__UNKNOWN_16 :: struct #copy {
    _: [16]u8 = default
}
__UNKNOWN_40 :: struct #copy {
    _: [40]u8 = default
}
__UNKNOWN_0 :: struct {}

#lib("./lib/imgui_bindings.lib")
#lib("./lib/imgui.lib")

import std.alloca
use import std.io.stdio

use import glfw

#export_scope
IM_COL32 :: (r: u8, g: u8, b: u8, a: u8 = 255) -> u32 #macro {
    @bin_or(
        @bin_lsl(u32(r), 0),
        @bin_lsl(u32(g), 8),
        @bin_lsl(u32(b), 16),
        @bin_lsl(u32(a), 24)
    )
}

FILE :: void
FLT_MAX :: f32.max

uintptr_t :: u64
va_list :: ^mut char8
size_t :: u64
ptrdiff_t :: i64
intptr_t :: i64
__vcrt_bool :: bool
ImTextureID :: ^mut void
ImGuiID :: u32
ImGuiInputTextCallback :: fn(^mut ImGuiInputTextCallbackData) -> i32
ImGuiSizeCallback :: fn(^mut ImGuiSizeCallbackData) -> void
ImWchar16 :: u16
ImWchar32 :: u32
ImWchar :: ImWchar16
ImS8 :: i8
ImU8 :: u8
ImS16 :: i16
ImU16 :: u16
ImS32 :: i32
ImU32 :: u32
ImS64 :: i64
ImU64 :: u64
ImGuiTextEditCallback :: ImGuiInputTextCallback
ImGuiTextEditCallbackData :: ImGuiInputTextCallbackData
ImDrawCallback :: fn(^mut ImDrawList, ^mut ImDrawCmd) -> void
ImDrawIdx :: u16
CustomRect :: ImFontAtlasCustomRect
GlyphRangesBuilder :: ImFontGlyphRangesBuilder
ImFileHandle :: ^mut FILE
ImPoolIdx :: i32
IMGUI_VERSION :: "1.79 WIP"
IMGUI_VERSION_NUM :: 17803
IMGUI_HAS_VIEWPORT :: 1
IMGUI_HAS_DOCK :: 1
IMGUI_PAYLOAD_TYPE_COLOR_3F :: "_COL3F"
IMGUI_PAYLOAD_TYPE_COLOR_4F :: "_COL4F"
IM_UNICODE_CODEPOINT_INVALID :: 0xFFFD
IM_UNICODE_CODEPOINT_MAX :: 0xFFFF
IM_COL32_R_SHIFT :: 0
IM_COL32_G_SHIFT :: 8
IM_COL32_B_SHIFT :: 16
IM_COL32_A_SHIFT :: 24
IM_COL32_A_MASK :: 0xFF000000
IM_COL32_WHITE :: IM_COL32(255,255,255,255)
IM_COL32_BLACK :: IM_COL32(0,0,0,255)
IM_COL32_BLACK_TRANS :: IM_COL32(0,0,0,0)
IM_DRAWLIST_TEX_LINES_WIDTH_MAX :: (63)
IMGUI_PAYLOAD_TYPE_WINDOW :: "_IMWINDOW"
IM_PI :: 3.14159265358979323846f
IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MIN :: 12
IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX :: 512
IM_DRAWLIST_ARCFAST_TESSELLATION_MULTIPLIER :: 1
ImGuiWindowFlags :: enum #copy #repr("C") #tag_type(i32) #flags {
    None                      = 0x0
    NoTitleBar                = 0x1
    NoResize                  = 0x2
    NoMove                    = 0x4
    NoScrollbar               = 0x8
    NoScrollWithMouse         = 0x10
    NoCollapse                = 0x20
    NoDecoration              = 0x2b
    AlwaysAutoResize          = 0x40
    NoBackground              = 0x80
    NoSavedSettings           = 0x100
    NoMouseInputs             = 0x200
    MenuBar                   = 0x400
    HorizontalScrollbar       = 0x800
    NoFocusOnAppearing        = 0x1000
    NoBringToFrontOnFocus     = 0x2000
    AlwaysVerticalScrollbar   = 0x4000
    AlwaysHorizontalScrollbar = 0x8000
    AlwaysUseWindowPadding    = 0x10000
    NoNavInputs               = 0x40000
    NoNavFocus                = 0x80000
    NoNav                     = 0xc0000
    NoInputs                  = 0xc0200
    UnsavedDocument           = 0x100000
    NoDocking                 = 0x200000
    NavFlattened              = 0x800000
    ChildWindow               = 0x1000000
    Tooltip                   = 0x2000000
    Popup                     = 0x4000000
    Modal                     = 0x8000000
    ChildMenu                 = 0x10000000
    DockNodeHost              = 0x20000000
}
ImGuiInputTextFlags :: enum #copy #repr("C") #tag_type(i32) #flags {
    None                = 0x0
    CharsDecimal        = 0x1
    CharsHexadecimal    = 0x2
    CharsUppercase      = 0x4
    CharsNoBlank        = 0x8
    AutoSelectAll       = 0x10
    EnterReturnsTrue    = 0x20
    CallbackCompletion  = 0x40
    CallbackHistory     = 0x80
    CallbackAlways      = 0x100
    CallbackCharFilter  = 0x200
    AllowTabInput       = 0x400
    CtrlEnterForNewLine = 0x800
    NoHorizontalScroll  = 0x1000
    AlwaysInsertMode    = 0x2000
    ReadOnly            = 0x4000
    Password            = 0x8000
    NoUndoRedo          = 0x10000
    CharsScientific     = 0x20000
    CallbackResize      = 0x40000
    CallbackEdit        = 0x80000
    Multiline           = 0x100000
    NoMarkEdited        = 0x200000
}
ImGuiTreeNodeFlags :: enum #copy #repr("C") #tag_type(i32) #flags {
    None                 = 0x0
    Selected             = 0x1
    Framed               = 0x2
    AllowItemOverlap     = 0x4
    NoTreePushOnOpen     = 0x8
    NoAutoOpenOnLog      = 0x10
    CollapsingHeader     = 0x1a
    DefaultOpen          = 0x20
    OpenOnDoubleClick    = 0x40
    OpenOnArrow          = 0x80
    Leaf                 = 0x100
    Bullet               = 0x200
    FramePadding         = 0x400
    SpanAvailWidth       = 0x800
    SpanFullWidth        = 0x1000
    NavLeftJumpsBackHere = 0x2000
}
ImGuiPopupFlags :: enum #copy #repr("C") #tag_type(i32) #flags {
    None                    = 0x0
    MouseButtonLeft         = 0x0
    MouseButtonRight        = 0x1
    MouseButtonDefault      = 0x1
    MouseButtonMiddle       = 0x2
    MouseButtonMask         = 0x1f
    NoOpenOverExistingPopup = 0x20
    NoOpenOverItems         = 0x40
    AnyPopupId              = 0x80
    AnyPopupLevel           = 0x100
    AnyPopup                = 0x180
}
ImGuiSelectableFlags :: enum #copy #repr("C") #tag_type(i32) #flags {
    None             = 0x0
    DontClosePopups  = 0x1
    SpanAllColumns   = 0x2
    AllowDoubleClick = 0x4
    Disabled         = 0x8
    AllowItemOverlap = 0x10
}
ImGuiComboFlags :: enum #copy #repr("C") #tag_type(i32) #flags {
    None           = 0x0
    PopupAlignLeft = 0x1
    HeightSmall    = 0x2
    HeightRegular  = 0x4
    HeightLarge    = 0x8
    HeightLargest  = 0x10
    HeightMask     = 0x1e
    NoArrowButton  = 0x20
    NoPreview      = 0x40
}
ImGuiTabBarFlags :: enum #copy #repr("C") #tag_type(i32) #flags {
    None                         = 0x0
    Reorderable                  = 0x1
    AutoSelectNewTabs            = 0x2
    TabListPopupButton           = 0x4
    NoCloseWithMiddleMouseButton = 0x8
    NoTabListScrollingButtons    = 0x10
    NoTooltip                    = 0x20
    FittingPolicyResizeDown      = 0x40
    FittingPolicyDefault         = 0x40
    FittingPolicyScroll          = 0x80
    FittingPolicyMask            = 0xc0
}
ImGuiTabItemFlags :: enum #copy #repr("C") #tag_type(i32) #flags {
    None                         = 0x0
    UnsavedDocument              = 0x1
    SetSelected                  = 0x2
    NoCloseWithMiddleMouseButton = 0x4
    NoPushId                     = 0x8
    NoTooltip                    = 0x10
}
ImGuiFocusedFlags :: enum #copy #repr("C") #tag_type(i32) #flags {
    None                = 0x0
    ChildWindows        = 0x1
    RootWindow          = 0x2
    RootAndChildWindows = 0x3
    AnyWindow           = 0x4
}
ImGuiHoveredFlags :: enum #copy #repr("C") #tag_type(i32) #flags {
    None                         = 0x0
    ChildWindows                 = 0x1
    RootWindow                   = 0x2
    RootAndChildWindows          = 0x3
    AnyWindow                    = 0x4
    AllowWhenBlockedByPopup      = 0x8
    AllowWhenBlockedByActiveItem = 0x20
    AllowWhenOverlapped          = 0x40
    RectOnly                     = 0x68
    AllowWhenDisabled            = 0x80
}
ImGuiDockNodeFlags :: enum #copy #repr("C") #tag_type(i32) #flags {
    None                   = 0x0
    KeepAliveOnly          = 0x1
    NoDockingInCentralNode = 0x4
    PassthruCentralNode    = 0x8
    NoSplit                = 0x10
    NoResize               = 0x20
    AutoHideTabBar         = 0x40
}
ImGuiDragDropFlags :: enum #copy #repr("C") #tag_type(i32) #flags {
    None                     = 0x0
    SourceNoPreviewTooltip   = 0x1
    SourceNoDisableHover     = 0x2
    SourceNoHoldToOpenOthers = 0x4
    SourceAllowNullID        = 0x8
    SourceExtern             = 0x10
    SourceAutoExpirePayload  = 0x20
    AcceptBeforeDelivery     = 0x400
    AcceptNoDrawDefaultRect  = 0x800
    AcceptPeekOnly           = 0xc00
    AcceptNoPreviewTooltip   = 0x1000
}
ImGuiDataType :: enum #copy #repr("C") #tag_type(i32) {
    S8     = 0x0
    U8     = 0x1
    S16    = 0x2
    U16    = 0x3
    S32    = 0x4
    U32    = 0x5
    S64    = 0x6
    U64    = 0x7
    Float  = 0x8
    Double = 0x9
    COUNT  = 0xa
}
ImGuiDir :: enum #copy #repr("C") #tag_type(i32) {
    None  = -1
    Left  = 0x0
    Right = 0x1
    Up    = 0x2
    Down  = 0x3
    COUNT = 0x4
}
ImGuiKey :: enum #copy #repr("C") #tag_type(i32) {
    Tab         = 0x0
    LeftArrow   = 0x1
    RightArrow  = 0x2
    UpArrow     = 0x3
    DownArrow   = 0x4
    PageUp      = 0x5
    PageDown    = 0x6
    Home        = 0x7
    End         = 0x8
    Insert      = 0x9
    Delete      = 0xa
    Backspace   = 0xb
    Space       = 0xc
    Enter       = 0xd
    Escape      = 0xe
    KeyPadEnter = 0xf
    A           = 0x10
    C           = 0x11
    V           = 0x12
    X           = 0x13
    Y           = 0x14
    Z           = 0x15
    COUNT       = 0x16
}
ImGuiKeyModFlags :: enum #copy #repr("C") #tag_type(i32) #flags {
    None  = 0x0
    Ctrl  = 0x1
    Shift = 0x2
    Alt   = 0x4
    Super = 0x8
}
ImGuiNavInput :: enum #copy #repr("C") #tag_type(i32) {
    Activate      = 0x0
    Cancel        = 0x1
    Input         = 0x2
    Menu          = 0x3
    DpadLeft      = 0x4
    DpadRight     = 0x5
    DpadUp        = 0x6
    DpadDown      = 0x7
    LStickLeft    = 0x8
    LStickRight   = 0x9
    LStickUp      = 0xa
    LStickDown    = 0xb
    FocusPrev     = 0xc
    FocusNext     = 0xd
    TweakSlow     = 0xe
    TweakFast     = 0xf
    KeyMenu       = 0x10
    InternalStart = 0x10
    KeyLeft       = 0x11
    KeyRight      = 0x12
    KeyUp         = 0x13
    KeyDown       = 0x14
    COUNT         = 0x15
}
ImGuiConfigFlags :: enum #copy #repr("C") #tag_type(i32) #flags {
    None                    = 0x0
    NavEnableKeyboard       = 0x1
    NavEnableGamepad        = 0x2
    NavEnableSetMousePos    = 0x4
    NavNoCaptureKeyboard    = 0x8
    NoMouse                 = 0x10
    NoMouseCursorChange     = 0x20
    DockingEnable           = 0x40
    ViewportsEnable         = 0x400
    DpiEnableScaleViewports = 0x4000
    DpiEnableScaleFonts     = 0x8000
    IsSRGB                  = 0x100000
    IsTouchScreen           = 0x200000
}
ImGuiBackendFlags :: enum #copy #repr("C") #tag_type(i32) #flags {
    None                    = 0x0
    HasGamepad              = 0x1
    HasMouseCursors         = 0x2
    HasSetMousePos          = 0x4
    RendererHasVtxOffset    = 0x8
    PlatformHasViewports    = 0x400
    HasMouseHoveredViewport = 0x800
    RendererHasViewports    = 0x1000
}
ImGuiCol :: enum #copy #repr("C") #tag_type(i32) {
    Text                  = 0x0
    TextDisabled          = 0x1
    WindowBg              = 0x2
    ChildBg               = 0x3
    PopupBg               = 0x4
    Border                = 0x5
    BorderShadow          = 0x6
    FrameBg               = 0x7
    FrameBgHovered        = 0x8
    FrameBgActive         = 0x9
    TitleBg               = 0xa
    TitleBgActive         = 0xb
    TitleBgCollapsed      = 0xc
    MenuBarBg             = 0xd
    ScrollbarBg           = 0xe
    ScrollbarGrab         = 0xf
    ScrollbarGrabHovered  = 0x10
    ScrollbarGrabActive   = 0x11
    CheckMark             = 0x12
    SliderGrab            = 0x13
    SliderGrabActive      = 0x14
    Button                = 0x15
    ButtonHovered         = 0x16
    ButtonActive          = 0x17
    Header                = 0x18
    HeaderHovered         = 0x19
    HeaderActive          = 0x1a
    Separator             = 0x1b
    SeparatorHovered      = 0x1c
    SeparatorActive       = 0x1d
    ResizeGrip            = 0x1e
    ResizeGripHovered     = 0x1f
    ResizeGripActive      = 0x20
    Tab                   = 0x21
    TabHovered            = 0x22
    TabActive             = 0x23
    TabUnfocused          = 0x24
    TabUnfocusedActive    = 0x25
    DockingPreview        = 0x26
    DockingEmptyBg        = 0x27
    PlotLines             = 0x28
    PlotLinesHovered      = 0x29
    PlotHistogram         = 0x2a
    PlotHistogramHovered  = 0x2b
    TextSelectedBg        = 0x2c
    DragDropTarget        = 0x2d
    NavHighlight          = 0x2e
    NavWindowingHighlight = 0x2f
    NavWindowingDimBg     = 0x30
    ModalWindowDimBg      = 0x31
    ModalWindowDarkening  = 0x31
    COUNT                 = 0x32
}
ImGuiStyleVar :: enum #copy #repr("C") #tag_type(i32) {
    Alpha               = 0x0
    WindowPadding       = 0x1
    WindowRounding      = 0x2
    WindowBorderSize    = 0x3
    WindowMinSize       = 0x4
    WindowTitleAlign    = 0x5
    ChildRounding       = 0x6
    ChildBorderSize     = 0x7
    PopupRounding       = 0x8
    PopupBorderSize     = 0x9
    FramePadding        = 0xa
    FrameRounding       = 0xb
    FrameBorderSize     = 0xc
    ItemSpacing         = 0xd
    ItemInnerSpacing    = 0xe
    IndentSpacing       = 0xf
    ScrollbarSize       = 0x10
    ScrollbarRounding   = 0x11
    GrabMinSize         = 0x12
    GrabRounding        = 0x13
    TabRounding         = 0x14
    ButtonTextAlign     = 0x15
    SelectableTextAlign = 0x16
    COUNT               = 0x17
    Count               = 0x17
}
ImGuiButtonFlags :: enum #copy #repr("C") #tag_type(i32) #flags {
    None               = 0x0
    MouseButtonLeft    = 0x1
    MouseButtonDefault = 0x1
    MouseButtonRight   = 0x2
    MouseButtonMiddle  = 0x4
    MouseButtonMask    = 0x7
}
ImGuiColorEditFlags :: enum #copy #repr("C") #tag_type(i32) #flags {
    None             = 0x0
    NoAlpha          = 0x2
    NoPicker         = 0x4
    NoOptions        = 0x8
    NoSmallPreview   = 0x10
    NoInputs         = 0x20
    NoTooltip        = 0x40
    NoLabel          = 0x80
    NoSidePreview    = 0x100
    NoDragDrop       = 0x200
    NoBorder         = 0x400
    AlphaBar         = 0x10000
    AlphaPreview     = 0x20000
    AlphaPreviewHalf = 0x40000
    HDR              = 0x80000
    DisplayRGB       = 0x100000
    RGB              = 0x100000
    DisplayHSV       = 0x200000
    HSV              = 0x200000
    DisplayHex       = 0x400000
    HEX              = 0x400000
    DisplayMask      = 0x700000
    Uint8            = 0x800000
    Float            = 0x1000000
    DataTypeMask     = 0x1800000
    PickerHueBar     = 0x2000000
    PickerHueWheel   = 0x4000000
    PickerMask       = 0x6000000
    InputRGB         = 0x8000000
    OptionsDefault   = 0xa900000
    InputHSV         = 0x10000000
    InputMask        = 0x18000000
}
ImGuiSliderFlags :: enum #copy #repr("C") #tag_type(i32) #flags {
    None            = 0x0
    ClampOnInput    = 0x10
    Logarithmic     = 0x20
    NoRoundToFormat = 0x40
    NoInput         = 0x80
    InvalidMask     = 0x7000000f
}
ImGuiMouseButton :: enum #copy #repr("C") #tag_type(i32) {
    Left   = 0x0
    Right  = 0x1
    Middle = 0x2
    COUNT  = 0x5
}
ImGuiMouseCursor :: enum #copy #repr("C") #tag_type(i32) {
    None       = -1
    Arrow      = 0x0
    TextInput  = 0x1
    ResizeAll  = 0x2
    ResizeNS   = 0x3
    ResizeEW   = 0x4
    ResizeNESW = 0x5
    ResizeNWSE = 0x6
    Hand       = 0x7
    NotAllowed = 0x8
    COUNT      = 0x9
    Count      = 0x9
}
ImGuiCond :: enum #copy #repr("C") #tag_type(i32) {
    None         = 0x0
    Always       = 0x1
    Once         = 0x2
    FirstUseEver = 0x4
    Appearing    = 0x8
}
ImDrawCornerFlags :: enum #copy #repr("C") #tag_type(i32) #flags {
    None     = 0x0
    TopLeft  = 0x1
    TopRight = 0x2
    Top      = 0x3
    BotLeft  = 0x4
    Left     = 0x5
    BotRight = 0x8
    Right    = 0xa
    Bot      = 0xc
    All      = 0xf
}
ImDrawListFlags :: enum #copy #repr("C") #tag_type(i32) #flags {
    None                   = 0x0
    AntiAliasedLines       = 0x1
    AntiAliasedLinesUseTex = 0x2
    AntiAliasedFill        = 0x4
    AllowVtxOffset         = 0x8
}
ImFontAtlasFlags :: enum #copy #repr("C") #tag_type(i32) #flags {
    None               = 0x0
    NoPowerOfTwoHeight = 0x1
    NoMouseCursors     = 0x2
    NoBakedLines       = 0x4
}
ImGuiViewportFlags :: enum #copy #repr("C") #tag_type(i32) #flags {
    None                = 0x0
    NoDecoration        = 0x1
    NoTaskBarIcon       = 0x2
    NoFocusOnAppearing  = 0x4
    NoFocusOnClick      = 0x8
    NoInputs            = 0x10
    NoRendererClear     = 0x20
    TopMost             = 0x40
    Minimized           = 0x80
    NoAutoMerge         = 0x100
    CanHostOtherWindows = 0x200
}
ImGuiItemFlags :: enum #copy #repr("C") #tag_type(i32) #flags {
    None                     = 0x0
    Default                  = 0x0
    NoTabStop                = 0x1
    ButtonRepeat             = 0x2
    Disabled                 = 0x4
    NoNav                    = 0x8
    NoNavDefaultFocus        = 0x10
    SelectableDontClosePopup = 0x20
    MixedValue               = 0x40
    ReadOnly                 = 0x80
}
ImGuiItemStatusFlags :: enum #copy #repr("C") #tag_type(i32) #flags {
    None             = 0x0
    HoveredRect      = 0x1
    HasDisplayRect   = 0x2
    Edited           = 0x4
    ToggledSelection = 0x8
    ToggledOpen      = 0x10
    HasDeactivated   = 0x20
    Deactivated      = 0x40
}
ImGuiButtonFlagsPrivate :: enum #copy #repr("C") #tag_type(i32) #flags {
    PressedOnClick                = 0x10
    PressedOnClickRelease         = 0x20
    PressedOnDefault              = 0x20
    PressedOnClickReleaseAnywhere = 0x40
    PressedOnRelease              = 0x80
    PressedOnDoubleClick          = 0x100
    PressedOnDragDropHold         = 0x200
    PressedOnMask                 = 0x3f0
    Repeat                        = 0x400
    FlattenChildren               = 0x800
    AllowItemOverlap              = 0x1000
    DontClosePopups               = 0x2000
    Disabled                      = 0x4000
    AlignTextBaseLine             = 0x8000
    NoKeyModifiers                = 0x10000
    NoHoldingActiveId             = 0x20000
    NoNavFocus                    = 0x40000
    NoHoveredOnFocus              = 0x80000
}
ImGuiSliderFlagsPrivate :: enum #copy #repr("C") #tag_type(i32) #flags {
    Vertical = 0x100000
    ReadOnly = 0x200000
}
ImGuiSelectableFlagsPrivate :: enum #copy #repr("C") #tag_type(i32) #flags {
    NoHoldingActiveID    = 0x100000
    SelectOnClick        = 0x200000
    SelectOnRelease      = 0x400000
    SpanAvailWidth       = 0x800000
    DrawHoveredWhenHeld  = 0x1000000
    SetNavIdOnHover      = 0x2000000
    NoPadWithHalfSpacing = 0x4000000
}
ImGuiTreeNodeFlagsPrivate :: enum #copy #repr("C") #tag_type(i32) #flags {
    ClipLabelForTrailingButton = 0x100000
}
ImGuiSeparatorFlags :: enum #copy #repr("C") #tag_type(i32) #flags {
    None           = 0x0
    Horizontal     = 0x1
    Vertical       = 0x2
    SpanAllColumns = 0x4
}
ImGuiTextFlags :: enum #copy #repr("C") #tag_type(i32) #flags {
    None                       = 0x0
    NoWidthForLargeClippedText = 0x1
}
ImGuiTooltipFlags :: enum #copy #repr("C") #tag_type(i32) #flags {
    None                    = 0x0
    OverridePreviousTooltip = 0x1
}
ImGuiLayoutType :: enum #copy #repr("C") #tag_type(i32) {
    Horizontal = 0x0
    Vertical   = 0x1
}
ImGuiLogType :: enum #copy #repr("C") #tag_type(i32) {
    None      = 0x0
    TTY       = 0x1
    File      = 0x2
    Buffer    = 0x3
    Clipboard = 0x4
}
ImGuiAxis :: enum #copy #repr("C") #tag_type(i32) {
    None = -1
    X    = 0x0
    Y    = 0x1
}
ImGuiPlotType :: enum #copy #repr("C") #tag_type(i32) {
    Lines     = 0x0
    Histogram = 0x1
}
ImGuiInputSource :: enum #copy #repr("C") #tag_type(i32) {
    None        = 0x0
    Mouse       = 0x1
    Nav         = 0x2
    NavKeyboard = 0x3
    NavGamepad  = 0x4
    COUNT       = 0x5
}
ImGuiInputReadMode :: enum #copy #repr("C") #tag_type(i32) {
    Down       = 0x0
    Pressed    = 0x1
    Released   = 0x2
    Repeat     = 0x3
    RepeatSlow = 0x4
    RepeatFast = 0x5
}
ImGuiNavHighlightFlags :: enum #copy #repr("C") #tag_type(i32) #flags {
    None        = 0x0
    TypeDefault = 0x1
    TypeThin    = 0x2
    AlwaysDraw  = 0x4
    NoRounding  = 0x8
}
ImGuiNavDirSourceFlags :: enum #copy #repr("C") #tag_type(i32) #flags {
    None      = 0x0
    Keyboard  = 0x1
    PadDPad   = 0x2
    PadLStick = 0x4
}
ImGuiNavMoveFlags :: enum #copy #repr("C") #tag_type(i32) #flags {
    None                = 0x0
    LoopX               = 0x1
    LoopY               = 0x2
    WrapX               = 0x4
    WrapY               = 0x8
    AllowCurrentNavId   = 0x10
    AlsoScoreVisibleSet = 0x20
    ScrollToEdge        = 0x40
}
ImGuiNavForward :: enum #copy #repr("C") #tag_type(i32) {
    None          = 0x0
    ForwardQueued = 0x1
    ForwardActive = 0x2
}
ImGuiNavLayer :: enum #copy #repr("C") #tag_type(i32) {
    Main  = 0x0
    Menu  = 0x1
    COUNT = 0x2
}
ImGuiPopupPositionPolicy :: enum #copy #repr("C") #tag_type(i32) {
    Default  = 0x0
    ComboBox = 0x1
}
ImGuiDataTypePrivate :: enum #copy #repr("C") #tag_type(i32) {
    String  = 0xb
    Pointer = 0xc
    ID      = 0xd
}
ImGuiNextWindowDataFlags :: enum #copy #repr("C") #tag_type(i32) #flags {
    None              = 0x0
    HasPos            = 0x1
    HasSize           = 0x2
    HasContentSize    = 0x4
    HasCollapsed      = 0x8
    HasSizeConstraint = 0x10
    HasFocus          = 0x20
    HasBgAlpha        = 0x40
    HasScroll         = 0x80
    HasViewport       = 0x100
    HasDock           = 0x200
    HasWindowClass    = 0x400
}
ImGuiNextItemDataFlags :: enum #copy #repr("C") #tag_type(i32) #flags {
    None     = 0x0
    HasWidth = 0x1
    HasOpen  = 0x2
}
ImGuiColumnsFlags :: enum #copy #repr("C") #tag_type(i32) #flags {
    None                   = 0x0
    NoBorder               = 0x1
    NoResize               = 0x2
    NoPreserveWidths       = 0x4
    NoForceWithinWindow    = 0x8
    GrowParentContentsSize = 0x10
}
ImGuiDockNodeFlagsPrivate :: enum #copy #repr("C") #tag_type(i32) #flags {
    SharedFlagsInheritMask = -1
    DockSpace              = 0x400
    CentralNode            = 0x800
    NoTabBar               = 0x1000
    HiddenTabBar           = 0x2000
    NoWindowMenuButton     = 0x4000
    NoCloseButton          = 0x8000
    NoDocking              = 0x10000
    NoDockingSplitMe       = 0x20000
    NoDockingSplitOther    = 0x40000
    NoDockingOverMe        = 0x80000
    NoDockingOverOther     = 0x100000
    NoResizeX              = 0x200000
    NoResizeY              = 0x400000
    NoResizeFlagsMask      = 0x600020
    LocalFlagsTransferMask = 0x61f870
    SavedFlagsMask         = 0x61fc20
    LocalFlagsMask         = 0x61fc70
}
ImGuiDataAuthority :: enum #copy #repr("C") #tag_type(i32) {
    Auto     = 0x0
    DockNode = 0x1
    Window   = 0x2
}
ImGuiDockNodeState :: enum #copy #repr("C") #tag_type(i32) {
    Unknown                                   = 0x0
    HostWindowHiddenBecauseSingleWindow       = 0x1
    HostWindowHiddenBecauseWindowsAreResizing = 0x2
    HostWindowVisible                         = 0x3
}
ImGuiTabBarFlagsPrivate :: enum #copy #repr("C") #tag_type(i32) #flags {
    DockNode     = 0x100000
    IsFocused    = 0x200000
    SaveSettings = 0x400000
}
ImGuiTabItemFlagsPrivate :: enum #copy #repr("C") #tag_type(i32) #flags {
    NoCloseButton = 0x100000
    Unsorted      = 0x200000
    Preview       = 0x400000
}
ImVec2 :: struct #copy {
    x : f32 = default
    y : f32 = default
}
impl ImVec2 {
    new :: () -> ImVec2 {
        result : ImVec2 = default
        __c__ImVec2_new_2(^mut result)
        return result
    }
    new :: (__x: f32, __y: f32) -> ImVec2 {
        result : ImVec2 = default
        __c__ImVec2_new_3(^mut result, __x, __y)
        return result
    }
}
ImVec4 :: struct #copy {
    x : f32 = default
    y : f32 = default
    z : f32 = default
    w : f32 = default
}
impl ImVec4 {
    new :: () -> ImVec4 {
        result : ImVec4 = default
        __c__ImVec4_new_4(^mut result)
        return result
    }
    new :: (__x: f32, __y: f32, __z: f32, __w: f32) -> ImVec4 {
        result : ImVec4 = default
        __c__ImVec4_new_5(^mut result, __x, __y, __z, __w)
        return result
    }
}
ImNewWrapper :: struct #copy {
}
ImGuiStyle :: struct #copy {
    Alpha : f32 = default
    WindowPadding : ImVec2 = default
    WindowRounding : f32 = default
    WindowBorderSize : f32 = default
    WindowMinSize : ImVec2 = default
    WindowTitleAlign : ImVec2 = default
    WindowMenuButtonPosition : ImGuiDir = default
    ChildRounding : f32 = default
    ChildBorderSize : f32 = default
    PopupRounding : f32 = default
    PopupBorderSize : f32 = default
    FramePadding : ImVec2 = default
    FrameRounding : f32 = default
    FrameBorderSize : f32 = default
    ItemSpacing : ImVec2 = default
    ItemInnerSpacing : ImVec2 = default
    TouchExtraPadding : ImVec2 = default
    IndentSpacing : f32 = default
    ColumnsMinSpacing : f32 = default
    ScrollbarSize : f32 = default
    ScrollbarRounding : f32 = default
    GrabMinSize : f32 = default
    GrabRounding : f32 = default
    LogSliderDeadzone : f32 = default
    TabRounding : f32 = default
    TabBorderSize : f32 = default
    TabMinWidthForUnselectedCloseButton : f32 = default
    ColorButtonPosition : ImGuiDir = default
    ButtonTextAlign : ImVec2 = default
    SelectableTextAlign : ImVec2 = default
    DisplayWindowPadding : ImVec2 = default
    DisplaySafeAreaPadding : ImVec2 = default
    MouseCursorScale : f32 = default
    AntiAliasedLines : bool = default
    AntiAliasedLinesUseTex : bool = default
    AntiAliasedFill : bool = default
    CurveTessellationTol : f32 = default
    CircleSegmentMaxError : f32 = default
    Colors : [50]ImVec4 = default
}
impl ImGuiStyle {
    new :: () -> ImGuiStyle {
        result : ImGuiStyle = default
        __c__ImGuiStyle_new_39(^mut result)
        return result
    }
    ScaleAllSizes :: (&mut Self, _scale_factor: f32) {
        __c__ImGuiStyle_ScaleAllSizes_40(^mut *self, _scale_factor)
    }
}
ImGuiIO :: struct #copy {
    ConfigFlags : ImGuiConfigFlags = default
    BackendFlags : ImGuiBackendFlags = default
    DisplaySize : ImVec2 = default
    DeltaTime : f32 = default
    IniSavingRate : f32 = default
    IniFilename : ^char8 = default
    LogFilename : ^char8 = default
    MouseDoubleClickTime : f32 = default
    MouseDoubleClickMaxDist : f32 = default
    MouseDragThreshold : f32 = default
    KeyMap : [22]i32 = default
    KeyRepeatDelay : f32 = default
    KeyRepeatRate : f32 = default
    UserData : ^mut void = default
    Fonts : ^mut ImFontAtlas = default
    FontGlobalScale : f32 = default
    FontAllowUserScaling : bool = default
    FontDefault : ^mut ImFont = default
    DisplayFramebufferScale : ImVec2 = default
    ConfigDockingNoSplit : bool = default
    ConfigDockingWithShift : bool = default
    ConfigDockingAlwaysTabBar : bool = default
    ConfigDockingTransparentPayload : bool = default
    ConfigViewportsNoAutoMerge : bool = default
    ConfigViewportsNoTaskBarIcon : bool = default
    ConfigViewportsNoDecoration : bool = default
    ConfigViewportsNoDefaultParent : bool = default
    MouseDrawCursor : bool = default
    ConfigMacOSXBehaviors : bool = default
    ConfigInputTextCursorBlink : bool = default
    ConfigWindowsResizeFromEdges : bool = default
    ConfigWindowsMoveFromTitleBarOnly : bool = default
    ConfigWindowsMemoryCompactTimer : f32 = default
    BackendPlatformName : ^char8 = default
    BackendRendererName : ^char8 = default
    BackendPlatformUserData : ^mut void = default
    BackendRendererUserData : ^mut void = default
    BackendLanguageUserData : ^mut void = default
    GetClipboardTextFn : fn(^mut void) -> ^char8 = default
    SetClipboardTextFn : fn(^mut void, ^char8) -> void = default
    ClipboardUserData : ^mut void = default
    RenderDrawListsFn : fn(^mut ImDrawData) -> void = default
    MousePos : ImVec2 = default
    MouseDown : [5]bool = default
    MouseWheel : f32 = default
    MouseWheelH : f32 = default
    MouseHoveredViewport : ImGuiID = default
    KeyCtrl : bool = default
    KeyShift : bool = default
    KeyAlt : bool = default
    KeySuper : bool = default
    KeysDown : [512]bool = default
    NavInputs : [21]f32 = default
    WantCaptureMouse : bool = default
    WantCaptureKeyboard : bool = default
    WantTextInput : bool = default
    WantSetMousePos : bool = default
    WantSaveIniSettings : bool = default
    NavActive : bool = default
    NavVisible : bool = default
    Framerate : f32 = default
    MetricsRenderVertices : i32 = default
    MetricsRenderIndices : i32 = default
    MetricsRenderWindows : i32 = default
    MetricsActiveWindows : i32 = default
    MetricsActiveAllocations : i32 = default
    MouseDelta : ImVec2 = default
    KeyMods : ImGuiKeyModFlags = default
    MousePosPrev : ImVec2 = default
    MouseClickedPos : [5]ImVec2 = default
    MouseClickedTime : [5]f64 = default
    MouseClicked : [5]bool = default
    MouseDoubleClicked : [5]bool = default
    MouseReleased : [5]bool = default
    MouseDownOwned : [5]bool = default
    MouseDownWasDoubleClick : [5]bool = default
    MouseDownDuration : [5]f32 = default
    MouseDownDurationPrev : [5]f32 = default
    MouseDragMaxDistanceAbs : [5]ImVec2 = default
    MouseDragMaxDistanceSqr : [5]f32 = default
    KeysDownDuration : [512]f32 = default
    KeysDownDurationPrev : [512]f32 = default
    NavInputsDownDuration : [21]f32 = default
    NavInputsDownDurationPrev : [21]f32 = default
    PenPressure : f32 = default
    InputQueueSurrogate : ImWchar16 = default
    InputQueueCharacters : __UNKNOWN_16 = default
}
impl ImGuiIO {
    AddInputCharacter :: (&mut Self, _c: u32) {
        __c__ImGuiIO_AddInputCharacter_53(^mut *self, _c)
    }
    AddInputCharacterUTF16 :: (&mut Self, _c: ImWchar16) {
        __c__ImGuiIO_AddInputCharacterUTF16_54(^mut *self, _c)
    }
    AddInputCharactersUTF8 :: (&mut Self, _str: ^char8) {
        __c__ImGuiIO_AddInputCharactersUTF8_55(^mut *self, _str)
    }
    ClearInputCharacters :: (&mut Self) {
        __c__ImGuiIO_ClearInputCharacters_56(^mut *self)
    }
    new :: () -> ImGuiIO {
        result : ImGuiIO = default
        __c__ImGuiIO_new_91(^mut result)
        return result
    }
}
ImGuiInputTextCallbackData :: struct #copy {
    EventFlag : ImGuiInputTextFlags = default
    Flags : ImGuiInputTextFlags = default
    UserData : ^mut void = default
    EventChar : ImWchar = default
    EventKey : ImGuiKey = default
    Buf : ^mut char8 = default
    BufTextLen : i32 = default
    BufSize : i32 = default
    BufDirty : bool = default
    CursorPos : i32 = default
    SelectionStart : i32 = default
    SelectionEnd : i32 = default
}
impl ImGuiInputTextCallbackData {
    new :: () -> ImGuiInputTextCallbackData {
        result : ImGuiInputTextCallbackData = default
        __c__ImGuiInputTextCallbackData_new_12(^mut result)
        return result
    }
    DeleteChars :: (&mut Self, _pos: i32, _bytes_count: i32) {
        __c__ImGuiInputTextCallbackData_DeleteChars_13(^mut *self, _pos, _bytes_count)
    }
    InsertChars :: (&mut Self, _pos: i32, _text: ^char8, _text_end: ^char8) {
        __c__ImGuiInputTextCallbackData_InsertChars_14(^mut *self, _pos, _text, _text_end)
    }
    SelectAll :: (&mut Self) {
        __c__ImGuiInputTextCallbackData_SelectAll_15(^mut *self)
    }
    ClearSelection :: (&mut Self) {
        __c__ImGuiInputTextCallbackData_ClearSelection_16(^mut *self)
    }
    HasSelection :: (&mut Self) -> bool {
        mut result : bool = default
        __c__ImGuiInputTextCallbackData_HasSelection_17(^mut *self, ^mut result)
        return result
    }
}
ImGuiSizeCallbackData :: struct #copy {
    UserData : ^mut void = default
    Pos : ImVec2 = default
    CurrentSize : ImVec2 = default
    DesiredSize : ImVec2 = default
}
ImGuiWindowClass :: struct #copy {
    ClassId : ImGuiID = default
    ParentViewportId : ImGuiID = default
    ViewportFlagsOverrideSet : ImGuiViewportFlags = default
    ViewportFlagsOverrideClear : ImGuiViewportFlags = default
    DockNodeFlagsOverrideSet : ImGuiDockNodeFlags = default
    DockNodeFlagsOverrideClear : ImGuiDockNodeFlags = default
    DockingAlwaysTabBar : bool = default
    DockingAllowUnclassed : bool = default
}
impl ImGuiWindowClass {
    new :: () -> ImGuiWindowClass {
        result : ImGuiWindowClass = default
        __c__ImGuiWindowClass_new_8(^mut result)
        return result
    }
}
ImGuiPayload :: struct #copy {
    Data : ^mut void = default
    DataSize : i32 = default
    SourceId : ImGuiID = default
    SourceParentId : ImGuiID = default
    DataFrameCount : i32 = default
    DataType : [33]char8 = default
    Preview : bool = default
    Delivery : bool = default
}
impl ImGuiPayload {
    new :: () -> ImGuiPayload {
        result : ImGuiPayload = default
        __c__ImGuiPayload_new_8(^mut result)
        return result
    }
    Clear :: (&mut Self) {
        __c__ImGuiPayload_Clear_9(^mut *self)
    }
    IsDataType :: (&mut Self, _type: ^char8) -> bool {
        mut result : bool = default
        __c__ImGuiPayload_IsDataType_10(^mut *self, ^mut result, _type)
        return result
    }
    IsPreview :: (&mut Self) -> bool {
        mut result : bool = default
        __c__ImGuiPayload_IsPreview_11(^mut *self, ^mut result)
        return result
    }
    IsDelivery :: (&mut Self) -> bool {
        mut result : bool = default
        __c__ImGuiPayload_IsDelivery_12(^mut *self, ^mut result)
        return result
    }
}
ImGuiOnceUponAFrame :: struct #copy {
    RefFrame : i32 = default
}
impl ImGuiOnceUponAFrame {
    new :: () -> ImGuiOnceUponAFrame {
        result : ImGuiOnceUponAFrame = default
        __c__ImGuiOnceUponAFrame_new_0(^mut result)
        return result
    }
}
ImGuiTextFilter :: struct #copy {
    InputBuf : [256]char8 = default
    Filters : __UNKNOWN_16 = default
    CountGrep : i32 = default
}
impl ImGuiTextFilter {
    new :: (_default_filter: ^char8) -> ImGuiTextFilter {
        result : ImGuiTextFilter = default
        __c__ImGuiTextFilter_new_0(^mut result, _default_filter)
        return result
    }
    Draw :: (&mut Self, _label: ^char8, _width: f32) -> bool {
        mut result : bool = default
        __c__ImGuiTextFilter_Draw_1(^mut *self, ^mut result, _label, _width)
        return result
    }
    PassFilter :: (&mut Self, _text: ^char8, _text_end: ^char8) -> bool {
        mut result : bool = default
        __c__ImGuiTextFilter_PassFilter_2(^mut *self, ^mut result, _text, _text_end)
        return result
    }
    Build :: (&mut Self) {
        __c__ImGuiTextFilter_Build_3(^mut *self)
    }
    Clear :: (&mut Self) {
        __c__ImGuiTextFilter_Clear_4(^mut *self)
    }
    IsActive :: (&mut Self) -> bool {
        mut result : bool = default
        __c__ImGuiTextFilter_IsActive_5(^mut *self, ^mut result)
        return result
    }
}
ImGuiTextRange :: struct #copy {
    b : ^char8 = default
    e : ^char8 = default
}
impl ImGuiTextRange {
    new :: () -> ImGuiTextRange {
        result : ImGuiTextRange = default
        __c__ImGuiTextRange_new_2(^mut result)
        return result
    }
    new :: (__b: ^char8, __e: ^char8) -> ImGuiTextRange {
        result : ImGuiTextRange = default
        __c__ImGuiTextRange_new_3(^mut result, __b, __e)
        return result
    }
    empty :: (&mut Self) -> bool {
        mut result : bool = default
        __c__ImGuiTextRange_empty_4(^mut *self, ^mut result)
        return result
    }
    split :: (&mut Self, _separator: char8, _out: ^mut __UNKNOWN_16) {
        __c__ImGuiTextRange_split_5(^mut *self, _separator, _out)
    }
}
ImGuiTextBuffer :: struct #copy {
    Buf : __UNKNOWN_16 = default
}
impl ImGuiTextBuffer {
    new :: () -> ImGuiTextBuffer {
        result : ImGuiTextBuffer = default
        __c__ImGuiTextBuffer_new_2(^mut result)
        return result
    }
    begin :: (&mut Self) -> ^char8 {
        mut result : ^char8 = default
        __c__ImGuiTextBuffer_begin_4(^mut *self, ^mut result)
        return result
    }
    end :: (&mut Self) -> ^char8 {
        mut result : ^char8 = default
        __c__ImGuiTextBuffer_end_5(^mut *self, ^mut result)
        return result
    }
    size :: (&mut Self) -> i32 {
        mut result : i32 = default
        __c__ImGuiTextBuffer_size_6(^mut *self, ^mut result)
        return result
    }
    empty :: (&mut Self) -> bool {
        mut result : bool = default
        __c__ImGuiTextBuffer_empty_7(^mut *self, ^mut result)
        return result
    }
    clear :: (&mut Self) {
        __c__ImGuiTextBuffer_clear_8(^mut *self)
    }
    reserve :: (&mut Self, _capacity: i32) {
        __c__ImGuiTextBuffer_reserve_9(^mut *self, _capacity)
    }
    c_str :: (&mut Self) -> ^char8 {
        mut result : ^char8 = default
        __c__ImGuiTextBuffer_c_str_10(^mut *self, ^mut result)
        return result
    }
    append :: (&mut Self, _str: ^char8, _str_end: ^char8) {
        __c__ImGuiTextBuffer_append_11(^mut *self, _str, _str_end)
    }
    appendf :: (&mut Self, _fmt: ^char8) {
        __c__ImGuiTextBuffer_appendf_12(^mut *self, _fmt)
    }
    appendfv :: (&mut Self, _fmt: ^char8, _args: va_list) {
        __c__ImGuiTextBuffer_appendfv_13(^mut *self, _fmt, _args)
    }
}
ImGuiStorage :: struct #copy {
    Data : __UNKNOWN_16 = default
}
impl ImGuiStorage {
    Clear :: (&mut Self) {
        __c__ImGuiStorage_Clear_2(^mut *self)
    }
    GetInt :: (&mut Self, _key: ImGuiID, _default_val: i32) -> i32 {
        mut result : i32 = default
        __c__ImGuiStorage_GetInt_3(^mut *self, ^mut result, _key, _default_val)
        return result
    }
    SetInt :: (&mut Self, _key: ImGuiID, _val: i32) {
        __c__ImGuiStorage_SetInt_4(^mut *self, _key, _val)
    }
    GetBool :: (&mut Self, _key: ImGuiID, _default_val: bool) -> bool {
        mut result : bool = default
        __c__ImGuiStorage_GetBool_5(^mut *self, ^mut result, _key, _default_val)
        return result
    }
    SetBool :: (&mut Self, _key: ImGuiID, _val: bool) {
        __c__ImGuiStorage_SetBool_6(^mut *self, _key, _val)
    }
    GetFloat :: (&mut Self, _key: ImGuiID, _default_val: f32) -> f32 {
        mut result : f32 = default
        __c__ImGuiStorage_GetFloat_7(^mut *self, ^mut result, _key, _default_val)
        return result
    }
    SetFloat :: (&mut Self, _key: ImGuiID, _val: f32) {
        __c__ImGuiStorage_SetFloat_8(^mut *self, _key, _val)
    }
    GetVoidPtr :: (&mut Self, _key: ImGuiID) -> ^mut void {
        mut result : ^mut void = default
        __c__ImGuiStorage_GetVoidPtr_9(^mut *self, ^mut result, _key)
        return result
    }
    SetVoidPtr :: (&mut Self, _key: ImGuiID, _val: ^mut void) {
        __c__ImGuiStorage_SetVoidPtr_10(^mut *self, _key, _val)
    }
    GetIntRef :: (&mut Self, _key: ImGuiID, _default_val: i32) -> ^mut i32 {
        mut result : ^mut i32 = default
        __c__ImGuiStorage_GetIntRef_11(^mut *self, ^mut result, _key, _default_val)
        return result
    }
    GetBoolRef :: (&mut Self, _key: ImGuiID, _default_val: bool) -> ^mut bool {
        mut result : ^mut bool = default
        __c__ImGuiStorage_GetBoolRef_12(^mut *self, ^mut result, _key, _default_val)
        return result
    }
    GetFloatRef :: (&mut Self, _key: ImGuiID, _default_val: f32) -> ^mut f32 {
        mut result : ^mut f32 = default
        __c__ImGuiStorage_GetFloatRef_13(^mut *self, ^mut result, _key, _default_val)
        return result
    }
    GetVoidPtrRef :: (&mut Self, _key: ImGuiID, _default_val: ^mut void) -> ^mut ^mut void {
        mut result : ^mut ^mut void = default
        __c__ImGuiStorage_GetVoidPtrRef_14(^mut *self, ^mut result, _key, _default_val)
        return result
    }
    SetAllInt :: (&mut Self, _val: i32) {
        __c__ImGuiStorage_SetAllInt_15(^mut *self, _val)
    }
    BuildSortByKey :: (&mut Self) {
        __c__ImGuiStorage_BuildSortByKey_16(^mut *self)
    }
}
ImGuiStoragePair :: struct #copy {
    key : ImGuiID = default
}
impl ImGuiStoragePair {
    new :: (__key: ImGuiID, __val_i: i32) -> ImGuiStoragePair {
        result : ImGuiStoragePair = default
        __c__ImGuiStoragePair_new_2(^mut result, __key, __val_i)
        return result
    }
    new :: (__key: ImGuiID, __val_f: f32) -> ImGuiStoragePair {
        result : ImGuiStoragePair = default
        __c__ImGuiStoragePair_new_3(^mut result, __key, __val_f)
        return result
    }
    new :: (__key: ImGuiID, __val_p: ^mut void) -> ImGuiStoragePair {
        result : ImGuiStoragePair = default
        __c__ImGuiStoragePair_new_4(^mut result, __key, __val_p)
        return result
    }
}
ImGuiListClipper :: struct #copy {
    DisplayStart : i32 = default
    DisplayEnd : i32 = default
    ItemsCount : i32 = default
    StepNo : i32 = default
    ItemsHeight : f32 = default
    StartPosY : f32 = default
}
impl ImGuiListClipper {
    new :: (_items_count: i32, _items_height: f32) -> ImGuiListClipper {
        result : ImGuiListClipper = default
        __c__ImGuiListClipper_new_6(^mut result, _items_count, _items_height)
        return result
    }
    Step :: (&mut Self) -> bool {
        mut result : bool = default
        __c__ImGuiListClipper_Step_8(^mut *self, ^mut result)
        return result
    }
    Begin :: (&mut Self, _items_count: i32, _items_height: f32) {
        __c__ImGuiListClipper_Begin_9(^mut *self, _items_count, _items_height)
    }
    End :: (&mut Self) {
        __c__ImGuiListClipper_End_10(^mut *self)
    }
}
impl Drop for ImGuiListClipper {
    drop :: (&mut Self) {
        __c__ImGuiListClipper_dtor(^*self)
    }
}
ImColor :: struct #copy {
    Value : ImVec4 = default
}
impl ImColor {
    new :: () -> ImColor {
        result : ImColor = default
        __c__ImColor_new_1(^mut result)
        return result
    }
    new :: (_r: i32, _g: i32, _b: i32, _a: i32) -> ImColor {
        result : ImColor = default
        __c__ImColor_new_2(^mut result, _r, _g, _b, _a)
        return result
    }
    new :: (_rgba: ImU32) -> ImColor {
        result : ImColor = default
        __c__ImColor_new_3(^mut result, _rgba)
        return result
    }
    new :: (_r: f32, _g: f32, _b: f32, _a: f32) -> ImColor {
        result : ImColor = default
        __c__ImColor_new_4(^mut result, _r, _g, _b, _a)
        return result
    }
    new :: (_col: &mut ImVec4) -> ImColor {
        result : ImColor = default
        __c__ImColor_new_5(^mut result, ^mut *_col)
        return result
    }
    SetHSV :: (&mut Self, _h: f32, _s: f32, _v: f32, _a: f32) {
        __c__ImColor_SetHSV_8(^mut *self, _h, _s, _v, _a)
    }
    HSV :: (&mut Self, _h: f32, _s: f32, _v: f32, _a: f32) -> ImColor {
        mut result : ImColor = default
        __c__ImColor_HSV_9(^mut *self, ^mut result, _h, _s, _v, _a)
        return result
    }
}
ImDrawCmd :: struct #copy {
    ClipRect : ImVec4 = default
    TextureId : ImTextureID = default
    VtxOffset : u32 = default
    IdxOffset : u32 = default
    ElemCount : u32 = default
    UserCallback : ImDrawCallback = default
    UserCallbackData : ^mut void = default
}
impl ImDrawCmd {
    new :: () -> ImDrawCmd {
        result : ImDrawCmd = default
        __c__ImDrawCmd_new_7(^mut result)
        return result
    }
}
ImDrawVert :: struct #copy {
    pos : ImVec2 = default
    uv : ImVec2 = default
    col : ImU32 = default
}
ImDrawChannel :: struct #copy {
    _CmdBuffer : __UNKNOWN_16 = default
    _IdxBuffer : __UNKNOWN_16 = default
}
ImDrawListSplitter :: struct #copy {
    _Current : i32 = default
    _Count : i32 = default
    _Channels : __UNKNOWN_16 = default
}
impl ImDrawListSplitter {
    new :: () -> ImDrawListSplitter {
        result : ImDrawListSplitter = default
        __c__ImDrawListSplitter_new_3(^mut result)
        return result
    }
    Clear :: (&mut Self) {
        __c__ImDrawListSplitter_Clear_5(^mut *self)
    }
    ClearFreeMemory :: (&mut Self) {
        __c__ImDrawListSplitter_ClearFreeMemory_6(^mut *self)
    }
    Split :: (&mut Self, _draw_list: ^mut ImDrawList, _count: i32) {
        __c__ImDrawListSplitter_Split_7(^mut *self, _draw_list, _count)
    }
    Merge :: (&mut Self, _draw_list: ^mut ImDrawList) {
        __c__ImDrawListSplitter_Merge_8(^mut *self, _draw_list)
    }
    SetCurrentChannel :: (&mut Self, _draw_list: ^mut ImDrawList, _channel_idx: i32) {
        __c__ImDrawListSplitter_SetCurrentChannel_9(^mut *self, _draw_list, _channel_idx)
    }
}
impl Drop for ImDrawListSplitter {
    drop :: (&mut Self) {
        __c__ImDrawListSplitter_dtor(^*self)
    }
}
ImDrawList :: struct #copy {
    CmdBuffer : __UNKNOWN_16 = default
    IdxBuffer : __UNKNOWN_16 = default
    VtxBuffer : __UNKNOWN_16 = default
    Flags : ImDrawListFlags = default
    _Data : ^mut ImDrawListSharedData = default
    _OwnerName : ^char8 = default
    _VtxCurrentIdx : u32 = default
    _VtxWritePtr : ^mut ImDrawVert = default
    _IdxWritePtr : ^mut ImDrawIdx = default
    _ClipRectStack : __UNKNOWN_16 = default
    _TextureIdStack : __UNKNOWN_16 = default
    _Path : __UNKNOWN_16 = default
    _CmdHeader : ImDrawCmd = default
    _Splitter : ImDrawListSplitter = default
}
impl ImDrawList {
    new :: (_shared_data: ^mut ImDrawListSharedData) -> ImDrawList {
        result : ImDrawList = default
        __c__ImDrawList_new_14(^mut result, _shared_data)
        return result
    }
    PushClipRect :: (&mut Self, _clip_rect_min: ImVec2, _clip_rect_max: ImVec2, _intersect_with_current_clip_rect: bool) {
        __c__ImDrawList_PushClipRect_16(^mut *self, ^mut _clip_rect_min, ^mut _clip_rect_max, _intersect_with_current_clip_rect)
    }
    PushClipRectFullScreen :: (&mut Self) {
        __c__ImDrawList_PushClipRectFullScreen_17(^mut *self)
    }
    PopClipRect :: (&mut Self) {
        __c__ImDrawList_PopClipRect_18(^mut *self)
    }
    PushTextureID :: (&mut Self, _texture_id: ImTextureID) {
        __c__ImDrawList_PushTextureID_19(^mut *self, _texture_id)
    }
    PopTextureID :: (&mut Self) {
        __c__ImDrawList_PopTextureID_20(^mut *self)
    }
    GetClipRectMin :: (&mut Self) -> ImVec2 {
        mut result : ImVec2 = default
        __c__ImDrawList_GetClipRectMin_21(^mut *self, ^mut result)
        return result
    }
    GetClipRectMax :: (&mut Self) -> ImVec2 {
        mut result : ImVec2 = default
        __c__ImDrawList_GetClipRectMax_22(^mut *self, ^mut result)
        return result
    }
    AddLine :: (&mut Self, _p1: &mut ImVec2, _p2: &mut ImVec2, _col: ImU32, _thickness: f32) {
        __c__ImDrawList_AddLine_23(^mut *self, ^mut *_p1, ^mut *_p2, _col, _thickness)
    }
    AddRect :: (&mut Self, _p_min: &mut ImVec2, _p_max: &mut ImVec2, _col: ImU32, _rounding: f32, _rounding_corners: ImDrawCornerFlags, _thickness: f32) {
        __c__ImDrawList_AddRect_24(^mut *self, ^mut *_p_min, ^mut *_p_max, _col, _rounding, _rounding_corners, _thickness)
    }
    AddRectFilled :: (&mut Self, _p_min: &mut ImVec2, _p_max: &mut ImVec2, _col: ImU32, _rounding: f32, _rounding_corners: ImDrawCornerFlags) {
        __c__ImDrawList_AddRectFilled_25(^mut *self, ^mut *_p_min, ^mut *_p_max, _col, _rounding, _rounding_corners)
    }
    AddRectFilledMultiColor :: (&mut Self, _p_min: &mut ImVec2, _p_max: &mut ImVec2, _col_upr_left: ImU32, _col_upr_right: ImU32, _col_bot_right: ImU32, _col_bot_left: ImU32) {
        __c__ImDrawList_AddRectFilledMultiColor_26(^mut *self, ^mut *_p_min, ^mut *_p_max, _col_upr_left, _col_upr_right, _col_bot_right, _col_bot_left)
    }
    AddQuad :: (&mut Self, _p1: &mut ImVec2, _p2: &mut ImVec2, _p3: &mut ImVec2, _p4: &mut ImVec2, _col: ImU32, _thickness: f32) {
        __c__ImDrawList_AddQuad_27(^mut *self, ^mut *_p1, ^mut *_p2, ^mut *_p3, ^mut *_p4, _col, _thickness)
    }
    AddQuadFilled :: (&mut Self, _p1: &mut ImVec2, _p2: &mut ImVec2, _p3: &mut ImVec2, _p4: &mut ImVec2, _col: ImU32) {
        __c__ImDrawList_AddQuadFilled_28(^mut *self, ^mut *_p1, ^mut *_p2, ^mut *_p3, ^mut *_p4, _col)
    }
    AddTriangle :: (&mut Self, _p1: &mut ImVec2, _p2: &mut ImVec2, _p3: &mut ImVec2, _col: ImU32, _thickness: f32) {
        __c__ImDrawList_AddTriangle_29(^mut *self, ^mut *_p1, ^mut *_p2, ^mut *_p3, _col, _thickness)
    }
    AddTriangleFilled :: (&mut Self, _p1: &mut ImVec2, _p2: &mut ImVec2, _p3: &mut ImVec2, _col: ImU32) {
        __c__ImDrawList_AddTriangleFilled_30(^mut *self, ^mut *_p1, ^mut *_p2, ^mut *_p3, _col)
    }
    AddCircle :: (&mut Self, _center: &mut ImVec2, _radius: f32, _col: ImU32, _num_segments: i32, _thickness: f32) {
        __c__ImDrawList_AddCircle_31(^mut *self, ^mut *_center, _radius, _col, _num_segments, _thickness)
    }
    AddCircleFilled :: (&mut Self, _center: &mut ImVec2, _radius: f32, _col: ImU32, _num_segments: i32) {
        __c__ImDrawList_AddCircleFilled_32(^mut *self, ^mut *_center, _radius, _col, _num_segments)
    }
    AddNgon :: (&mut Self, _center: &mut ImVec2, _radius: f32, _col: ImU32, _num_segments: i32, _thickness: f32) {
        __c__ImDrawList_AddNgon_33(^mut *self, ^mut *_center, _radius, _col, _num_segments, _thickness)
    }
    AddNgonFilled :: (&mut Self, _center: &mut ImVec2, _radius: f32, _col: ImU32, _num_segments: i32) {
        __c__ImDrawList_AddNgonFilled_34(^mut *self, ^mut *_center, _radius, _col, _num_segments)
    }
    AddText :: (&mut Self, _pos: &mut ImVec2, _col: ImU32, _text_begin: ^char8, _text_end: ^char8) {
        __c__ImDrawList_AddText_35(^mut *self, ^mut *_pos, _col, _text_begin, _text_end)
    }
    AddText :: (&mut Self, _font: ^mut ImFont, _font_size: f32, _pos: &mut ImVec2, _col: ImU32, _text_begin: ^char8, _text_end: ^char8, _wrap_width: f32, _cpu_fine_clip_rect: ^mut ImVec4) {
        __c__ImDrawList_AddText_36(^mut *self, _font, _font_size, ^mut *_pos, _col, _text_begin, _text_end, _wrap_width, _cpu_fine_clip_rect)
    }
    AddPolyline :: (&mut Self, _points: ^mut ImVec2, _num_points: i32, _col: ImU32, _closed: bool, _thickness: f32) {
        __c__ImDrawList_AddPolyline_37(^mut *self, _points, _num_points, _col, _closed, _thickness)
    }
    AddConvexPolyFilled :: (&mut Self, _points: ^mut ImVec2, _num_points: i32, _col: ImU32) {
        __c__ImDrawList_AddConvexPolyFilled_38(^mut *self, _points, _num_points, _col)
    }
    AddBezierCurve :: (&mut Self, _p1: &mut ImVec2, _p2: &mut ImVec2, _p3: &mut ImVec2, _p4: &mut ImVec2, _col: ImU32, _thickness: f32, _num_segments: i32) {
        __c__ImDrawList_AddBezierCurve_39(^mut *self, ^mut *_p1, ^mut *_p2, ^mut *_p3, ^mut *_p4, _col, _thickness, _num_segments)
    }
    AddImage :: (&mut Self, _user_texture_id: ImTextureID, _p_min: &mut ImVec2, _p_max: &mut ImVec2, _uv_min: &mut ImVec2, _uv_max: &mut ImVec2, _col: ImU32) {
        __c__ImDrawList_AddImage_40(^mut *self, _user_texture_id, ^mut *_p_min, ^mut *_p_max, ^mut *_uv_min, ^mut *_uv_max, _col)
    }
    AddImageQuad :: (&mut Self, _user_texture_id: ImTextureID, _p1: &mut ImVec2, _p2: &mut ImVec2, _p3: &mut ImVec2, _p4: &mut ImVec2, _uv1: &mut ImVec2, _uv2: &mut ImVec2, _uv3: &mut ImVec2, _uv4: &mut ImVec2, _col: ImU32) {
        __c__ImDrawList_AddImageQuad_41(^mut *self, _user_texture_id, ^mut *_p1, ^mut *_p2, ^mut *_p3, ^mut *_p4, ^mut *_uv1, ^mut *_uv2, ^mut *_uv3, ^mut *_uv4, _col)
    }
    AddImageRounded :: (&mut Self, _user_texture_id: ImTextureID, _p_min: &mut ImVec2, _p_max: &mut ImVec2, _uv_min: &mut ImVec2, _uv_max: &mut ImVec2, _col: ImU32, _rounding: f32, _rounding_corners: ImDrawCornerFlags) {
        __c__ImDrawList_AddImageRounded_42(^mut *self, _user_texture_id, ^mut *_p_min, ^mut *_p_max, ^mut *_uv_min, ^mut *_uv_max, _col, _rounding, _rounding_corners)
    }
    PathClear :: (&mut Self) {
        __c__ImDrawList_PathClear_43(^mut *self)
    }
    PathLineTo :: (&mut Self, _pos: &mut ImVec2) {
        __c__ImDrawList_PathLineTo_44(^mut *self, ^mut *_pos)
    }
    PathLineToMergeDuplicate :: (&mut Self, _pos: &mut ImVec2) {
        __c__ImDrawList_PathLineToMergeDuplicate_45(^mut *self, ^mut *_pos)
    }
    PathFillConvex :: (&mut Self, _col: ImU32) {
        __c__ImDrawList_PathFillConvex_46(^mut *self, _col)
    }
    PathStroke :: (&mut Self, _col: ImU32, _closed: bool, _thickness: f32) {
        __c__ImDrawList_PathStroke_47(^mut *self, _col, _closed, _thickness)
    }
    PathArcTo :: (&mut Self, _center: &mut ImVec2, _radius: f32, _a_min: f32, _a_max: f32, _num_segments: i32) {
        __c__ImDrawList_PathArcTo_48(^mut *self, ^mut *_center, _radius, _a_min, _a_max, _num_segments)
    }
    PathArcToFast :: (&mut Self, _center: &mut ImVec2, _radius: f32, _a_min_of_12: i32, _a_max_of_12: i32) {
        __c__ImDrawList_PathArcToFast_49(^mut *self, ^mut *_center, _radius, _a_min_of_12, _a_max_of_12)
    }
    PathBezierCurveTo :: (&mut Self, _p2: &mut ImVec2, _p3: &mut ImVec2, _p4: &mut ImVec2, _num_segments: i32) {
        __c__ImDrawList_PathBezierCurveTo_50(^mut *self, ^mut *_p2, ^mut *_p3, ^mut *_p4, _num_segments)
    }
    PathRect :: (&mut Self, _rect_min: &mut ImVec2, _rect_max: &mut ImVec2, _rounding: f32, _rounding_corners: ImDrawCornerFlags) {
        __c__ImDrawList_PathRect_51(^mut *self, ^mut *_rect_min, ^mut *_rect_max, _rounding, _rounding_corners)
    }
    AddCallback :: (&mut Self, _callback: ImDrawCallback, _callback_data: ^mut void) {
        __c__ImDrawList_AddCallback_52(^mut *self, _callback, _callback_data)
    }
    AddDrawCmd :: (&mut Self) {
        __c__ImDrawList_AddDrawCmd_53(^mut *self)
    }
    CloneOutput :: (&mut Self) -> ^mut ImDrawList {
        mut result : ^mut ImDrawList = default
        __c__ImDrawList_CloneOutput_54(^mut *self, ^mut result)
        return result
    }
    ChannelsSplit :: (&mut Self, _count: i32) {
        __c__ImDrawList_ChannelsSplit_55(^mut *self, _count)
    }
    ChannelsMerge :: (&mut Self) {
        __c__ImDrawList_ChannelsMerge_56(^mut *self)
    }
    ChannelsSetCurrent :: (&mut Self, _n: i32) {
        __c__ImDrawList_ChannelsSetCurrent_57(^mut *self, _n)
    }
    PrimReserve :: (&mut Self, _idx_count: i32, _vtx_count: i32) {
        __c__ImDrawList_PrimReserve_58(^mut *self, _idx_count, _vtx_count)
    }
    PrimUnreserve :: (&mut Self, _idx_count: i32, _vtx_count: i32) {
        __c__ImDrawList_PrimUnreserve_59(^mut *self, _idx_count, _vtx_count)
    }
    PrimRect :: (&mut Self, _a: &mut ImVec2, _b: &mut ImVec2, _col: ImU32) {
        __c__ImDrawList_PrimRect_60(^mut *self, ^mut *_a, ^mut *_b, _col)
    }
    PrimRectUV :: (&mut Self, _a: &mut ImVec2, _b: &mut ImVec2, _uv_a: &mut ImVec2, _uv_b: &mut ImVec2, _col: ImU32) {
        __c__ImDrawList_PrimRectUV_61(^mut *self, ^mut *_a, ^mut *_b, ^mut *_uv_a, ^mut *_uv_b, _col)
    }
    PrimQuadUV :: (&mut Self, _a: &mut ImVec2, _b: &mut ImVec2, _c: &mut ImVec2, _d: &mut ImVec2, _uv_a: &mut ImVec2, _uv_b: &mut ImVec2, _uv_c: &mut ImVec2, _uv_d: &mut ImVec2, _col: ImU32) {
        __c__ImDrawList_PrimQuadUV_62(^mut *self, ^mut *_a, ^mut *_b, ^mut *_c, ^mut *_d, ^mut *_uv_a, ^mut *_uv_b, ^mut *_uv_c, ^mut *_uv_d, _col)
    }
    PrimWriteVtx :: (&mut Self, _pos: &mut ImVec2, _uv: &mut ImVec2, _col: ImU32) {
        __c__ImDrawList_PrimWriteVtx_63(^mut *self, ^mut *_pos, ^mut *_uv, _col)
    }
    PrimWriteIdx :: (&mut Self, _idx: ImDrawIdx) {
        __c__ImDrawList_PrimWriteIdx_64(^mut *self, _idx)
    }
    PrimVtx :: (&mut Self, _pos: &mut ImVec2, _uv: &mut ImVec2, _col: ImU32) {
        __c__ImDrawList_PrimVtx_65(^mut *self, ^mut *_pos, ^mut *_uv, _col)
    }
    _ResetForNewFrame :: (&mut Self) {
        __c__ImDrawList__ResetForNewFrame_66(^mut *self)
    }
    _ClearFreeMemory :: (&mut Self) {
        __c__ImDrawList__ClearFreeMemory_67(^mut *self)
    }
    _PopUnusedDrawCmd :: (&mut Self) {
        __c__ImDrawList__PopUnusedDrawCmd_68(^mut *self)
    }
    _OnChangedClipRect :: (&mut Self) {
        __c__ImDrawList__OnChangedClipRect_69(^mut *self)
    }
    _OnChangedTextureID :: (&mut Self) {
        __c__ImDrawList__OnChangedTextureID_70(^mut *self)
    }
    _OnChangedVtxOffset :: (&mut Self) {
        __c__ImDrawList__OnChangedVtxOffset_71(^mut *self)
    }
}
impl Drop for ImDrawList {
    drop :: (&mut Self) {
        __c__ImDrawList_dtor(^*self)
    }
}
ImDrawData :: struct #copy {
    Valid : bool = default
    CmdLists : ^mut ^mut ImDrawList = default
    CmdListsCount : i32 = default
    TotalIdxCount : i32 = default
    TotalVtxCount : i32 = default
    DisplayPos : ImVec2 = default
    DisplaySize : ImVec2 = default
    FramebufferScale : ImVec2 = default
    OwnerViewport : ^mut ImGuiViewport = default
}
impl ImDrawData {
    new :: () -> ImDrawData {
        result : ImDrawData = default
        __c__ImDrawData_new_9(^mut result)
        return result
    }
    Clear :: (&mut Self) {
        __c__ImDrawData_Clear_11(^mut *self)
    }
    DeIndexAllBuffers :: (&mut Self) {
        __c__ImDrawData_DeIndexAllBuffers_12(^mut *self)
    }
    ScaleClipRects :: (&mut Self, _fb_scale: &mut ImVec2) {
        __c__ImDrawData_ScaleClipRects_13(^mut *self, ^mut *_fb_scale)
    }
}
impl Drop for ImDrawData {
    drop :: (&mut Self) {
        __c__ImDrawData_dtor(^*self)
    }
}
ImFontConfig :: struct #copy {
    FontData : ^mut void = default
    FontDataSize : i32 = default
    FontDataOwnedByAtlas : bool = default
    FontNo : i32 = default
    SizePixels : f32 = default
    OversampleH : i32 = default
    OversampleV : i32 = default
    PixelSnapH : bool = default
    GlyphExtraSpacing : ImVec2 = default
    GlyphOffset : ImVec2 = default
    GlyphRanges : ^mut ImWchar = default
    GlyphMinAdvanceX : f32 = default
    GlyphMaxAdvanceX : f32 = default
    MergeMode : bool = default
    RasterizerFlags : u32 = default
    RasterizerMultiply : f32 = default
    EllipsisChar : ImWchar = default
    Name : [40]char8 = default
    DstFont : ^mut ImFont = default
}
impl ImFontConfig {
    new :: () -> ImFontConfig {
        result : ImFontConfig = default
        __c__ImFontConfig_new_19(^mut result)
        return result
    }
}
ImFontGlyph :: struct #copy {
    Codepoint : u32 = default
    Visible : u32 = default
    AdvanceX : f32 = default
    X0 : f32 = default
    Y0 : f32 = default
    X1 : f32 = default
    Y1 : f32 = default
    U0 : f32 = default
    V0 : f32 = default
    U1 : f32 = default
    V1 : f32 = default
}
ImFontGlyphRangesBuilder :: struct #copy {
    UsedChars : __UNKNOWN_16 = default
}
impl ImFontGlyphRangesBuilder {
    new :: () -> ImFontGlyphRangesBuilder {
        result : ImFontGlyphRangesBuilder = default
        __c__ImFontGlyphRangesBuilder_new_1(^mut result)
        return result
    }
    Clear :: (&mut Self) {
        __c__ImFontGlyphRangesBuilder_Clear_2(^mut *self)
    }
    GetBit :: (&mut Self, _n: size_t) -> bool {
        mut result : bool = default
        __c__ImFontGlyphRangesBuilder_GetBit_3(^mut *self, ^mut result, _n)
        return result
    }
    SetBit :: (&mut Self, _n: size_t) {
        __c__ImFontGlyphRangesBuilder_SetBit_4(^mut *self, _n)
    }
    AddChar :: (&mut Self, _c: ImWchar) {
        __c__ImFontGlyphRangesBuilder_AddChar_5(^mut *self, _c)
    }
    AddText :: (&mut Self, _text: ^char8, _text_end: ^char8) {
        __c__ImFontGlyphRangesBuilder_AddText_6(^mut *self, _text, _text_end)
    }
    AddRanges :: (&mut Self, _ranges: ^mut ImWchar) {
        __c__ImFontGlyphRangesBuilder_AddRanges_7(^mut *self, _ranges)
    }
    BuildRanges :: (&mut Self, _out_ranges: ^mut __UNKNOWN_16) {
        __c__ImFontGlyphRangesBuilder_BuildRanges_8(^mut *self, _out_ranges)
    }
}
ImFontAtlasCustomRect :: struct #copy {
    Width : u16 = default
    Height : u16 = default
    X : u16 = default
    Y : u16 = default
    GlyphID : u32 = default
    GlyphAdvanceX : f32 = default
    GlyphOffset : ImVec2 = default
    Font : ^mut ImFont = default
}
impl ImFontAtlasCustomRect {
    new :: () -> ImFontAtlasCustomRect {
        result : ImFontAtlasCustomRect = default
        __c__ImFontAtlasCustomRect_new_8(^mut result)
        return result
    }
    IsPacked :: (&mut Self) -> bool {
        mut result : bool = default
        __c__ImFontAtlasCustomRect_IsPacked_9(^mut *self, ^mut result)
        return result
    }
}
ImFontAtlas :: struct #copy {
    Locked : bool = default
    Flags : ImFontAtlasFlags = default
    TexID : ImTextureID = default
    TexDesiredWidth : i32 = default
    TexGlyphPadding : i32 = default
    TexPixelsAlpha8 : ^mut u8 = default
    TexPixelsRGBA32 : ^mut u32 = default
    TexWidth : i32 = default
    TexHeight : i32 = default
    TexUvScale : ImVec2 = default
    TexUvWhitePixel : ImVec2 = default
    Fonts : __UNKNOWN_16 = default
    CustomRects : __UNKNOWN_16 = default
    ConfigData : __UNKNOWN_16 = default
    TexUvLines : [64]ImVec4 = default
    PackIdMouseCursors : i32 = default
    PackIdLines : i32 = default
}
impl ImFontAtlas {
    new :: () -> ImFontAtlas {
        result : ImFontAtlas = default
        __c__ImFontAtlas_new_0(^mut result)
        return result
    }
    AddFont :: (&mut Self, _font_cfg: ^mut ImFontConfig) -> ^mut ImFont {
        mut result : ^mut ImFont = default
        __c__ImFontAtlas_AddFont_2(^mut *self, ^mut result, _font_cfg)
        return result
    }
    AddFontDefault :: (&mut Self, _font_cfg: ^mut ImFontConfig) -> ^mut ImFont {
        mut result : ^mut ImFont = default
        __c__ImFontAtlas_AddFontDefault_3(^mut *self, ^mut result, _font_cfg)
        return result
    }
    AddFontFromFileTTF :: (&mut Self, _filename: ^char8, _size_pixels: f32, _font_cfg: ^mut ImFontConfig, _glyph_ranges: ^mut ImWchar) -> ^mut ImFont {
        mut result : ^mut ImFont = default
        __c__ImFontAtlas_AddFontFromFileTTF_4(^mut *self, ^mut result, _filename, _size_pixels, _font_cfg, _glyph_ranges)
        return result
    }
    AddFontFromMemoryTTF :: (&mut Self, _font_data: ^mut void, _font_size: i32, _size_pixels: f32, _font_cfg: ^mut ImFontConfig, _glyph_ranges: ^mut ImWchar) -> ^mut ImFont {
        mut result : ^mut ImFont = default
        __c__ImFontAtlas_AddFontFromMemoryTTF_5(^mut *self, ^mut result, _font_data, _font_size, _size_pixels, _font_cfg, _glyph_ranges)
        return result
    }
    AddFontFromMemoryCompressedTTF :: (&mut Self, _compressed_font_data: ^mut void, _compressed_font_size: i32, _size_pixels: f32, _font_cfg: ^mut ImFontConfig, _glyph_ranges: ^mut ImWchar) -> ^mut ImFont {
        mut result : ^mut ImFont = default
        __c__ImFontAtlas_AddFontFromMemoryCompressedTTF_6(^mut *self, ^mut result, _compressed_font_data, _compressed_font_size, _size_pixels, _font_cfg, _glyph_ranges)
        return result
    }
    AddFontFromMemoryCompressedBase85TTF :: (&mut Self, _compressed_font_data_base85: ^char8, _size_pixels: f32, _font_cfg: ^mut ImFontConfig, _glyph_ranges: ^mut ImWchar) -> ^mut ImFont {
        mut result : ^mut ImFont = default
        __c__ImFontAtlas_AddFontFromMemoryCompressedBase85TTF_7(^mut *self, ^mut result, _compressed_font_data_base85, _size_pixels, _font_cfg, _glyph_ranges)
        return result
    }
    ClearInputData :: (&mut Self) {
        __c__ImFontAtlas_ClearInputData_8(^mut *self)
    }
    ClearTexData :: (&mut Self) {
        __c__ImFontAtlas_ClearTexData_9(^mut *self)
    }
    ClearFonts :: (&mut Self) {
        __c__ImFontAtlas_ClearFonts_10(^mut *self)
    }
    Clear :: (&mut Self) {
        __c__ImFontAtlas_Clear_11(^mut *self)
    }
    Build :: (&mut Self) -> bool {
        mut result : bool = default
        __c__ImFontAtlas_Build_12(^mut *self, ^mut result)
        return result
    }
    GetTexDataAsAlpha8 :: (&mut Self, _out_pixels: ^mut ^mut u8, _out_width: ^mut i32, _out_height: ^mut i32, _out_bytes_per_pixel: ^mut i32) {
        __c__ImFontAtlas_GetTexDataAsAlpha8_13(^mut *self, _out_pixels, _out_width, _out_height, _out_bytes_per_pixel)
    }
    GetTexDataAsRGBA32 :: (&mut Self, _out_pixels: ^mut ^mut u8, _out_width: ^mut i32, _out_height: ^mut i32, _out_bytes_per_pixel: ^mut i32) {
        __c__ImFontAtlas_GetTexDataAsRGBA32_14(^mut *self, _out_pixels, _out_width, _out_height, _out_bytes_per_pixel)
    }
    IsBuilt :: (&mut Self) -> bool {
        mut result : bool = default
        __c__ImFontAtlas_IsBuilt_15(^mut *self, ^mut result)
        return result
    }
    SetTexID :: (&mut Self, _id: ImTextureID) {
        __c__ImFontAtlas_SetTexID_16(^mut *self, _id)
    }
    GetGlyphRangesDefault :: (&mut Self) -> ^mut ImWchar {
        mut result : ^mut ImWchar = default
        __c__ImFontAtlas_GetGlyphRangesDefault_17(^mut *self, ^mut result)
        return result
    }
    GetGlyphRangesKorean :: (&mut Self) -> ^mut ImWchar {
        mut result : ^mut ImWchar = default
        __c__ImFontAtlas_GetGlyphRangesKorean_18(^mut *self, ^mut result)
        return result
    }
    GetGlyphRangesJapanese :: (&mut Self) -> ^mut ImWchar {
        mut result : ^mut ImWchar = default
        __c__ImFontAtlas_GetGlyphRangesJapanese_19(^mut *self, ^mut result)
        return result
    }
    GetGlyphRangesChineseFull :: (&mut Self) -> ^mut ImWchar {
        mut result : ^mut ImWchar = default
        __c__ImFontAtlas_GetGlyphRangesChineseFull_20(^mut *self, ^mut result)
        return result
    }
    GetGlyphRangesChineseSimplifiedCommon :: (&mut Self) -> ^mut ImWchar {
        mut result : ^mut ImWchar = default
        __c__ImFontAtlas_GetGlyphRangesChineseSimplifiedCommon_21(^mut *self, ^mut result)
        return result
    }
    GetGlyphRangesCyrillic :: (&mut Self) -> ^mut ImWchar {
        mut result : ^mut ImWchar = default
        __c__ImFontAtlas_GetGlyphRangesCyrillic_22(^mut *self, ^mut result)
        return result
    }
    GetGlyphRangesThai :: (&mut Self) -> ^mut ImWchar {
        mut result : ^mut ImWchar = default
        __c__ImFontAtlas_GetGlyphRangesThai_23(^mut *self, ^mut result)
        return result
    }
    GetGlyphRangesVietnamese :: (&mut Self) -> ^mut ImWchar {
        mut result : ^mut ImWchar = default
        __c__ImFontAtlas_GetGlyphRangesVietnamese_24(^mut *self, ^mut result)
        return result
    }
    AddCustomRectRegular :: (&mut Self, _width: i32, _height: i32) -> i32 {
        mut result : i32 = default
        __c__ImFontAtlas_AddCustomRectRegular_25(^mut *self, ^mut result, _width, _height)
        return result
    }
    AddCustomRectFontGlyph :: (&mut Self, _font: ^mut ImFont, _id: ImWchar, _width: i32, _height: i32, _advance_x: f32, _offset: &mut ImVec2) -> i32 {
        mut result : i32 = default
        __c__ImFontAtlas_AddCustomRectFontGlyph_26(^mut *self, ^mut result, _font, _id, _width, _height, _advance_x, ^mut *_offset)
        return result
    }
    GetCustomRectByIndex :: (&mut Self, _index: i32) -> ^mut ImFontAtlasCustomRect {
        mut result : ^mut ImFontAtlasCustomRect = default
        __c__ImFontAtlas_GetCustomRectByIndex_27(^mut *self, ^mut result, _index)
        return result
    }
    CalcCustomRectUV :: (&mut Self, _rect: ^mut ImFontAtlasCustomRect, _out_uv_min: ^mut ImVec2, _out_uv_max: ^mut ImVec2) {
        __c__ImFontAtlas_CalcCustomRectUV_28(^mut *self, _rect, _out_uv_min, _out_uv_max)
    }
    GetMouseCursorTexData :: (&mut Self, _cursor: ImGuiMouseCursor, _out_offset: ^mut ImVec2, _out_size: ^mut ImVec2, _out_uv_border: ^mut ImVec2, _out_uv_fill: ^mut ImVec2) -> bool {
        mut result : bool = default
        __c__ImFontAtlas_GetMouseCursorTexData_29(^mut *self, ^mut result, _cursor, _out_offset, _out_size, _out_uv_border, _out_uv_fill)
        return result
    }
}
impl Drop for ImFontAtlas {
    drop :: (&mut Self) {
        __c__ImFontAtlas_dtor(^*self)
    }
}
ImFont :: struct #copy {
    IndexAdvanceX : __UNKNOWN_16 = default
    FallbackAdvanceX : f32 = default
    FontSize : f32 = default
    IndexLookup : __UNKNOWN_16 = default
    Glyphs : __UNKNOWN_16 = default
    FallbackGlyph : ^mut ImFontGlyph = default
    DisplayOffset : ImVec2 = default
    ContainerAtlas : ^mut ImFontAtlas = default
    ConfigData : ^mut ImFontConfig = default
    ConfigDataCount : i16 = default
    FallbackChar : ImWchar = default
    EllipsisChar : ImWchar = default
    DirtyLookupTables : bool = default
    Scale : f32 = default
    Ascent : f32 = default
    Descent : f32 = default
    MetricsTotalSurface : i32 = default
    Used4kPagesMap : [2]ImU8 = default
}
impl ImFont {
    new :: () -> ImFont {
        result : ImFont = default
        __c__ImFont_new_18(^mut result)
        return result
    }
    FindGlyph :: (&mut Self, _c: ImWchar) -> ^mut ImFontGlyph {
        mut result : ^mut ImFontGlyph = default
        __c__ImFont_FindGlyph_20(^mut *self, ^mut result, _c)
        return result
    }
    FindGlyphNoFallback :: (&mut Self, _c: ImWchar) -> ^mut ImFontGlyph {
        mut result : ^mut ImFontGlyph = default
        __c__ImFont_FindGlyphNoFallback_21(^mut *self, ^mut result, _c)
        return result
    }
    GetCharAdvance :: (&mut Self, _c: ImWchar) -> f32 {
        mut result : f32 = default
        __c__ImFont_GetCharAdvance_22(^mut *self, ^mut result, _c)
        return result
    }
    IsLoaded :: (&mut Self) -> bool {
        mut result : bool = default
        __c__ImFont_IsLoaded_23(^mut *self, ^mut result)
        return result
    }
    GetDebugName :: (&mut Self) -> ^char8 {
        mut result : ^char8 = default
        __c__ImFont_GetDebugName_24(^mut *self, ^mut result)
        return result
    }
    CalcTextSizeA :: (&mut Self, _size: f32, _max_width: f32, _wrap_width: f32, _text_begin: ^char8, _text_end: ^char8, _remaining: ^mut ^char8) -> ImVec2 {
        mut result : ImVec2 = default
        __c__ImFont_CalcTextSizeA_25(^mut *self, ^mut result, _size, _max_width, _wrap_width, _text_begin, _text_end, _remaining)
        return result
    }
    CalcWordWrapPositionA :: (&mut Self, _scale: f32, _text: ^char8, _text_end: ^char8, _wrap_width: f32) -> ^char8 {
        mut result : ^char8 = default
        __c__ImFont_CalcWordWrapPositionA_26(^mut *self, ^mut result, _scale, _text, _text_end, _wrap_width)
        return result
    }
    RenderChar :: (&mut Self, _draw_list: ^mut ImDrawList, _size: f32, _pos: ImVec2, _col: ImU32, _c: ImWchar) {
        __c__ImFont_RenderChar_27(^mut *self, _draw_list, _size, ^mut _pos, _col, _c)
    }
    RenderText :: (&mut Self, _draw_list: ^mut ImDrawList, _size: f32, _pos: ImVec2, _col: ImU32, _clip_rect: &mut ImVec4, _text_begin: ^char8, _text_end: ^char8, _wrap_width: f32, _cpu_fine_clip: bool) {
        __c__ImFont_RenderText_28(^mut *self, _draw_list, _size, ^mut _pos, _col, ^mut *_clip_rect, _text_begin, _text_end, _wrap_width, _cpu_fine_clip)
    }
    BuildLookupTable :: (&mut Self) {
        __c__ImFont_BuildLookupTable_29(^mut *self)
    }
    ClearOutputData :: (&mut Self) {
        __c__ImFont_ClearOutputData_30(^mut *self)
    }
    GrowIndex :: (&mut Self, _new_size: i32) {
        __c__ImFont_GrowIndex_31(^mut *self, _new_size)
    }
    AddGlyph :: (&mut Self, _src_cfg: ^mut ImFontConfig, _c: ImWchar, _x0: f32, _y0: f32, _x1: f32, _y1: f32, _u0: f32, _v0: f32, _u1: f32, _v1: f32, _advance_x: f32) {
        __c__ImFont_AddGlyph_32(^mut *self, _src_cfg, _c, _x0, _y0, _x1, _y1, _u0, _v0, _u1, _v1, _advance_x)
    }
    AddRemapChar :: (&mut Self, _dst: ImWchar, _src: ImWchar, _overwrite_dst: bool) {
        __c__ImFont_AddRemapChar_33(^mut *self, _dst, _src, _overwrite_dst)
    }
    SetGlyphVisible :: (&mut Self, _c: ImWchar, _visible: bool) {
        __c__ImFont_SetGlyphVisible_34(^mut *self, _c, _visible)
    }
    SetFallbackChar :: (&mut Self, _c: ImWchar) {
        __c__ImFont_SetFallbackChar_35(^mut *self, _c)
    }
    IsGlyphRangeUnused :: (&mut Self, _c_begin: u32, _c_last: u32) -> bool {
        mut result : bool = default
        __c__ImFont_IsGlyphRangeUnused_36(^mut *self, ^mut result, _c_begin, _c_last)
        return result
    }
}
impl Drop for ImFont {
    drop :: (&mut Self) {
        __c__ImFont_dtor(^*self)
    }
}
ImGuiPlatformIO :: struct #copy {
    Platform_CreateWindow : fn(^mut ImGuiViewport) -> void = default
    Platform_DestroyWindow : fn(^mut ImGuiViewport) -> void = default
    Platform_ShowWindow : fn(^mut ImGuiViewport) -> void = default
    Platform_SetWindowPos : fn(^mut ImGuiViewport, ImVec2) -> void = default
    Platform_GetWindowPos : fn(^mut ImGuiViewport) -> ImVec2 = default
    Platform_SetWindowSize : fn(^mut ImGuiViewport, ImVec2) -> void = default
    Platform_GetWindowSize : fn(^mut ImGuiViewport) -> ImVec2 = default
    Platform_SetWindowFocus : fn(^mut ImGuiViewport) -> void = default
    Platform_GetWindowFocus : fn(^mut ImGuiViewport) -> bool = default
    Platform_GetWindowMinimized : fn(^mut ImGuiViewport) -> bool = default
    Platform_SetWindowTitle : fn(^mut ImGuiViewport, ^char8) -> void = default
    Platform_SetWindowAlpha : fn(^mut ImGuiViewport, f32) -> void = default
    Platform_UpdateWindow : fn(^mut ImGuiViewport) -> void = default
    Platform_RenderWindow : fn(^mut ImGuiViewport, ^mut void) -> void = default
    Platform_SwapBuffers : fn(^mut ImGuiViewport, ^mut void) -> void = default
    Platform_GetWindowDpiScale : fn(^mut ImGuiViewport) -> f32 = default
    Platform_OnChangedViewport : fn(^mut ImGuiViewport) -> void = default
    Platform_SetImeInputPos : fn(^mut ImGuiViewport, ImVec2) -> void = default
    Platform_CreateVkSurface : fn(^mut ImGuiViewport, ImU64, ^mut void, ^mut ImU64) -> i32 = default
    Renderer_CreateWindow : fn(^mut ImGuiViewport) -> void = default
    Renderer_DestroyWindow : fn(^mut ImGuiViewport) -> void = default
    Renderer_SetWindowSize : fn(^mut ImGuiViewport, ImVec2) -> void = default
    Renderer_RenderWindow : fn(^mut ImGuiViewport, ^mut void) -> void = default
    Renderer_SwapBuffers : fn(^mut ImGuiViewport, ^mut void) -> void = default
    Monitors : __UNKNOWN_16 = default
    MainViewport : ^mut ImGuiViewport = default
    Viewports : __UNKNOWN_16 = default
}
impl ImGuiPlatformIO {
    new :: () -> ImGuiPlatformIO {
        result : ImGuiPlatformIO = default
        __c__ImGuiPlatformIO_new_27(^mut result)
        return result
    }
}
ImGuiPlatformMonitor :: struct #copy {
    MainPos : ImVec2 = default
    MainSize : ImVec2 = default
    WorkPos : ImVec2 = default
    WorkSize : ImVec2 = default
    DpiScale : f32 = default
}
impl ImGuiPlatformMonitor {
    new :: () -> ImGuiPlatformMonitor {
        result : ImGuiPlatformMonitor = default
        __c__ImGuiPlatformMonitor_new_5(^mut result)
        return result
    }
}
ImGuiViewport :: struct #copy {
    ID : ImGuiID = default
    Flags : ImGuiViewportFlags = default
    Pos : ImVec2 = default
    Size : ImVec2 = default
    WorkOffsetMin : ImVec2 = default
    WorkOffsetMax : ImVec2 = default
    DpiScale : f32 = default
    DrawData : ^mut ImDrawData = default
    ParentViewportId : ImGuiID = default
    RendererUserData : ^mut void = default
    PlatformUserData : ^mut void = default
    PlatformHandle : ^mut void = default
    PlatformHandleRaw : ^mut void = default
    PlatformRequestMove : bool = default
    PlatformRequestResize : bool = default
    PlatformRequestClose : bool = default
}
impl ImGuiViewport {
    new :: () -> ImGuiViewport {
        result : ImGuiViewport = default
        __c__ImGuiViewport_new_16(^mut result)
        return result
    }
    GetCenter :: (&mut Self) -> ImVec2 {
        mut result : ImVec2 = default
        __c__ImGuiViewport_GetCenter_18(^mut *self, ^mut result)
        return result
    }
    GetWorkPos :: (&mut Self) -> ImVec2 {
        mut result : ImVec2 = default
        __c__ImGuiViewport_GetWorkPos_19(^mut *self, ^mut result)
        return result
    }
    GetWorkSize :: (&mut Self) -> ImVec2 {
        mut result : ImVec2 = default
        __c__ImGuiViewport_GetWorkSize_20(^mut *self, ^mut result)
        return result
    }
}
impl Drop for ImGuiViewport {
    drop :: (&mut Self) {
        __c__ImGuiViewport_dtor(^*self)
    }
}
StbUndoRecord :: struct #copy {
    where : i32 = default
    insert_length : i32 = default
    delete_length : i32 = default
    char_storage : i32 = default
}
StbUndoState :: struct #copy {
    undo_rec : [99]StbUndoRecord = default
    undo_char : [999]ImWchar = default
    undo_point : i16 = default
    redo_point : i16 = default
    undo_char_point : i32 = default
    redo_char_point : i32 = default
}
STB_TexteditState :: struct #copy {
    cursor : i32 = default
    select_start : i32 = default
    select_end : i32 = default
    insert_mode : u8 = default
    cursor_at_end_of_line : u8 = default
    initialized : u8 = default
    has_preferred_x : u8 = default
    single_line : u8 = default
    padding1 : u8 = default
    padding2 : u8 = default
    padding3 : u8 = default
    preferred_x : f32 = default
    undostate : StbUndoState = default
}
ImVec1 :: struct #copy {
    x : f32 = default
}
impl ImVec1 {
    new :: () -> ImVec1 {
        result : ImVec1 = default
        __c__ImVec1_new_1(^mut result)
        return result
    }
    new :: (__x: f32) -> ImVec1 {
        result : ImVec1 = default
        __c__ImVec1_new_2(^mut result, __x)
        return result
    }
}
ImVec2ih :: struct #copy {
    x : i16 = default
    y : i16 = default
}
impl ImVec2ih {
    new :: () -> ImVec2ih {
        result : ImVec2ih = default
        __c__ImVec2ih_new_2(^mut result)
        return result
    }
    new :: (__x: i16, __y: i16) -> ImVec2ih {
        result : ImVec2ih = default
        __c__ImVec2ih_new_3(^mut result, __x, __y)
        return result
    }
    new :: (_rhs: &mut ImVec2) -> ImVec2ih {
        result : ImVec2ih = default
        __c__ImVec2ih_new_4(^mut result, ^mut *_rhs)
        return result
    }
}
ImRect :: struct #copy {
    Min : ImVec2 = default
    Max : ImVec2 = default
}
impl ImRect {
    new :: () -> ImRect {
        result : ImRect = default
        __c__ImRect_new_2(^mut result)
        return result
    }
    new :: (_min: &mut ImVec2, _max: &mut ImVec2) -> ImRect {
        result : ImRect = default
        __c__ImRect_new_3(^mut result, ^mut *_min, ^mut *_max)
        return result
    }
    new :: (_v: &mut ImVec4) -> ImRect {
        result : ImRect = default
        __c__ImRect_new_4(^mut result, ^mut *_v)
        return result
    }
    new :: (_x1: f32, _y1: f32, _x2: f32, _y2: f32) -> ImRect {
        result : ImRect = default
        __c__ImRect_new_5(^mut result, _x1, _y1, _x2, _y2)
        return result
    }
    GetCenter :: (&mut Self) -> ImVec2 {
        mut result : ImVec2 = default
        __c__ImRect_GetCenter_6(^mut *self, ^mut result)
        return result
    }
    GetSize :: (&mut Self) -> ImVec2 {
        mut result : ImVec2 = default
        __c__ImRect_GetSize_7(^mut *self, ^mut result)
        return result
    }
    GetWidth :: (&mut Self) -> f32 {
        mut result : f32 = default
        __c__ImRect_GetWidth_8(^mut *self, ^mut result)
        return result
    }
    GetHeight :: (&mut Self) -> f32 {
        mut result : f32 = default
        __c__ImRect_GetHeight_9(^mut *self, ^mut result)
        return result
    }
    GetTL :: (&mut Self) -> ImVec2 {
        mut result : ImVec2 = default
        __c__ImRect_GetTL_10(^mut *self, ^mut result)
        return result
    }
    GetTR :: (&mut Self) -> ImVec2 {
        mut result : ImVec2 = default
        __c__ImRect_GetTR_11(^mut *self, ^mut result)
        return result
    }
    GetBL :: (&mut Self) -> ImVec2 {
        mut result : ImVec2 = default
        __c__ImRect_GetBL_12(^mut *self, ^mut result)
        return result
    }
    GetBR :: (&mut Self) -> ImVec2 {
        mut result : ImVec2 = default
        __c__ImRect_GetBR_13(^mut *self, ^mut result)
        return result
    }
    Contains :: (&mut Self, _p: &mut ImVec2) -> bool {
        mut result : bool = default
        __c__ImRect_Contains_14(^mut *self, ^mut result, ^mut *_p)
        return result
    }
    Contains :: (&mut Self, _r: &mut ImRect) -> bool {
        mut result : bool = default
        __c__ImRect_Contains_15(^mut *self, ^mut result, ^mut *_r)
        return result
    }
    Overlaps :: (&mut Self, _r: &mut ImRect) -> bool {
        mut result : bool = default
        __c__ImRect_Overlaps_16(^mut *self, ^mut result, ^mut *_r)
        return result
    }
    Add :: (&mut Self, _p: &mut ImVec2) {
        __c__ImRect_Add_17(^mut *self, ^mut *_p)
    }
    Add :: (&mut Self, _r: &mut ImRect) {
        __c__ImRect_Add_18(^mut *self, ^mut *_r)
    }
    Expand :: (&mut Self, _amount: f32) {
        __c__ImRect_Expand_19(^mut *self, _amount)
    }
    Expand :: (&mut Self, _amount: &mut ImVec2) {
        __c__ImRect_Expand_20(^mut *self, ^mut *_amount)
    }
    Translate :: (&mut Self, _d: &mut ImVec2) {
        __c__ImRect_Translate_21(^mut *self, ^mut *_d)
    }
    TranslateX :: (&mut Self, _dx: f32) {
        __c__ImRect_TranslateX_22(^mut *self, _dx)
    }
    TranslateY :: (&mut Self, _dy: f32) {
        __c__ImRect_TranslateY_23(^mut *self, _dy)
    }
    ClipWith :: (&mut Self, _r: &mut ImRect) {
        __c__ImRect_ClipWith_24(^mut *self, ^mut *_r)
    }
    ClipWithFull :: (&mut Self, _r: &mut ImRect) {
        __c__ImRect_ClipWithFull_25(^mut *self, ^mut *_r)
    }
    Floor :: (&mut Self) {
        __c__ImRect_Floor_26(^mut *self)
    }
    IsInverted :: (&mut Self) -> bool {
        mut result : bool = default
        __c__ImRect_IsInverted_27(^mut *self, ^mut result)
        return result
    }
    ToVec4 :: (&mut Self) -> ImVec4 {
        mut result : ImVec4 = default
        __c__ImRect_ToVec4_28(^mut *self, ^mut result)
        return result
    }
}
ImBitVector :: struct #copy {
    Storage : __UNKNOWN_16 = default
}
impl ImBitVector {
    Create :: (&mut Self, _sz: i32) {
        __c__ImBitVector_Create_1(^mut *self, _sz)
    }
    Clear :: (&mut Self) {
        __c__ImBitVector_Clear_2(^mut *self)
    }
    TestBit :: (&mut Self, _n: i32) -> bool {
        mut result : bool = default
        __c__ImBitVector_TestBit_3(^mut *self, ^mut result, _n)
        return result
    }
    SetBit :: (&mut Self, _n: i32) {
        __c__ImBitVector_SetBit_4(^mut *self, _n)
    }
    ClearBit :: (&mut Self, _n: i32) {
        __c__ImBitVector_ClearBit_5(^mut *self, _n)
    }
}
ImDrawListSharedData :: struct #copy {
    TexUvWhitePixel : ImVec2 = default
    Font : ^mut ImFont = default
    FontSize : f32 = default
    CurveTessellationTol : f32 = default
    CircleSegmentMaxError : f32 = default
    ClipRectFullscreen : ImVec4 = default
    InitialFlags : ImDrawListFlags = default
    ArcFastVtx : [12]ImVec2 = default
    CircleSegmentCounts : [64]ImU8 = default
    TexUvLines : ^mut ImVec4 = default
}
impl ImDrawListSharedData {
    new :: () -> ImDrawListSharedData {
        result : ImDrawListSharedData = default
        __c__ImDrawListSharedData_new_10(^mut result)
        return result
    }
    SetCircleSegmentMaxError :: (&mut Self, _max_error: f32) {
        __c__ImDrawListSharedData_SetCircleSegmentMaxError_11(^mut *self, _max_error)
    }
}
ImDrawDataBuilder :: struct #copy {
    Layers : [2]__UNKNOWN_16 = default
}
impl ImDrawDataBuilder {
    Clear :: (&mut Self) {
        __c__ImDrawDataBuilder_Clear_1(^mut *self)
    }
    ClearFreeMemory :: (&mut Self) {
        __c__ImDrawDataBuilder_ClearFreeMemory_2(^mut *self)
    }
    FlattenIntoSingleLayer :: (&mut Self) {
        __c__ImDrawDataBuilder_FlattenIntoSingleLayer_3(^mut *self)
    }
}
ImGuiDataTypeTempStorage :: struct #copy {
    Data : [8]ImU8 = default
}
ImGuiDataTypeInfo :: struct #copy {
    Size : size_t = default
    Name : ^char8 = default
    PrintFmt : ^char8 = default
    ScanFmt : ^char8 = default
}
ImGuiColorMod :: struct #copy {
    Col : ImGuiCol = default
    BackupValue : ImVec4 = default
}
ImGuiStyleMod :: struct #copy {
    VarIdx : ImGuiStyleVar = default
}
impl ImGuiStyleMod {
    new :: (_idx: ImGuiStyleVar, _v: i32) -> ImGuiStyleMod {
        result : ImGuiStyleMod = default
        __c__ImGuiStyleMod_new_2(^mut result, _idx, _v)
        return result
    }
    new :: (_idx: ImGuiStyleVar, _v: f32) -> ImGuiStyleMod {
        result : ImGuiStyleMod = default
        __c__ImGuiStyleMod_new_3(^mut result, _idx, _v)
        return result
    }
    new :: (_idx: ImGuiStyleVar, _v: ImVec2) -> ImGuiStyleMod {
        result : ImGuiStyleMod = default
        __c__ImGuiStyleMod_new_4(^mut result, _idx, ^mut _v)
        return result
    }
}
ImGuiGroupData :: struct #copy {
    BackupCursorPos : ImVec2 = default
    BackupCursorMaxPos : ImVec2 = default
    BackupIndent : ImVec1 = default
    BackupGroupOffset : ImVec1 = default
    BackupCurrLineSize : ImVec2 = default
    BackupCurrLineTextBaseOffset : f32 = default
    BackupActiveIdIsAlive : ImGuiID = default
    BackupActiveIdPreviousFrameIsAlive : bool = default
    EmitItem : bool = default
}
ImGuiMenuColumns :: struct #copy {
    Spacing : f32 = default
    Width : f32 = default
    NextWidth : f32 = default
    Pos : [3]f32 = default
    NextWidths : [3]f32 = default
}
impl ImGuiMenuColumns {
    new :: () -> ImGuiMenuColumns {
        result : ImGuiMenuColumns = default
        __c__ImGuiMenuColumns_new_5(^mut result)
        return result
    }
    Update :: (&mut Self, _count: i32, _spacing: f32, _clear: bool) {
        __c__ImGuiMenuColumns_Update_6(^mut *self, _count, _spacing, _clear)
    }
    DeclColumns :: (&mut Self, _w0: f32, _w1: f32, _w2: f32) -> f32 {
        mut result : f32 = default
        __c__ImGuiMenuColumns_DeclColumns_7(^mut *self, ^mut result, _w0, _w1, _w2)
        return result
    }
    CalcExtraSpace :: (&mut Self, _avail_w: f32) -> f32 {
        mut result : f32 = default
        __c__ImGuiMenuColumns_CalcExtraSpace_8(^mut *self, ^mut result, _avail_w)
        return result
    }
}
ImGuiInputTextState :: struct #copy {
    ID : ImGuiID = default
    CurLenW : i32 = default
    CurLenA : i32 = default
    TextW : __UNKNOWN_16 = default
    TextA : __UNKNOWN_16 = default
    InitialTextA : __UNKNOWN_16 = default
    TextAIsValid : bool = default
    BufCapacityA : i32 = default
    ScrollX : f32 = default
    Stb : STB_TexteditState = default
    CursorAnim : f32 = default
    CursorFollow : bool = default
    SelectedAllMouseLock : bool = default
    Edited : bool = default
    UserFlags : ImGuiInputTextFlags = default
    UserCallback : ImGuiInputTextCallback = default
    UserCallbackData : ^mut void = default
}
impl ImGuiInputTextState {
    new :: () -> ImGuiInputTextState {
        result : ImGuiInputTextState = default
        __c__ImGuiInputTextState_new_17(^mut result)
        return result
    }
    ClearText :: (&mut Self) {
        __c__ImGuiInputTextState_ClearText_18(^mut *self)
    }
    ClearFreeMemory :: (&mut Self) {
        __c__ImGuiInputTextState_ClearFreeMemory_19(^mut *self)
    }
    GetUndoAvailCount :: (&mut Self) -> i32 {
        mut result : i32 = default
        __c__ImGuiInputTextState_GetUndoAvailCount_20(^mut *self, ^mut result)
        return result
    }
    GetRedoAvailCount :: (&mut Self) -> i32 {
        mut result : i32 = default
        __c__ImGuiInputTextState_GetRedoAvailCount_21(^mut *self, ^mut result)
        return result
    }
    OnKeyPressed :: (&mut Self, _key: i32) {
        __c__ImGuiInputTextState_OnKeyPressed_22(^mut *self, _key)
    }
    CursorAnimReset :: (&mut Self) {
        __c__ImGuiInputTextState_CursorAnimReset_23(^mut *self)
    }
    CursorClamp :: (&mut Self) {
        __c__ImGuiInputTextState_CursorClamp_24(^mut *self)
    }
    HasSelection :: (&mut Self) -> bool {
        mut result : bool = default
        __c__ImGuiInputTextState_HasSelection_25(^mut *self, ^mut result)
        return result
    }
    ClearSelection :: (&mut Self) {
        __c__ImGuiInputTextState_ClearSelection_26(^mut *self)
    }
    SelectAll :: (&mut Self) {
        __c__ImGuiInputTextState_SelectAll_27(^mut *self)
    }
}
ImGuiPopupData :: struct #copy {
    PopupId : ImGuiID = default
    Window : ^mut ImGuiWindow = default
    SourceWindow : ^mut ImGuiWindow = default
    OpenFrameCount : i32 = default
    OpenParentId : ImGuiID = default
    OpenPopupPos : ImVec2 = default
    OpenMousePos : ImVec2 = default
}
impl ImGuiPopupData {
    new :: () -> ImGuiPopupData {
        result : ImGuiPopupData = default
        __c__ImGuiPopupData_new_7(^mut result)
        return result
    }
}
ImGuiNavMoveResult :: struct #copy {
    Window : ^mut ImGuiWindow = default
    ID : ImGuiID = default
    FocusScopeId : ImGuiID = default
    DistBox : f32 = default
    DistCenter : f32 = default
    DistAxial : f32 = default
    RectRel : ImRect = default
}
impl ImGuiNavMoveResult {
    new :: () -> ImGuiNavMoveResult {
        result : ImGuiNavMoveResult = default
        __c__ImGuiNavMoveResult_new_7(^mut result)
        return result
    }
    Clear :: (&mut Self) {
        __c__ImGuiNavMoveResult_Clear_8(^mut *self)
    }
}
ImGuiNextWindowData :: struct #copy {
    Flags : ImGuiNextWindowDataFlags = default
    PosCond : ImGuiCond = default
    SizeCond : ImGuiCond = default
    CollapsedCond : ImGuiCond = default
    DockCond : ImGuiCond = default
    PosVal : ImVec2 = default
    PosPivotVal : ImVec2 = default
    SizeVal : ImVec2 = default
    ContentSizeVal : ImVec2 = default
    ScrollVal : ImVec2 = default
    PosUndock : bool = default
    CollapsedVal : bool = default
    SizeConstraintRect : ImRect = default
    SizeCallback : ImGuiSizeCallback = default
    SizeCallbackUserData : ^mut void = default
    BgAlphaVal : f32 = default
    ViewportId : ImGuiID = default
    DockId : ImGuiID = default
    WindowClass : ImGuiWindowClass = default
    MenuBarOffsetMinVal : ImVec2 = default
}
impl ImGuiNextWindowData {
    new :: () -> ImGuiNextWindowData {
        result : ImGuiNextWindowData = default
        __c__ImGuiNextWindowData_new_20(^mut result)
        return result
    }
    ClearFlags :: (&mut Self) {
        __c__ImGuiNextWindowData_ClearFlags_21(^mut *self)
    }
}
ImGuiNextItemData :: struct #copy {
    Flags : ImGuiNextItemDataFlags = default
    Width : f32 = default
    FocusScopeId : ImGuiID = default
    OpenCond : ImGuiCond = default
    OpenVal : bool = default
}
impl ImGuiNextItemData {
    new :: () -> ImGuiNextItemData {
        result : ImGuiNextItemData = default
        __c__ImGuiNextItemData_new_5(^mut result)
        return result
    }
    ClearFlags :: (&mut Self) {
        __c__ImGuiNextItemData_ClearFlags_6(^mut *self)
    }
}
ImGuiShrinkWidthItem :: struct #copy {
    Index : i32 = default
    Width : f32 = default
}
ImGuiPtrOrIndex :: struct #copy {
    Ptr : ^mut void = default
    Index : i32 = default
}
impl ImGuiPtrOrIndex {
    new :: (_ptr: ^mut void) -> ImGuiPtrOrIndex {
        result : ImGuiPtrOrIndex = default
        __c__ImGuiPtrOrIndex_new_2(^mut result, _ptr)
        return result
    }
    new :: (_index: i32) -> ImGuiPtrOrIndex {
        result : ImGuiPtrOrIndex = default
        __c__ImGuiPtrOrIndex_new_3(^mut result, _index)
        return result
    }
}
ImGuiColumnData :: struct #copy {
    OffsetNorm : f32 = default
    OffsetNormBeforeResize : f32 = default
    Flags : ImGuiColumnsFlags = default
    ClipRect : ImRect = default
}
impl ImGuiColumnData {
    new :: () -> ImGuiColumnData {
        result : ImGuiColumnData = default
        __c__ImGuiColumnData_new_4(^mut result)
        return result
    }
}
ImGuiColumns :: struct #copy {
    ID : ImGuiID = default
    Flags : ImGuiColumnsFlags = default
    IsFirstFrame : bool = default
    IsBeingResized : bool = default
    Current : i32 = default
    Count : i32 = default
    OffMinX : f32 = default
    OffMaxX : f32 = default
    LineMinY : f32 = default
    LineMaxY : f32 = default
    HostCursorPosY : f32 = default
    HostCursorMaxPosX : f32 = default
    HostInitialClipRect : ImRect = default
    HostBackupClipRect : ImRect = default
    HostBackupParentWorkRect : ImRect = default
    Columns : __UNKNOWN_16 = default
    Splitter : ImDrawListSplitter = default
}
impl ImGuiColumns {
    new :: () -> ImGuiColumns {
        result : ImGuiColumns = default
        __c__ImGuiColumns_new_17(^mut result)
        return result
    }
    Clear :: (&mut Self) {
        __c__ImGuiColumns_Clear_18(^mut *self)
    }
}
ImGuiDockNode :: struct #copy {
    ID : ImGuiID = default
    SharedFlags : ImGuiDockNodeFlags = default
    LocalFlags : ImGuiDockNodeFlags = default
    ParentNode : ^mut ImGuiDockNode = default
    ChildNodes : [2]^mut ImGuiDockNode = default
    Windows : __UNKNOWN_16 = default
    TabBar : ^mut ImGuiTabBar = default
    Pos : ImVec2 = default
    Size : ImVec2 = default
    SizeRef : ImVec2 = default
    SplitAxis : ImGuiAxis = default
    WindowClass : ImGuiWindowClass = default
    State : ImGuiDockNodeState = default
    HostWindow : ^mut ImGuiWindow = default
    VisibleWindow : ^mut ImGuiWindow = default
    CentralNode : ^mut ImGuiDockNode = default
    OnlyNodeWithWindows : ^mut ImGuiDockNode = default
    LastFrameAlive : i32 = default
    LastFrameActive : i32 = default
    LastFrameFocused : i32 = default
    LastFocusedNodeId : ImGuiID = default
    SelectedTabId : ImGuiID = default
    WantCloseTabId : ImGuiID = default
    AuthorityForPos : ImGuiDataAuthority = default
    AuthorityForSize : ImGuiDataAuthority = default
    AuthorityForViewport : ImGuiDataAuthority = default
    IsVisible : bool = default
    IsFocused : bool = default
    HasCloseButton : bool = default
    HasWindowMenuButton : bool = default
    EnableCloseButton : bool = default
    WantCloseAll : bool = default
    WantLockSizeOnce : bool = default
    WantMouseMove : bool = default
    WantHiddenTabBarUpdate : bool = default
    WantHiddenTabBarToggle : bool = default
    MarkedForPosSizeWrite : bool = default
}
impl ImGuiDockNode {
    new :: (_id: ImGuiID) -> ImGuiDockNode {
        result : ImGuiDockNode = default
        __c__ImGuiDockNode_new_37(^mut result, _id)
        return result
    }
    IsRootNode :: (&mut Self) -> bool {
        mut result : bool = default
        __c__ImGuiDockNode_IsRootNode_39(^mut *self, ^mut result)
        return result
    }
    IsDockSpace :: (&mut Self) -> bool {
        mut result : bool = default
        __c__ImGuiDockNode_IsDockSpace_40(^mut *self, ^mut result)
        return result
    }
    IsFloatingNode :: (&mut Self) -> bool {
        mut result : bool = default
        __c__ImGuiDockNode_IsFloatingNode_41(^mut *self, ^mut result)
        return result
    }
    IsCentralNode :: (&mut Self) -> bool {
        mut result : bool = default
        __c__ImGuiDockNode_IsCentralNode_42(^mut *self, ^mut result)
        return result
    }
    IsHiddenTabBar :: (&mut Self) -> bool {
        mut result : bool = default
        __c__ImGuiDockNode_IsHiddenTabBar_43(^mut *self, ^mut result)
        return result
    }
    IsNoTabBar :: (&mut Self) -> bool {
        mut result : bool = default
        __c__ImGuiDockNode_IsNoTabBar_44(^mut *self, ^mut result)
        return result
    }
    IsSplitNode :: (&mut Self) -> bool {
        mut result : bool = default
        __c__ImGuiDockNode_IsSplitNode_45(^mut *self, ^mut result)
        return result
    }
    IsLeafNode :: (&mut Self) -> bool {
        mut result : bool = default
        __c__ImGuiDockNode_IsLeafNode_46(^mut *self, ^mut result)
        return result
    }
    IsEmpty :: (&mut Self) -> bool {
        mut result : bool = default
        __c__ImGuiDockNode_IsEmpty_47(^mut *self, ^mut result)
        return result
    }
    GetMergedFlags :: (&mut Self) -> ImGuiDockNodeFlags {
        mut result : ImGuiDockNodeFlags = default
        __c__ImGuiDockNode_GetMergedFlags_48(^mut *self, ^mut result)
        return result
    }
    Rect :: (&mut Self) -> ImRect {
        mut result : ImRect = default
        __c__ImGuiDockNode_Rect_49(^mut *self, ^mut result)
        return result
    }
}
impl Drop for ImGuiDockNode {
    drop :: (&mut Self) {
        __c__ImGuiDockNode_dtor(^*self)
    }
}
ImGuiDockContext :: struct #copy {
    Nodes : ImGuiStorage = default
    Requests : __UNKNOWN_16 = default
    NodesSettings : __UNKNOWN_16 = default
    WantFullRebuild : bool = default
}
impl ImGuiDockContext {
    new :: () -> ImGuiDockContext {
        result : ImGuiDockContext = default
        __c__ImGuiDockContext_new_4(^mut result)
        return result
    }
}
ImGuiViewportP :: struct #copy {
    Idx : i32 = default
    LastFrameActive : i32 = default
    LastFrameDrawLists : [2]i32 = default
    LastFrontMostStampCount : i32 = default
    LastNameHash : ImGuiID = default
    LastPos : ImVec2 = default
    Alpha : f32 = default
    LastAlpha : f32 = default
    PlatformMonitor : i16 = default
    PlatformWindowCreated : bool = default
    Window : ^mut ImGuiWindow = default
    DrawLists : [2]^mut ImDrawList = default
    DrawDataP : ImDrawData = default
    DrawDataBuilder : ImDrawDataBuilder = default
    LastPlatformPos : ImVec2 = default
    LastPlatformSize : ImVec2 = default
    LastRendererSize : ImVec2 = default
    CurrWorkOffsetMin : ImVec2 = default
    CurrWorkOffsetMax : ImVec2 = default
}
impl ImGuiViewportP {
    new :: () -> ImGuiViewportP {
        result : ImGuiViewportP = default
        __c__ImGuiViewportP_new_20(^mut result)
        return result
    }
    GetMainRect :: (&mut Self) -> ImRect {
        mut result : ImRect = default
        __c__ImGuiViewportP_GetMainRect_22(^mut *self, ^mut result)
        return result
    }
    GetWorkRect :: (&mut Self) -> ImRect {
        mut result : ImRect = default
        __c__ImGuiViewportP_GetWorkRect_23(^mut *self, ^mut result)
        return result
    }
    ClearRequestFlags :: (&mut Self) {
        __c__ImGuiViewportP_ClearRequestFlags_24(^mut *self)
    }
}
impl Drop for ImGuiViewportP {
    drop :: (&mut Self) {
        __c__ImGuiViewportP_dtor(^*self)
    }
}
ImGuiWindowSettings :: struct #copy {
    ID : ImGuiID = default
    Pos : ImVec2ih = default
    Size : ImVec2ih = default
    ViewportPos : ImVec2ih = default
    ViewportId : ImGuiID = default
    DockId : ImGuiID = default
    ClassId : ImGuiID = default
    DockOrder : i16 = default
    Collapsed : bool = default
    WantApply : bool = default
}
impl ImGuiWindowSettings {
    new :: () -> ImGuiWindowSettings {
        result : ImGuiWindowSettings = default
        __c__ImGuiWindowSettings_new_10(^mut result)
        return result
    }
    GetName :: (&mut Self) -> ^mut char8 {
        mut result : ^mut char8 = default
        __c__ImGuiWindowSettings_GetName_11(^mut *self, ^mut result)
        return result
    }
}
ImGuiSettingsHandler :: struct #copy {
    TypeName : ^char8 = default
    TypeHash : ImGuiID = default
    ClearAllFn : fn(^mut ImGuiContext, ^mut ImGuiSettingsHandler) -> void = default
    ReadInitFn : fn(^mut ImGuiContext, ^mut ImGuiSettingsHandler) -> void = default
    ReadOpenFn : fn(^mut ImGuiContext, ^mut ImGuiSettingsHandler, ^char8) -> ^mut void = default
    ReadLineFn : fn(^mut ImGuiContext, ^mut ImGuiSettingsHandler, ^mut void, ^char8) -> void = default
    ApplyAllFn : fn(^mut ImGuiContext, ^mut ImGuiSettingsHandler) -> void = default
    WriteAllFn : fn(^mut ImGuiContext, ^mut ImGuiSettingsHandler, ^mut ImGuiTextBuffer) -> void = default
    UserData : ^mut void = default
}
impl ImGuiSettingsHandler {
    new :: () -> ImGuiSettingsHandler {
        result : ImGuiSettingsHandler = default
        __c__ImGuiSettingsHandler_new_9(^mut result)
        return result
    }
}
ImGuiContext :: struct #copy {
    Initialized : bool = default
    FontAtlasOwnedByContext : bool = default
    IO : ImGuiIO = default
    PlatformIO : ImGuiPlatformIO = default
    Style : ImGuiStyle = default
    ConfigFlagsCurrFrame : ImGuiConfigFlags = default
    ConfigFlagsLastFrame : ImGuiConfigFlags = default
    Font : ^mut ImFont = default
    FontSize : f32 = default
    FontBaseSize : f32 = default
    DrawListSharedData : ImDrawListSharedData = default
    Time : f64 = default
    FrameCount : i32 = default
    FrameCountEnded : i32 = default
    FrameCountPlatformEnded : i32 = default
    FrameCountRendered : i32 = default
    WithinFrameScope : bool = default
    WithinFrameScopeWithImplicitWindow : bool = default
    WithinEndChild : bool = default
    TestEngineHookItems : bool = default
    TestEngineHookIdInfo : ImGuiID = default
    TestEngine : ^mut void = default
    Windows : __UNKNOWN_16 = default
    WindowsFocusOrder : __UNKNOWN_16 = default
    WindowsTempSortBuffer : __UNKNOWN_16 = default
    CurrentWindowStack : __UNKNOWN_16 = default
    WindowsById : ImGuiStorage = default
    WindowsActiveCount : i32 = default
    CurrentWindow : ^mut ImGuiWindow = default
    HoveredWindow : ^mut ImGuiWindow = default
    HoveredRootWindow : ^mut ImGuiWindow = default
    HoveredWindowUnderMovingWindow : ^mut ImGuiWindow = default
    HoveredDockNode : ^mut ImGuiDockNode = default
    MovingWindow : ^mut ImGuiWindow = default
    WheelingWindow : ^mut ImGuiWindow = default
    WheelingWindowRefMousePos : ImVec2 = default
    WheelingWindowTimer : f32 = default
    HoveredId : ImGuiID = default
    HoveredIdPreviousFrame : ImGuiID = default
    HoveredIdAllowOverlap : bool = default
    HoveredIdDisabled : bool = default
    HoveredIdTimer : f32 = default
    HoveredIdNotActiveTimer : f32 = default
    ActiveId : ImGuiID = default
    ActiveIdIsAlive : ImGuiID = default
    ActiveIdTimer : f32 = default
    ActiveIdIsJustActivated : bool = default
    ActiveIdAllowOverlap : bool = default
    ActiveIdNoClearOnFocusLoss : bool = default
    ActiveIdHasBeenPressedBefore : bool = default
    ActiveIdHasBeenEditedBefore : bool = default
    ActiveIdHasBeenEditedThisFrame : bool = default
    ActiveIdUsingNavDirMask : ImU32 = default
    ActiveIdUsingNavInputMask : ImU32 = default
    ActiveIdUsingKeyInputMask : ImU64 = default
    ActiveIdClickOffset : ImVec2 = default
    ActiveIdWindow : ^mut ImGuiWindow = default
    ActiveIdSource : ImGuiInputSource = default
    ActiveIdMouseButton : i32 = default
    ActiveIdPreviousFrame : ImGuiID = default
    ActiveIdPreviousFrameIsAlive : bool = default
    ActiveIdPreviousFrameHasBeenEditedBefore : bool = default
    ActiveIdPreviousFrameWindow : ^mut ImGuiWindow = default
    LastActiveId : ImGuiID = default
    LastActiveIdTimer : f32 = default
    NextWindowData : ImGuiNextWindowData = default
    NextItemData : ImGuiNextItemData = default
    ColorModifiers : __UNKNOWN_16 = default
    StyleModifiers : __UNKNOWN_16 = default
    FontStack : __UNKNOWN_16 = default
    OpenPopupStack : __UNKNOWN_16 = default
    BeginPopupStack : __UNKNOWN_16 = default
    Viewports : __UNKNOWN_16 = default
    CurrentDpiScale : f32 = default
    CurrentViewport : ^mut ImGuiViewportP = default
    MouseViewport : ^mut ImGuiViewportP = default
    MouseLastHoveredViewport : ^mut ImGuiViewportP = default
    PlatformLastFocusedViewport : ImGuiID = default
    ViewportFrontMostStampCount : i32 = default
    NavWindow : ^mut ImGuiWindow = default
    NavId : ImGuiID = default
    NavFocusScopeId : ImGuiID = default
    NavActivateId : ImGuiID = default
    NavActivateDownId : ImGuiID = default
    NavActivatePressedId : ImGuiID = default
    NavInputId : ImGuiID = default
    NavJustTabbedId : ImGuiID = default
    NavJustMovedToId : ImGuiID = default
    NavJustMovedToFocusScopeId : ImGuiID = default
    NavJustMovedToKeyMods : ImGuiKeyModFlags = default
    NavNextActivateId : ImGuiID = default
    NavInputSource : ImGuiInputSource = default
    NavScoringRect : ImRect = default
    NavScoringCount : i32 = default
    NavLayer : ImGuiNavLayer = default
    NavIdTabCounter : i32 = default
    NavIdIsAlive : bool = default
    NavMousePosDirty : bool = default
    NavDisableHighlight : bool = default
    NavDisableMouseHover : bool = default
    NavAnyRequest : bool = default
    NavInitRequest : bool = default
    NavInitRequestFromMove : bool = default
    NavInitResultId : ImGuiID = default
    NavInitResultRectRel : ImRect = default
    NavMoveRequest : bool = default
    NavMoveRequestFlags : ImGuiNavMoveFlags = default
    NavMoveRequestForward : ImGuiNavForward = default
    NavMoveRequestKeyMods : ImGuiKeyModFlags = default
    NavMoveDir : ImGuiDir = default
    NavMoveDirLast : ImGuiDir = default
    NavMoveClipDir : ImGuiDir = default
    NavMoveResultLocal : ImGuiNavMoveResult = default
    NavMoveResultLocalVisibleSet : ImGuiNavMoveResult = default
    NavMoveResultOther : ImGuiNavMoveResult = default
    NavWrapRequestWindow : ^mut ImGuiWindow = default
    NavWrapRequestFlags : ImGuiNavMoveFlags = default
    NavWindowingTarget : ^mut ImGuiWindow = default
    NavWindowingTargetAnim : ^mut ImGuiWindow = default
    NavWindowingListWindow : ^mut ImGuiWindow = default
    NavWindowingTimer : f32 = default
    NavWindowingHighlightAlpha : f32 = default
    NavWindowingToggleLayer : bool = default
    FocusRequestCurrWindow : ^mut ImGuiWindow = default
    FocusRequestNextWindow : ^mut ImGuiWindow = default
    FocusRequestCurrCounterRegular : i32 = default
    FocusRequestCurrCounterTabStop : i32 = default
    FocusRequestNextCounterRegular : i32 = default
    FocusRequestNextCounterTabStop : i32 = default
    FocusTabPressed : bool = default
    DimBgRatio : f32 = default
    MouseCursor : ImGuiMouseCursor = default
    DragDropActive : bool = default
    DragDropWithinSource : bool = default
    DragDropWithinTarget : bool = default
    DragDropSourceFlags : ImGuiDragDropFlags = default
    DragDropSourceFrameCount : i32 = default
    DragDropMouseButton : i32 = default
    DragDropPayload : ImGuiPayload = default
    DragDropTargetRect : ImRect = default
    DragDropTargetId : ImGuiID = default
    DragDropAcceptFlags : ImGuiDragDropFlags = default
    DragDropAcceptIdCurrRectSurface : f32 = default
    DragDropAcceptIdCurr : ImGuiID = default
    DragDropAcceptIdPrev : ImGuiID = default
    DragDropAcceptFrameCount : i32 = default
    DragDropHoldJustPressedId : ImGuiID = default
    DragDropPayloadBufHeap : __UNKNOWN_16 = default
    DragDropPayloadBufLocal : [16]u8 = default
    CurrentTabBar : ^mut ImGuiTabBar = default
    TabBars : __UNKNOWN_40 = default
    CurrentTabBarStack : __UNKNOWN_16 = default
    ShrinkWidthBuffer : __UNKNOWN_16 = default
    LastValidMousePos : ImVec2 = default
    InputTextState : ImGuiInputTextState = default
    InputTextPasswordFont : ImFont = default
    TempInputId : ImGuiID = default
    ColorEditOptions : ImGuiColorEditFlags = default
    ColorEditLastHue : f32 = default
    ColorEditLastSat : f32 = default
    ColorEditLastColor : [3]f32 = default
    ColorPickerRef : ImVec4 = default
    SliderCurrentAccum : f32 = default
    SliderCurrentAccumDirty : bool = default
    DragCurrentAccumDirty : bool = default
    DragCurrentAccum : f32 = default
    DragSpeedDefaultRatio : f32 = default
    ScrollbarClickDeltaToGrabCenter : f32 = default
    TooltipOverrideCount : i32 = default
    ClipboardHandlerData : __UNKNOWN_16 = default
    MenusIdSubmittedThisFrame : __UNKNOWN_16 = default
    PlatformImePos : ImVec2 = default
    PlatformImeLastPos : ImVec2 = default
    PlatformImePosViewport : ^mut ImGuiViewportP = default
    PlatformLocaleDecimalPoint : char8 = default
    DockContext : ImGuiDockContext = default
    SettingsLoaded : bool = default
    SettingsDirtyTimer : f32 = default
    SettingsIniData : ImGuiTextBuffer = default
    SettingsHandlers : __UNKNOWN_16 = default
    SettingsWindows : __UNKNOWN_16 = default
    LogEnabled : bool = default
    LogType : ImGuiLogType = default
    LogFile : ImFileHandle = default
    LogBuffer : ImGuiTextBuffer = default
    LogLinePosY : f32 = default
    LogLineFirstItem : bool = default
    LogDepthRef : i32 = default
    LogDepthToExpand : i32 = default
    LogDepthToExpandDefault : i32 = default
    DebugItemPickerActive : bool = default
    DebugItemPickerBreakId : ImGuiID = default
    FramerateSecPerFrame : [120]f32 = default
    FramerateSecPerFrameIdx : i32 = default
    FramerateSecPerFrameAccum : f32 = default
    WantCaptureMouseNextFrame : i32 = default
    WantCaptureKeyboardNextFrame : i32 = default
    WantTextInputNextFrame : i32 = default
    TempBuffer : [3073]char8 = default
}
impl ImGuiContext {
    new :: (_shared_font_atlas: ^mut ImFontAtlas) -> ImGuiContext {
        result : ImGuiContext = default
        __c__ImGuiContext_new_199(^mut result, _shared_font_atlas)
        return result
    }
}
ImGuiWindowTempData :: struct #copy {
    CursorPos : ImVec2 = default
    CursorPosPrevLine : ImVec2 = default
    CursorStartPos : ImVec2 = default
    CursorMaxPos : ImVec2 = default
    CurrLineSize : ImVec2 = default
    PrevLineSize : ImVec2 = default
    CurrLineTextBaseOffset : f32 = default
    PrevLineTextBaseOffset : f32 = default
    Indent : ImVec1 = default
    ColumnsOffset : ImVec1 = default
    GroupOffset : ImVec1 = default
    LastItemId : ImGuiID = default
    LastItemStatusFlags : ImGuiItemStatusFlags = default
    LastItemRect : ImRect = default
    LastItemDisplayRect : ImRect = default
    NavLayerCurrent : ImGuiNavLayer = default
    NavLayerCurrentMask : i32 = default
    NavLayerActiveMask : i32 = default
    NavLayerActiveMaskNext : i32 = default
    NavFocusScopeIdCurrent : ImGuiID = default
    NavHideHighlightOneFrame : bool = default
    NavHasScroll : bool = default
    MenuBarAppending : bool = default
    MenuBarOffset : ImVec2 = default
    MenuColumns : ImGuiMenuColumns = default
    TreeDepth : i32 = default
    TreeJumpToParentOnPopMask : ImU32 = default
    ChildWindows : __UNKNOWN_16 = default
    StateStorage : ^mut ImGuiStorage = default
    CurrentColumns : ^mut ImGuiColumns = default
    LayoutType : ImGuiLayoutType = default
    ParentLayoutType : ImGuiLayoutType = default
    FocusCounterRegular : i32 = default
    FocusCounterTabStop : i32 = default
    ItemFlags : ImGuiItemFlags = default
    ItemWidth : f32 = default
    TextWrapPos : f32 = default
    ItemFlagsStack : __UNKNOWN_16 = default
    ItemWidthStack : __UNKNOWN_16 = default
    TextWrapPosStack : __UNKNOWN_16 = default
    GroupStack : __UNKNOWN_16 = default
    StackSizesBackup : [6]i16 = default
}
impl ImGuiWindowTempData {
    new :: () -> ImGuiWindowTempData {
        result : ImGuiWindowTempData = default
        __c__ImGuiWindowTempData_new_42(^mut result)
        return result
    }
}
ImGuiWindow :: struct #copy {
    Name : ^mut char8 = default
    ID : ImGuiID = default
    Flags : ImGuiWindowFlags = default
    FlagsPreviousFrame : ImGuiWindowFlags = default
    WindowClass : ImGuiWindowClass = default
    Viewport : ^mut ImGuiViewportP = default
    ViewportId : ImGuiID = default
    ViewportPos : ImVec2 = default
    ViewportAllowPlatformMonitorExtend : i32 = default
    Pos : ImVec2 = default
    Size : ImVec2 = default
    SizeFull : ImVec2 = default
    ContentSize : ImVec2 = default
    ContentSizeExplicit : ImVec2 = default
    WindowPadding : ImVec2 = default
    WindowRounding : f32 = default
    WindowBorderSize : f32 = default
    NameBufLen : i32 = default
    MoveId : ImGuiID = default
    ChildId : ImGuiID = default
    Scroll : ImVec2 = default
    ScrollMax : ImVec2 = default
    ScrollTarget : ImVec2 = default
    ScrollTargetCenterRatio : ImVec2 = default
    ScrollTargetEdgeSnapDist : ImVec2 = default
    ScrollbarSizes : ImVec2 = default
    ScrollbarX : bool = default
    ScrollbarY : bool = default
    ViewportOwned : bool = default
    Active : bool = default
    WasActive : bool = default
    WriteAccessed : bool = default
    Collapsed : bool = default
    WantCollapseToggle : bool = default
    SkipItems : bool = default
    Appearing : bool = default
    Hidden : bool = default
    IsFallbackWindow : bool = default
    HasCloseButton : bool = default
    ResizeBorderHeld : i8 = default
    BeginCount : i16 = default
    BeginOrderWithinParent : i16 = default
    BeginOrderWithinContext : i16 = default
    PopupId : ImGuiID = default
    AutoFitFramesX : ImS8 = default
    AutoFitFramesY : ImS8 = default
    AutoFitChildAxises : ImS8 = default
    AutoFitOnlyGrows : bool = default
    AutoPosLastDirection : ImGuiDir = default
    HiddenFramesCanSkipItems : i32 = default
    HiddenFramesCannotSkipItems : i32 = default
    SetWindowPosAllowFlags : ImGuiCond = default
    SetWindowSizeAllowFlags : ImGuiCond = default
    SetWindowCollapsedAllowFlags : ImGuiCond = default
    SetWindowDockAllowFlags : ImGuiCond = default
    SetWindowPosVal : ImVec2 = default
    SetWindowPosPivot : ImVec2 = default
    IDStack : __UNKNOWN_16 = default
    DC : ImGuiWindowTempData = default
    OuterRectClipped : ImRect = default
    InnerRect : ImRect = default
    InnerClipRect : ImRect = default
    WorkRect : ImRect = default
    ParentWorkRect : ImRect = default
    ClipRect : ImRect = default
    ContentRegionRect : ImRect = default
    HitTestHoleSize : ImVec2ih = default
    HitTestHoleOffset : ImVec2ih = default
    LastFrameActive : i32 = default
    LastFrameJustFocused : i32 = default
    LastTimeActive : f32 = default
    ItemWidthDefault : f32 = default
    StateStorage : ImGuiStorage = default
    ColumnsStorage : __UNKNOWN_16 = default
    FontWindowScale : f32 = default
    FontDpiScale : f32 = default
    SettingsOffset : i32 = default
    DrawList : ^mut ImDrawList = default
    DrawListInst : ImDrawList = default
    ParentWindow : ^mut ImGuiWindow = default
    RootWindow : ^mut ImGuiWindow = default
    RootWindowDockStop : ^mut ImGuiWindow = default
    RootWindowForTitleBarHighlight : ^mut ImGuiWindow = default
    RootWindowForNav : ^mut ImGuiWindow = default
    NavLastChildNavWindow : ^mut ImGuiWindow = default
    NavLastIds : [2]ImGuiID = default
    NavRectRel : [2]ImRect = default
    MemoryCompacted : bool = default
    MemoryDrawListIdxCapacity : i32 = default
    MemoryDrawListVtxCapacity : i32 = default
    DockNode : ^mut ImGuiDockNode = default
    DockNodeAsHost : ^mut ImGuiDockNode = default
    DockId : ImGuiID = default
    DockTabItemStatusFlags : ImGuiItemStatusFlags = default
    DockTabItemRect : ImRect = default
    DockOrder : i16 = default
    DockIsActive : bool = default
    DockTabIsVisible : bool = default
    DockTabWantClose : bool = default
}
impl ImGuiWindow {
    new :: (_context: ^mut ImGuiContext, _name: ^char8) -> ImGuiWindow {
        result : ImGuiWindow = default
        __c__ImGuiWindow_new_100(^mut result, _context, _name)
        return result
    }
    GetID :: (&mut Self, _str: ^char8, _str_end: ^char8) -> ImGuiID {
        mut result : ImGuiID = default
        __c__ImGuiWindow_GetID_102(^mut *self, ^mut result, _str, _str_end)
        return result
    }
    GetID :: (&mut Self, _ptr: ^mut void) -> ImGuiID {
        mut result : ImGuiID = default
        __c__ImGuiWindow_GetID_103(^mut *self, ^mut result, _ptr)
        return result
    }
    GetID :: (&mut Self, _n: i32) -> ImGuiID {
        mut result : ImGuiID = default
        __c__ImGuiWindow_GetID_104(^mut *self, ^mut result, _n)
        return result
    }
    GetIDNoKeepAlive :: (&mut Self, _str: ^char8, _str_end: ^char8) -> ImGuiID {
        mut result : ImGuiID = default
        __c__ImGuiWindow_GetIDNoKeepAlive_105(^mut *self, ^mut result, _str, _str_end)
        return result
    }
    GetIDNoKeepAlive :: (&mut Self, _ptr: ^mut void) -> ImGuiID {
        mut result : ImGuiID = default
        __c__ImGuiWindow_GetIDNoKeepAlive_106(^mut *self, ^mut result, _ptr)
        return result
    }
    GetIDNoKeepAlive :: (&mut Self, _n: i32) -> ImGuiID {
        mut result : ImGuiID = default
        __c__ImGuiWindow_GetIDNoKeepAlive_107(^mut *self, ^mut result, _n)
        return result
    }
    GetIDFromRectangle :: (&mut Self, _r_abs: &mut ImRect) -> ImGuiID {
        mut result : ImGuiID = default
        __c__ImGuiWindow_GetIDFromRectangle_108(^mut *self, ^mut result, ^mut *_r_abs)
        return result
    }
    Rect :: (&mut Self) -> ImRect {
        mut result : ImRect = default
        __c__ImGuiWindow_Rect_109(^mut *self, ^mut result)
        return result
    }
    CalcFontSize :: (&mut Self) -> f32 {
        mut result : f32 = default
        __c__ImGuiWindow_CalcFontSize_110(^mut *self, ^mut result)
        return result
    }
    TitleBarHeight :: (&mut Self) -> f32 {
        mut result : f32 = default
        __c__ImGuiWindow_TitleBarHeight_111(^mut *self, ^mut result)
        return result
    }
    TitleBarRect :: (&mut Self) -> ImRect {
        mut result : ImRect = default
        __c__ImGuiWindow_TitleBarRect_112(^mut *self, ^mut result)
        return result
    }
    MenuBarHeight :: (&mut Self) -> f32 {
        mut result : f32 = default
        __c__ImGuiWindow_MenuBarHeight_113(^mut *self, ^mut result)
        return result
    }
    MenuBarRect :: (&mut Self) -> ImRect {
        mut result : ImRect = default
        __c__ImGuiWindow_MenuBarRect_114(^mut *self, ^mut result)
        return result
    }
}
impl Drop for ImGuiWindow {
    drop :: (&mut Self) {
        __c__ImGuiWindow_dtor(^*self)
    }
}
ImGuiLastItemDataBackup :: struct #copy {
    LastItemId : ImGuiID = default
    LastItemStatusFlags : ImGuiItemStatusFlags = default
    LastItemRect : ImRect = default
    LastItemDisplayRect : ImRect = default
}
impl ImGuiLastItemDataBackup {
    new :: () -> ImGuiLastItemDataBackup {
        result : ImGuiLastItemDataBackup = default
        __c__ImGuiLastItemDataBackup_new_4(^mut result)
        return result
    }
    Backup :: (&mut Self) {
        __c__ImGuiLastItemDataBackup_Backup_5(^mut *self)
    }
    Restore :: (&mut Self) {
        __c__ImGuiLastItemDataBackup_Restore_6(^mut *self)
    }
}
ImGuiTabItem :: struct #copy {
    ID : ImGuiID = default
    Flags : ImGuiTabItemFlags = default
    Window : ^mut ImGuiWindow = default
    LastFrameVisible : i32 = default
    LastFrameSelected : i32 = default
    Offset : f32 = default
    Width : f32 = default
    ContentWidth : f32 = default
    NameOffset : ImS16 = default
    BeginOrder : ImS8 = default
    WantClose : bool = default
}
impl ImGuiTabItem {
    new :: () -> ImGuiTabItem {
        result : ImGuiTabItem = default
        __c__ImGuiTabItem_new_11(^mut result)
        return result
    }
}
ImGuiTabBar :: struct #copy {
    Tabs : __UNKNOWN_16 = default
    ID : ImGuiID = default
    SelectedTabId : ImGuiID = default
    NextSelectedTabId : ImGuiID = default
    VisibleTabId : ImGuiID = default
    CurrFrameVisible : i32 = default
    PrevFrameVisible : i32 = default
    BarRect : ImRect = default
    LastTabContentHeight : f32 = default
    WidthAllTabs : f32 = default
    WidthAllTabsIdeal : f32 = default
    OffsetNextTab : f32 = default
    ScrollingAnim : f32 = default
    ScrollingTarget : f32 = default
    ScrollingTargetDistToVisibility : f32 = default
    ScrollingSpeed : f32 = default
    Flags : ImGuiTabBarFlags = default
    ReorderRequestTabId : ImGuiID = default
    ReorderRequestDir : ImS8 = default
    TabsActiveCount : ImS8 = default
    WantLayout : bool = default
    VisibleTabWasSubmitted : bool = default
    LastTabItemIdx : i16 = default
    FramePadding : ImVec2 = default
    TabsNames : ImGuiTextBuffer = default
}
impl ImGuiTabBar {
    new :: () -> ImGuiTabBar {
        result : ImGuiTabBar = default
        __c__ImGuiTabBar_new_25(^mut result)
        return result
    }
    GetTabOrder :: (&mut Self, _tab: ^mut ImGuiTabItem) -> i32 {
        mut result : i32 = default
        __c__ImGuiTabBar_GetTabOrder_26(^mut *self, ^mut result, _tab)
        return result
    }
    GetTabName :: (&mut Self, _tab: ^mut ImGuiTabItem) -> ^char8 {
        mut result : ^char8 = default
        __c__ImGuiTabBar_GetTabName_27(^mut *self, ^mut result, _tab)
        return result
    }
}
CreateContext :: (_shared_font_atlas: ^mut ImFontAtlas) -> ^mut ImGuiContext {
    mut result : ^mut ImGuiContext = default
    __c__CreateContext(^result, _shared_font_atlas)
    return result
}
DestroyContext :: (_ctx: ^mut ImGuiContext) {
    __c__DestroyContext(_ctx)
}
GetCurrentContext :: () -> ^mut ImGuiContext {
    mut result : ^mut ImGuiContext = default
    __c__GetCurrentContext(^result)
    return result
}
SetCurrentContext :: (_ctx: ^mut ImGuiContext) {
    __c__SetCurrentContext(_ctx)
}
GetIO :: () -> &mut ImGuiIO {
    mut result : ^mut ImGuiIO = default
    __c__GetIO(^result)
    return &mut *result
}
GetStyle :: () -> &mut ImGuiStyle {
    mut result : ^mut ImGuiStyle = default
    __c__GetStyle(^result)
    return &mut *result
}
NewFrame :: () {
    __c__NewFrame()
}
EndFrame :: () {
    __c__EndFrame()
}
Render :: () {
    __c__Render()
}
GetDrawData :: () -> ^mut ImDrawData {
    mut result : ^mut ImDrawData = default
    __c__GetDrawData(^result)
    return result
}
ShowDemoWindow :: (_p_open: ^mut bool) {
    __c__ShowDemoWindow(_p_open)
}
ShowAboutWindow :: (_p_open: ^mut bool) {
    __c__ShowAboutWindow(_p_open)
}
ShowMetricsWindow :: (_p_open: ^mut bool) {
    __c__ShowMetricsWindow(_p_open)
}
ShowStyleEditor :: (_ref: ^mut ImGuiStyle) {
    __c__ShowStyleEditor(_ref)
}
ShowStyleSelector :: (_label: ^char8) -> bool {
    mut result : bool = default
    __c__ShowStyleSelector(^result, _label)
    return result
}
ShowFontSelector :: (_label: ^char8) {
    __c__ShowFontSelector(_label)
}
ShowUserGuide :: () {
    __c__ShowUserGuide()
}
GetVersion :: () -> ^char8 {
    mut result : ^char8 = default
    __c__GetVersion(^result)
    return result
}
StyleColorsDark :: (_dst: ^mut ImGuiStyle) {
    __c__StyleColorsDark(_dst)
}
StyleColorsClassic :: (_dst: ^mut ImGuiStyle) {
    __c__StyleColorsClassic(_dst)
}
StyleColorsLight :: (_dst: ^mut ImGuiStyle) {
    __c__StyleColorsLight(_dst)
}
Begin :: (_name: ^char8, _p_open: ^mut bool, _flags: ImGuiWindowFlags) -> bool {
    mut result : bool = default
    __c__Begin(^result, _name, _p_open, _flags)
    return result
}
End :: () {
    __c__End()
}
BeginChild :: (_str_id: ^char8, _size: &mut ImVec2, _border: bool, _flags: ImGuiWindowFlags) -> bool {
    mut result : bool = default
    __c__BeginChild(^result, _str_id, ^mut *_size, _border, _flags)
    return result
}
BeginChild_2 :: (_id: ImGuiID, _size: &mut ImVec2, _border: bool, _flags: ImGuiWindowFlags) -> bool {
    mut result : bool = default
    __c__BeginChild_2(^result, _id, ^mut *_size, _border, _flags)
    return result
}
EndChild :: () {
    __c__EndChild()
}
IsWindowAppearing :: () -> bool {
    mut result : bool = default
    __c__IsWindowAppearing(^result)
    return result
}
IsWindowCollapsed :: () -> bool {
    mut result : bool = default
    __c__IsWindowCollapsed(^result)
    return result
}
IsWindowFocused :: (_flags: ImGuiFocusedFlags) -> bool {
    mut result : bool = default
    __c__IsWindowFocused(^result, _flags)
    return result
}
IsWindowHovered :: (_flags: ImGuiHoveredFlags) -> bool {
    mut result : bool = default
    __c__IsWindowHovered(^result, _flags)
    return result
}
GetWindowDrawList :: () -> ^mut ImDrawList {
    mut result : ^mut ImDrawList = default
    __c__GetWindowDrawList(^result)
    return result
}
GetWindowDpiScale :: () -> f32 {
    mut result : f32 = default
    __c__GetWindowDpiScale(^result)
    return result
}
GetWindowViewport :: () -> ^mut ImGuiViewport {
    mut result : ^mut ImGuiViewport = default
    __c__GetWindowViewport(^result)
    return result
}
GetWindowPos :: () -> ImVec2 {
    mut result : ImVec2 = default
    __c__GetWindowPos(^result)
    return result
}
GetWindowSize :: () -> ImVec2 {
    mut result : ImVec2 = default
    __c__GetWindowSize(^result)
    return result
}
GetWindowWidth :: () -> f32 {
    mut result : f32 = default
    __c__GetWindowWidth(^result)
    return result
}
GetWindowHeight :: () -> f32 {
    mut result : f32 = default
    __c__GetWindowHeight(^result)
    return result
}
SetNextWindowPos :: (_pos: &mut ImVec2, _cond: ImGuiCond, _pivot: &mut ImVec2) {
    __c__SetNextWindowPos(^mut *_pos, _cond, ^mut *_pivot)
}
SetNextWindowSize :: (_size: &mut ImVec2, _cond: ImGuiCond) {
    __c__SetNextWindowSize(^mut *_size, _cond)
}
SetNextWindowSizeConstraints :: (_size_min: &mut ImVec2, _size_max: &mut ImVec2, _custom_callback: ImGuiSizeCallback, _custom_callback_data: ^mut void) {
    __c__SetNextWindowSizeConstraints(^mut *_size_min, ^mut *_size_max, _custom_callback, _custom_callback_data)
}
SetNextWindowContentSize :: (_size: &mut ImVec2) {
    __c__SetNextWindowContentSize(^mut *_size)
}
SetNextWindowCollapsed :: (_collapsed: bool, _cond: ImGuiCond) {
    __c__SetNextWindowCollapsed(_collapsed, _cond)
}
SetNextWindowFocus :: () {
    __c__SetNextWindowFocus()
}
SetNextWindowBgAlpha :: (_alpha: f32) {
    __c__SetNextWindowBgAlpha(_alpha)
}
SetNextWindowViewport :: (_viewport_id: ImGuiID) {
    __c__SetNextWindowViewport(_viewport_id)
}
SetWindowPos :: (_pos: &mut ImVec2, _cond: ImGuiCond) {
    __c__SetWindowPos(^mut *_pos, _cond)
}
SetWindowSize :: (_size: &mut ImVec2, _cond: ImGuiCond) {
    __c__SetWindowSize(^mut *_size, _cond)
}
SetWindowCollapsed :: (_collapsed: bool, _cond: ImGuiCond) {
    __c__SetWindowCollapsed(_collapsed, _cond)
}
SetWindowFocus :: () {
    __c__SetWindowFocus()
}
SetWindowFontScale :: (_scale: f32) {
    __c__SetWindowFontScale(_scale)
}
SetWindowPos_2 :: (_name: ^char8, _pos: &mut ImVec2, _cond: ImGuiCond) {
    __c__SetWindowPos_2(_name, ^mut *_pos, _cond)
}
SetWindowSize_2 :: (_name: ^char8, _size: &mut ImVec2, _cond: ImGuiCond) {
    __c__SetWindowSize_2(_name, ^mut *_size, _cond)
}
SetWindowCollapsed_2 :: (_name: ^char8, _collapsed: bool, _cond: ImGuiCond) {
    __c__SetWindowCollapsed_2(_name, _collapsed, _cond)
}
SetWindowFocus_2 :: (_name: ^char8) {
    __c__SetWindowFocus_2(_name)
}
GetContentRegionMax :: () -> ImVec2 {
    mut result : ImVec2 = default
    __c__GetContentRegionMax(^result)
    return result
}
GetContentRegionAvail :: () -> ImVec2 {
    mut result : ImVec2 = default
    __c__GetContentRegionAvail(^result)
    return result
}
GetWindowContentRegionMin :: () -> ImVec2 {
    mut result : ImVec2 = default
    __c__GetWindowContentRegionMin(^result)
    return result
}
GetWindowContentRegionMax :: () -> ImVec2 {
    mut result : ImVec2 = default
    __c__GetWindowContentRegionMax(^result)
    return result
}
GetWindowContentRegionWidth :: () -> f32 {
    mut result : f32 = default
    __c__GetWindowContentRegionWidth(^result)
    return result
}
GetScrollX :: () -> f32 {
    mut result : f32 = default
    __c__GetScrollX(^result)
    return result
}
GetScrollY :: () -> f32 {
    mut result : f32 = default
    __c__GetScrollY(^result)
    return result
}
GetScrollMaxX :: () -> f32 {
    mut result : f32 = default
    __c__GetScrollMaxX(^result)
    return result
}
GetScrollMaxY :: () -> f32 {
    mut result : f32 = default
    __c__GetScrollMaxY(^result)
    return result
}
SetScrollX :: (_scroll_x: f32) {
    __c__SetScrollX(_scroll_x)
}
SetScrollY :: (_scroll_y: f32) {
    __c__SetScrollY(_scroll_y)
}
SetScrollHereX :: (_center_x_ratio: f32) {
    __c__SetScrollHereX(_center_x_ratio)
}
SetScrollHereY :: (_center_y_ratio: f32) {
    __c__SetScrollHereY(_center_y_ratio)
}
SetScrollFromPosX :: (_local_x: f32, _center_x_ratio: f32) {
    __c__SetScrollFromPosX(_local_x, _center_x_ratio)
}
SetScrollFromPosY :: (_local_y: f32, _center_y_ratio: f32) {
    __c__SetScrollFromPosY(_local_y, _center_y_ratio)
}
PushFont :: (_font: ^mut ImFont) {
    __c__PushFont(_font)
}
PopFont :: () {
    __c__PopFont()
}
PushStyleColor :: (_idx: ImGuiCol, _col: ImU32) {
    __c__PushStyleColor(_idx, _col)
}
PushStyleColor_2 :: (_idx: ImGuiCol, _col: &mut ImVec4) {
    __c__PushStyleColor_2(_idx, ^mut *_col)
}
PopStyleColor :: (_count: i32) {
    __c__PopStyleColor(_count)
}
PushStyleVar :: (_idx: ImGuiStyleVar, _val: f32) {
    __c__PushStyleVar(_idx, _val)
}
PushStyleVarVec :: (_idx: ImGuiStyleVar, _val: &mut ImVec2) {
    __c__PushStyleVar_2(_idx, ^mut *_val)
}
PopStyleVar :: (_count: i32) {
    __c__PopStyleVar(_count)
}
GetStyleColorVec4 :: (_idx: ImGuiCol) -> &mut ImVec4 {
    mut result : ^mut ImVec4 = default
    __c__GetStyleColorVec4(^result, _idx)
    return &mut *result
}
GetFont :: () -> ^mut ImFont {
    mut result : ^mut ImFont = default
    __c__GetFont(^result)
    return result
}
GetFontSize :: () -> f32 {
    mut result : f32 = default
    __c__GetFontSize(^result)
    return result
}
GetFontTexUvWhitePixel :: () -> ImVec2 {
    mut result : ImVec2 = default
    __c__GetFontTexUvWhitePixel(^result)
    return result
}
GetColorU32 :: (_idx: ImGuiCol, _alpha_mul: f32) -> ImU32 {
    mut result : ImU32 = default
    __c__GetColorU32(^result, _idx, _alpha_mul)
    return result
}
GetColorU32_2 :: (_col: &mut ImVec4) -> ImU32 {
    mut result : ImU32 = default
    __c__GetColorU32_2(^result, ^mut *_col)
    return result
}
GetColorU32_3 :: (_col: ImU32) -> ImU32 {
    mut result : ImU32 = default
    __c__GetColorU32_3(^result, _col)
    return result
}
PushItemWidth :: (_item_width: f32) {
    __c__PushItemWidth(_item_width)
}
PopItemWidth :: () {
    __c__PopItemWidth()
}
SetNextItemWidth :: (_item_width: f32) {
    __c__SetNextItemWidth(_item_width)
}
CalcItemWidth :: () -> f32 {
    mut result : f32 = default
    __c__CalcItemWidth(^result)
    return result
}
PushTextWrapPos :: (_wrap_local_pos_x: f32) {
    __c__PushTextWrapPos(_wrap_local_pos_x)
}
PopTextWrapPos :: () {
    __c__PopTextWrapPos()
}
PushAllowKeyboardFocus :: (_allow_keyboard_focus: bool) {
    __c__PushAllowKeyboardFocus(_allow_keyboard_focus)
}
PopAllowKeyboardFocus :: () {
    __c__PopAllowKeyboardFocus()
}
PushButtonRepeat :: (_repeat: bool) {
    __c__PushButtonRepeat(_repeat)
}
PopButtonRepeat :: () {
    __c__PopButtonRepeat()
}
Separator :: () {
    __c__Separator()
}
SameLine :: (_offset_from_start_x: f32, _spacing: f32) {
    __c__SameLine(_offset_from_start_x, _spacing)
}
NewLine :: () {
    __c__NewLine()
}
Spacing :: () {
    __c__Spacing()
}
Dummy :: (_size: &mut ImVec2) {
    __c__Dummy(^mut *_size)
}
Indent :: (_indent_w: f32) {
    __c__Indent(_indent_w)
}
Unindent :: (_indent_w: f32) {
    __c__Unindent(_indent_w)
}
BeginGroup :: () {
    __c__BeginGroup()
}
EndGroup :: () {
    __c__EndGroup()
}
GetCursorPos :: () -> ImVec2 {
    mut result : ImVec2 = default
    __c__GetCursorPos(^result)
    return result
}
GetCursorPosX :: () -> f32 {
    mut result : f32 = default
    __c__GetCursorPosX(^result)
    return result
}
GetCursorPosY :: () -> f32 {
    mut result : f32 = default
    __c__GetCursorPosY(^result)
    return result
}
SetCursorPos :: (_local_pos: &mut ImVec2) {
    __c__SetCursorPos(^mut *_local_pos)
}
SetCursorPosX :: (_local_x: f32) {
    __c__SetCursorPosX(_local_x)
}
SetCursorPosY :: (_local_y: f32) {
    __c__SetCursorPosY(_local_y)
}
GetCursorStartPos :: () -> ImVec2 {
    mut result : ImVec2 = default
    __c__GetCursorStartPos(^result)
    return result
}
GetCursorScreenPos :: () -> ImVec2 {
    mut result : ImVec2 = default
    __c__GetCursorScreenPos(^result)
    return result
}
SetCursorScreenPos :: (_pos: &mut ImVec2) {
    __c__SetCursorScreenPos(^mut *_pos)
}
AlignTextToFramePadding :: () {
    __c__AlignTextToFramePadding()
}
GetTextLineHeight :: () -> f32 {
    mut result : f32 = default
    __c__GetTextLineHeight(^result)
    return result
}
GetTextLineHeightWithSpacing :: () -> f32 {
    mut result : f32 = default
    __c__GetTextLineHeightWithSpacing(^result)
    return result
}
GetFrameHeight :: () -> f32 {
    mut result : f32 = default
    __c__GetFrameHeight(^result)
    return result
}
GetFrameHeightWithSpacing :: () -> f32 {
    mut result : f32 = default
    __c__GetFrameHeightWithSpacing(^result)
    return result
}
PushID :: (_str_id: ^char8) {
    __c__PushID(_str_id)
}
PushID_2 :: (_str_id_begin: ^char8, _str_id_end: ^char8) {
    __c__PushID_2(_str_id_begin, _str_id_end)
}
PushID_3 :: (_ptr_id: ^mut void) {
    __c__PushID_3(_ptr_id)
}
PushID_4 :: (_int_id: i32) {
    __c__PushID_4(_int_id)
}
PopID :: () {
    __c__PopID()
}
GetID :: (_str_id: ^char8) -> ImGuiID {
    mut result : ImGuiID = default
    __c__GetID(^result, _str_id)
    return result
}
GetID_2 :: (_str_id_begin: ^char8, _str_id_end: ^char8) -> ImGuiID {
    mut result : ImGuiID = default
    __c__GetID_2(^result, _str_id_begin, _str_id_end)
    return result
}
GetID_3 :: (_ptr_id: ^mut void) -> ImGuiID {
    mut result : ImGuiID = default
    __c__GetID_3(^result, _ptr_id)
    return result
}
TextUnformatted :: (_text: ^char8, _text_end: ^char8) {
    __c__TextUnformatted(_text, _text_end)
}
Text :: (_fmt: ^char8) {
    __c__Text(_fmt)
}
TextV :: (_fmt: ^char8, _args: va_list) {
    __c__TextV(_fmt, _args)
}
TextColored :: (_col: &mut ImVec4, _fmt: ^char8) {
    __c__TextColored(^mut *_col, _fmt)
}
TextColoredV :: (_col: &mut ImVec4, _fmt: ^char8, _args: va_list) {
    __c__TextColoredV(^mut *_col, _fmt, _args)
}
TextDisabled :: (_fmt: ^char8) {
    __c__TextDisabled(_fmt)
}
TextDisabledV :: (_fmt: ^char8, _args: va_list) {
    __c__TextDisabledV(_fmt, _args)
}
TextWrapped :: (_fmt: ^char8) {
    __c__TextWrapped(_fmt)
}
TextWrappedV :: (_fmt: ^char8, _args: va_list) {
    __c__TextWrappedV(_fmt, _args)
}
LabelText :: (_label: ^char8, _fmt: ^char8) {
    __c__LabelText(_label, _fmt)
}
LabelTextV :: (_label: ^char8, _fmt: ^char8, _args: va_list) {
    __c__LabelTextV(_label, _fmt, _args)
}
BulletText :: (_fmt: ^char8) {
    __c__BulletText(_fmt)
}
BulletTextV :: (_fmt: ^char8, _args: va_list) {
    __c__BulletTextV(_fmt, _args)
}
Button :: (_label: ^char8, _size: &mut ImVec2) -> bool {
    mut result : bool = default
    __c__Button(^result, _label, ^mut *_size)
    return result
}
SmallButton :: (_label: ^char8) -> bool {
    mut result : bool = default
    __c__SmallButton(^result, _label)
    return result
}
InvisibleButton :: (_str_id: ^char8, _size: &mut ImVec2, _flags: ImGuiButtonFlags) -> bool {
    mut result : bool = default
    __c__InvisibleButton(^result, _str_id, ^mut *_size, _flags)
    return result
}
ArrowButton :: (_str_id: ^char8, _dir: ImGuiDir) -> bool {
    mut result : bool = default
    __c__ArrowButton(^result, _str_id, _dir)
    return result
}
Image :: (_user_texture_id: ImTextureID, _size: &mut ImVec2, _uv0: &mut ImVec2, _uv1: &mut ImVec2, _tint_col: &mut ImVec4, _border_col: &mut ImVec4) {
    __c__Image(_user_texture_id, ^mut *_size, ^mut *_uv0, ^mut *_uv1, ^mut *_tint_col, ^mut *_border_col)
}
ImageButton :: (_user_texture_id: ImTextureID, _size: &mut ImVec2, _uv0: &mut ImVec2, _uv1: &mut ImVec2, _frame_padding: i32, _bg_col: &mut ImVec4, _tint_col: &mut ImVec4) -> bool {
    mut result : bool = default
    __c__ImageButton(^result, _user_texture_id, ^mut *_size, ^mut *_uv0, ^mut *_uv1, _frame_padding, ^mut *_bg_col, ^mut *_tint_col)
    return result
}
Checkbox :: (_label: ^char8, _v: ^mut bool) -> bool {
    mut result : bool = default
    __c__Checkbox(^result, _label, _v)
    return result
}
CheckboxFlags :: (_label: ^char8, _flags: ^mut u32, _flags_value: u32) -> bool {
    mut result : bool = default
    __c__CheckboxFlags(^result, _label, _flags, _flags_value)
    return result
}
RadioButton :: (_label: ^char8, _active: bool) -> bool {
    mut result : bool = default
    __c__RadioButton(^result, _label, _active)
    return result
}
RadioButton_2 :: (_label: ^char8, _v: ^mut i32, _v_button: i32) -> bool {
    mut result : bool = default
    __c__RadioButton_2(^result, _label, _v, _v_button)
    return result
}
ProgressBar :: (_fraction: f32, _size_arg: &mut ImVec2, _overlay: ^char8) {
    __c__ProgressBar(_fraction, ^mut *_size_arg, _overlay)
}
Bullet :: () {
    __c__Bullet()
}
BeginCombo :: (_label: ^char8, _preview_value: ^char8, _flags: ImGuiComboFlags) -> bool {
    mut result : bool = default
    __c__BeginCombo(^result, _label, _preview_value, _flags)
    return result
}
EndCombo :: () {
    __c__EndCombo()
}
Combo :: (_label: ^char8, _current_item: ^mut i32, _items: ^mut ^char8, _items_count: i32, _popup_max_height_in_items: i32) -> bool {
    mut result : bool = default
    __c__Combo(^result, _label, _current_item, _items, _items_count, _popup_max_height_in_items)
    return result
}
Combo_2 :: (_label: ^char8, _current_item: ^mut i32, _items_separated_by_zeros: ^char8, _popup_max_height_in_items: i32) -> bool {
    mut result : bool = default
    __c__Combo_2(^result, _label, _current_item, _items_separated_by_zeros, _popup_max_height_in_items)
    return result
}
Combo_3 :: (_label: ^char8, _current_item: ^mut i32, _items_getter: fn(^mut void, i32, ^mut ^char8) -> bool, _data: ^mut void, _items_count: i32, _popup_max_height_in_items: i32) -> bool {
    mut result : bool = default
    __c__Combo_3(^result, _label, _current_item, _items_getter, _data, _items_count, _popup_max_height_in_items)
    return result
}
DragFloat :: (_label: ^char8, _v: ^mut f32, _v_speed: f32, _v_min: f32, _v_max: f32, _format: ^char8, _flags: ImGuiSliderFlags) -> bool {
    mut result : bool = default
    __c__DragFloat(^result, _label, _v, _v_speed, _v_min, _v_max, _format, _flags)
    return result
}
DragFloat2 :: (_label: ^char8, _v: ^mut f32, _v_speed: f32, _v_min: f32, _v_max: f32, _format: ^char8, _flags: ImGuiSliderFlags) -> bool {
    mut result : bool = default
    __c__DragFloat2(^result, _label, _v, _v_speed, _v_min, _v_max, _format, _flags)
    return result
}
DragFloat3 :: (_label: ^char8, _v: ^mut f32, _v_speed: f32, _v_min: f32, _v_max: f32, _format: ^char8, _flags: ImGuiSliderFlags) -> bool {
    mut result : bool = default
    __c__DragFloat3(^result, _label, _v, _v_speed, _v_min, _v_max, _format, _flags)
    return result
}
DragFloat4 :: (_label: ^char8, _v: ^mut f32, _v_speed: f32, _v_min: f32, _v_max: f32, _format: ^char8, _flags: ImGuiSliderFlags) -> bool {
    mut result : bool = default
    __c__DragFloat4(^result, _label, _v, _v_speed, _v_min, _v_max, _format, _flags)
    return result
}
DragFloatRange2 :: (_label: ^char8, _v_current_min: ^mut f32, _v_current_max: ^mut f32, _v_speed: f32, _v_min: f32, _v_max: f32, _format: ^char8, _format_max: ^char8, _flags: ImGuiSliderFlags) -> bool {
    mut result : bool = default
    __c__DragFloatRange2(^result, _label, _v_current_min, _v_current_max, _v_speed, _v_min, _v_max, _format, _format_max, _flags)
    return result
}
DragInt :: (_label: ^char8, _v: ^mut i32, _v_speed: f32, _v_min: i32, _v_max: i32, _format: ^char8, _flags: ImGuiSliderFlags) -> bool {
    mut result : bool = default
    __c__DragInt(^result, _label, _v, _v_speed, _v_min, _v_max, _format, _flags)
    return result
}
DragInt2 :: (_label: ^char8, _v: ^mut i32, _v_speed: f32, _v_min: i32, _v_max: i32, _format: ^char8, _flags: ImGuiSliderFlags) -> bool {
    mut result : bool = default
    __c__DragInt2(^result, _label, _v, _v_speed, _v_min, _v_max, _format, _flags)
    return result
}
DragInt3 :: (_label: ^char8, _v: ^mut i32, _v_speed: f32, _v_min: i32, _v_max: i32, _format: ^char8, _flags: ImGuiSliderFlags) -> bool {
    mut result : bool = default
    __c__DragInt3(^result, _label, _v, _v_speed, _v_min, _v_max, _format, _flags)
    return result
}
DragInt4 :: (_label: ^char8, _v: ^mut i32, _v_speed: f32, _v_min: i32, _v_max: i32, _format: ^char8, _flags: ImGuiSliderFlags) -> bool {
    mut result : bool = default
    __c__DragInt4(^result, _label, _v, _v_speed, _v_min, _v_max, _format, _flags)
    return result
}
DragIntRange2 :: (_label: ^char8, _v_current_min: ^mut i32, _v_current_max: ^mut i32, _v_speed: f32, _v_min: i32, _v_max: i32, _format: ^char8, _format_max: ^char8, _flags: ImGuiSliderFlags) -> bool {
    mut result : bool = default
    __c__DragIntRange2(^result, _label, _v_current_min, _v_current_max, _v_speed, _v_min, _v_max, _format, _format_max, _flags)
    return result
}
DragScalar :: (_label: ^char8, _data_type: ImGuiDataType, _p_data: ^mut void, _v_speed: f32, _p_min: ^mut void, _p_max: ^mut void, _format: ^char8, _flags: ImGuiSliderFlags) -> bool {
    mut result : bool = default
    __c__DragScalar(^result, _label, _data_type, _p_data, _v_speed, _p_min, _p_max, _format, _flags)
    return result
}
DragScalarN :: (_label: ^char8, _data_type: ImGuiDataType, _p_data: ^mut void, _components: i32, _v_speed: f32, _p_min: ^mut void, _p_max: ^mut void, _format: ^char8, _flags: ImGuiSliderFlags) -> bool {
    mut result : bool = default
    __c__DragScalarN(^result, _label, _data_type, _p_data, _components, _v_speed, _p_min, _p_max, _format, _flags)
    return result
}
SliderFloat :: (_label: ^char8, _v: ^mut f32, _v_min: f32, _v_max: f32, _format: ^char8, _flags: ImGuiSliderFlags) -> bool {
    mut result : bool = default
    __c__SliderFloat(^result, _label, _v, _v_min, _v_max, _format, _flags)
    return result
}
SliderFloat2 :: (_label: ^char8, _v: ^mut f32, _v_min: f32, _v_max: f32, _format: ^char8, _flags: ImGuiSliderFlags) -> bool {
    mut result : bool = default
    __c__SliderFloat2(^result, _label, _v, _v_min, _v_max, _format, _flags)
    return result
}
SliderFloat3 :: (_label: ^char8, _v: ^mut f32, _v_min: f32, _v_max: f32, _format: ^char8, _flags: ImGuiSliderFlags) -> bool {
    mut result : bool = default
    __c__SliderFloat3(^result, _label, _v, _v_min, _v_max, _format, _flags)
    return result
}
SliderFloat4 :: (_label: ^char8, _v: ^mut f32, _v_min: f32, _v_max: f32, _format: ^char8, _flags: ImGuiSliderFlags) -> bool {
    mut result : bool = default
    __c__SliderFloat4(^result, _label, _v, _v_min, _v_max, _format, _flags)
    return result
}
SliderAngle :: (_label: ^char8, _v_rad: ^mut f32, _v_degrees_min: f32, _v_degrees_max: f32, _format: ^char8, _flags: ImGuiSliderFlags) -> bool {
    mut result : bool = default
    __c__SliderAngle(^result, _label, _v_rad, _v_degrees_min, _v_degrees_max, _format, _flags)
    return result
}
SliderInt :: (_label: ^char8, _v: ^mut i32, _v_min: i32, _v_max: i32, _format: ^char8, _flags: ImGuiSliderFlags) -> bool {
    mut result : bool = default
    __c__SliderInt(^result, _label, _v, _v_min, _v_max, _format, _flags)
    return result
}
SliderInt2 :: (_label: ^char8, _v: ^mut i32, _v_min: i32, _v_max: i32, _format: ^char8, _flags: ImGuiSliderFlags) -> bool {
    mut result : bool = default
    __c__SliderInt2(^result, _label, _v, _v_min, _v_max, _format, _flags)
    return result
}
SliderInt3 :: (_label: ^char8, _v: ^mut i32, _v_min: i32, _v_max: i32, _format: ^char8, _flags: ImGuiSliderFlags) -> bool {
    mut result : bool = default
    __c__SliderInt3(^result, _label, _v, _v_min, _v_max, _format, _flags)
    return result
}
SliderInt4 :: (_label: ^char8, _v: ^mut i32, _v_min: i32, _v_max: i32, _format: ^char8, _flags: ImGuiSliderFlags) -> bool {
    mut result : bool = default
    __c__SliderInt4(^result, _label, _v, _v_min, _v_max, _format, _flags)
    return result
}
SliderScalar :: (_label: ^char8, _data_type: ImGuiDataType, _p_data: ^mut void, _p_min: ^mut void, _p_max: ^mut void, _format: ^char8, _flags: ImGuiSliderFlags) -> bool {
    mut result : bool = default
    __c__SliderScalar(^result, _label, _data_type, _p_data, _p_min, _p_max, _format, _flags)
    return result
}
SliderScalarN :: (_label: ^char8, _data_type: ImGuiDataType, _p_data: ^mut void, _components: i32, _p_min: ^mut void, _p_max: ^mut void, _format: ^char8, _flags: ImGuiSliderFlags) -> bool {
    mut result : bool = default
    __c__SliderScalarN(^result, _label, _data_type, _p_data, _components, _p_min, _p_max, _format, _flags)
    return result
}
VSliderFloat :: (_label: ^char8, _size: &mut ImVec2, _v: ^mut f32, _v_min: f32, _v_max: f32, _format: ^char8, _flags: ImGuiSliderFlags) -> bool {
    mut result : bool = default
    __c__VSliderFloat(^result, _label, ^mut *_size, _v, _v_min, _v_max, _format, _flags)
    return result
}
VSliderInt :: (_label: ^char8, _size: &mut ImVec2, _v: ^mut i32, _v_min: i32, _v_max: i32, _format: ^char8, _flags: ImGuiSliderFlags) -> bool {
    mut result : bool = default
    __c__VSliderInt(^result, _label, ^mut *_size, _v, _v_min, _v_max, _format, _flags)
    return result
}
VSliderScalar :: (_label: ^char8, _size: &mut ImVec2, _data_type: ImGuiDataType, _p_data: ^mut void, _p_min: ^mut void, _p_max: ^mut void, _format: ^char8, _flags: ImGuiSliderFlags) -> bool {
    mut result : bool = default
    __c__VSliderScalar(^result, _label, ^mut *_size, _data_type, _p_data, _p_min, _p_max, _format, _flags)
    return result
}
InputText :: (_label: ^char8, _buf: ^mut char8, _buf_size: size_t, _flags: ImGuiInputTextFlags, _callback: ImGuiInputTextCallback, _user_data: ^mut void) -> bool {
    mut result : bool = default
    __c__InputText(^result, _label, _buf, _buf_size, _flags, _callback, _user_data)
    return result
}
InputTextMultiline :: (_label: ^char8, _buf: ^mut char8, _buf_size: size_t, _size: &mut ImVec2, _flags: ImGuiInputTextFlags, _callback: ImGuiInputTextCallback, _user_data: ^mut void) -> bool {
    mut result : bool = default
    __c__InputTextMultiline(^result, _label, _buf, _buf_size, ^mut *_size, _flags, _callback, _user_data)
    return result
}
InputTextWithHint :: (_label: ^char8, _hint: ^char8, _buf: ^mut char8, _buf_size: size_t, _flags: ImGuiInputTextFlags, _callback: ImGuiInputTextCallback, _user_data: ^mut void) -> bool {
    mut result : bool = default
    __c__InputTextWithHint(^result, _label, _hint, _buf, _buf_size, _flags, _callback, _user_data)
    return result
}
InputFloat :: (_label: ^char8, _v: ^mut f32, _step: f32, _step_fast: f32, _format: ^char8, _flags: ImGuiInputTextFlags) -> bool {
    mut result : bool = default
    __c__InputFloat(^result, _label, _v, _step, _step_fast, _format, _flags)
    return result
}
InputFloat2 :: (_label: ^char8, _v: ^mut f32, _format: ^char8, _flags: ImGuiInputTextFlags) -> bool {
    mut result : bool = default
    __c__InputFloat2(^result, _label, _v, _format, _flags)
    return result
}
InputFloat3 :: (_label: ^char8, _v: ^mut f32, _format: ^char8, _flags: ImGuiInputTextFlags) -> bool {
    mut result : bool = default
    __c__InputFloat3(^result, _label, _v, _format, _flags)
    return result
}
InputFloat4 :: (_label: ^char8, _v: ^mut f32, _format: ^char8, _flags: ImGuiInputTextFlags) -> bool {
    mut result : bool = default
    __c__InputFloat4(^result, _label, _v, _format, _flags)
    return result
}
InputInt :: (_label: ^char8, _v: ^mut i32, _step: i32, _step_fast: i32, _flags: ImGuiInputTextFlags) -> bool {
    mut result : bool = default
    __c__InputInt(^result, _label, _v, _step, _step_fast, _flags)
    return result
}
InputInt2 :: (_label: ^char8, _v: ^mut i32, _flags: ImGuiInputTextFlags) -> bool {
    mut result : bool = default
    __c__InputInt2(^result, _label, _v, _flags)
    return result
}
InputInt3 :: (_label: ^char8, _v: ^mut i32, _flags: ImGuiInputTextFlags) -> bool {
    mut result : bool = default
    __c__InputInt3(^result, _label, _v, _flags)
    return result
}
InputInt4 :: (_label: ^char8, _v: ^mut i32, _flags: ImGuiInputTextFlags) -> bool {
    mut result : bool = default
    __c__InputInt4(^result, _label, _v, _flags)
    return result
}
InputDouble :: (_label: ^char8, _v: ^mut f64, _step: f64, _step_fast: f64, _format: ^char8, _flags: ImGuiInputTextFlags) -> bool {
    mut result : bool = default
    __c__InputDouble(^result, _label, _v, _step, _step_fast, _format, _flags)
    return result
}
InputScalar :: (_label: ^char8, _data_type: ImGuiDataType, _p_data: ^mut void, _p_step: ^mut void, _p_step_fast: ^mut void, _format: ^char8, _flags: ImGuiInputTextFlags) -> bool {
    mut result : bool = default
    __c__InputScalar(^result, _label, _data_type, _p_data, _p_step, _p_step_fast, _format, _flags)
    return result
}
InputScalarN :: (_label: ^char8, _data_type: ImGuiDataType, _p_data: ^mut void, _components: i32, _p_step: ^mut void, _p_step_fast: ^mut void, _format: ^char8, _flags: ImGuiInputTextFlags) -> bool {
    mut result : bool = default
    __c__InputScalarN(^result, _label, _data_type, _p_data, _components, _p_step, _p_step_fast, _format, _flags)
    return result
}
ColorEdit3 :: (_label: ^char8, _col: ^mut f32, _flags: ImGuiColorEditFlags) -> bool {
    mut result : bool = default
    __c__ColorEdit3(^result, _label, _col, _flags)
    return result
}
ColorEdit4 :: (_label: ^char8, _col: ^mut f32, _flags: ImGuiColorEditFlags) -> bool {
    mut result : bool = default
    __c__ColorEdit4(^result, _label, _col, _flags)
    return result
}
ColorPicker3 :: (_label: ^char8, _col: ^mut f32, _flags: ImGuiColorEditFlags) -> bool {
    mut result : bool = default
    __c__ColorPicker3(^result, _label, _col, _flags)
    return result
}
ColorPicker4 :: (_label: ^char8, _col: ^mut f32, _flags: ImGuiColorEditFlags, _ref_col: ^f32) -> bool {
    mut result : bool = default
    __c__ColorPicker4(^result, _label, _col, _flags, _ref_col)
    return result
}
ColorButton :: (_desc_id: ^char8, _col: &mut ImVec4, _flags: ImGuiColorEditFlags, _size: ImVec2) -> bool {
    mut result : bool = default
    __c__ColorButton(^result, _desc_id, ^mut *_col, _flags, ^mut _size)
    return result
}
SetColorEditOptions :: (_flags: ImGuiColorEditFlags) {
    __c__SetColorEditOptions(_flags)
}
TreeNode :: (_label: ^char8) -> bool {
    mut result : bool = default
    __c__TreeNode(^result, _label)
    return result
}
TreeNode_2 :: (_str_id: ^char8, _fmt: ^char8) -> bool {
    mut result : bool = default
    __c__TreeNode_2(^result, _str_id, _fmt)
    return result
}
TreeNode_3 :: (_ptr_id: ^mut void, _fmt: ^char8) -> bool {
    mut result : bool = default
    __c__TreeNode_3(^result, _ptr_id, _fmt)
    return result
}
TreeNodeV :: (_str_id: ^char8, _fmt: ^char8, _args: va_list) -> bool {
    mut result : bool = default
    __c__TreeNodeV(^result, _str_id, _fmt, _args)
    return result
}
TreeNodeV_2 :: (_ptr_id: ^mut void, _fmt: ^char8, _args: va_list) -> bool {
    mut result : bool = default
    __c__TreeNodeV_2(^result, _ptr_id, _fmt, _args)
    return result
}
TreeNodeEx :: (_label: ^char8, _flags: ImGuiTreeNodeFlags) -> bool {
    mut result : bool = default
    __c__TreeNodeEx(^result, _label, _flags)
    return result
}
TreeNodeEx_2 :: (_str_id: ^char8, _flags: ImGuiTreeNodeFlags, _fmt: ^char8) -> bool {
    mut result : bool = default
    __c__TreeNodeEx_2(^result, _str_id, _flags, _fmt)
    return result
}
TreeNodeEx_3 :: (_ptr_id: ^mut void, _flags: ImGuiTreeNodeFlags, _fmt: ^char8) -> bool {
    mut result : bool = default
    __c__TreeNodeEx_3(^result, _ptr_id, _flags, _fmt)
    return result
}
TreeNodeExV :: (_str_id: ^char8, _flags: ImGuiTreeNodeFlags, _fmt: ^char8, _args: va_list) -> bool {
    mut result : bool = default
    __c__TreeNodeExV(^result, _str_id, _flags, _fmt, _args)
    return result
}
TreeNodeExV_2 :: (_ptr_id: ^mut void, _flags: ImGuiTreeNodeFlags, _fmt: ^char8, _args: va_list) -> bool {
    mut result : bool = default
    __c__TreeNodeExV_2(^result, _ptr_id, _flags, _fmt, _args)
    return result
}
TreePush :: (_str_id: ^char8) {
    __c__TreePush(_str_id)
}
TreePush_2 :: (_ptr_id: ^mut void) {
    __c__TreePush_2(_ptr_id)
}
TreePop :: () {
    __c__TreePop()
}
GetTreeNodeToLabelSpacing :: () -> f32 {
    mut result : f32 = default
    __c__GetTreeNodeToLabelSpacing(^result)
    return result
}
CollapsingHeader :: (_label: ^char8, _flags: ImGuiTreeNodeFlags) -> bool {
    mut result : bool = default
    __c__CollapsingHeader(^result, _label, _flags)
    return result
}
CollapsingHeader_2 :: (_label: ^char8, _p_open: ^mut bool, _flags: ImGuiTreeNodeFlags) -> bool {
    mut result : bool = default
    __c__CollapsingHeader_2(^result, _label, _p_open, _flags)
    return result
}
SetNextItemOpen :: (_is_open: bool, _cond: ImGuiCond) {
    __c__SetNextItemOpen(_is_open, _cond)
}
Selectable :: (_label: ^char8, _selected: bool, _flags: ImGuiSelectableFlags, _size: &mut ImVec2) -> bool {
    mut result : bool = default
    __c__Selectable(^result, _label, _selected, _flags, ^mut *_size)
    return result
}
Selectable_2 :: (_label: ^char8, _p_selected: ^mut bool, _flags: ImGuiSelectableFlags, _size: &mut ImVec2) -> bool {
    mut result : bool = default
    __c__Selectable_2(^result, _label, _p_selected, _flags, ^mut *_size)
    return result
}
ListBox :: (_label: ^char8, _current_item: ^mut i32, _items: ^mut ^char8, _items_count: i32, _height_in_items: i32) -> bool {
    mut result : bool = default
    __c__ListBox(^result, _label, _current_item, _items, _items_count, _height_in_items)
    return result
}
ListBox_2 :: (_label: ^char8, _current_item: ^mut i32, _items_getter: fn(^mut void, i32, ^mut ^char8) -> bool, _data: ^mut void, _items_count: i32, _height_in_items: i32) -> bool {
    mut result : bool = default
    __c__ListBox_2(^result, _label, _current_item, _items_getter, _data, _items_count, _height_in_items)
    return result
}
ListBoxHeader :: (_label: ^char8, _size: &mut ImVec2) -> bool {
    mut result : bool = default
    __c__ListBoxHeader(^result, _label, ^mut *_size)
    return result
}
ListBoxHeader_2 :: (_label: ^char8, _items_count: i32, _height_in_items: i32) -> bool {
    mut result : bool = default
    __c__ListBoxHeader_2(^result, _label, _items_count, _height_in_items)
    return result
}
ListBoxFooter :: () {
    __c__ListBoxFooter()
}
PlotLines :: (_label: ^char8, _values: ^f32, _values_count: i32, _values_offset: i32, _overlay_text: ^char8, _scale_min: f32, _scale_max: f32, _graph_size: ImVec2, _stride: i32) {
    __c__PlotLines(_label, _values, _values_count, _values_offset, _overlay_text, _scale_min, _scale_max, ^mut _graph_size, _stride)
}
PlotLines_2 :: (_label: ^char8, _values_getter: fn(^mut void, i32) -> f32, _data: ^mut void, _values_count: i32, _values_offset: i32, _overlay_text: ^char8, _scale_min: f32, _scale_max: f32, _graph_size: ImVec2) {
    __c__PlotLines_2(_label, _values_getter, _data, _values_count, _values_offset, _overlay_text, _scale_min, _scale_max, ^mut _graph_size)
}
PlotHistogram :: (_label: ^char8, _values: ^f32, _values_count: i32, _values_offset: i32, _overlay_text: ^char8, _scale_min: f32, _scale_max: f32, _graph_size: ImVec2, _stride: i32) {
    __c__PlotHistogram(_label, _values, _values_count, _values_offset, _overlay_text, _scale_min, _scale_max, ^mut _graph_size, _stride)
}
PlotHistogram_2 :: (_label: ^char8, _values_getter: fn(^mut void, i32) -> f32, _data: ^mut void, _values_count: i32, _values_offset: i32, _overlay_text: ^char8, _scale_min: f32, _scale_max: f32, _graph_size: ImVec2) {
    __c__PlotHistogram_2(_label, _values_getter, _data, _values_count, _values_offset, _overlay_text, _scale_min, _scale_max, ^mut _graph_size)
}
Value :: (_prefix: ^char8, _b: bool) {
    __c__Value(_prefix, _b)
}
Value_2 :: (_prefix: ^char8, _v: i32) {
    __c__Value_2(_prefix, _v)
}
Value_3 :: (_prefix: ^char8, _v: u32) {
    __c__Value_3(_prefix, _v)
}
Value_4 :: (_prefix: ^char8, _v: f32, _float_format: ^char8) {
    __c__Value_4(_prefix, _v, _float_format)
}
BeginMenuBar :: () -> bool {
    mut result : bool = default
    __c__BeginMenuBar(^result)
    return result
}
EndMenuBar :: () {
    __c__EndMenuBar()
}
BeginMainMenuBar :: () -> bool {
    mut result : bool = default
    __c__BeginMainMenuBar(^result)
    return result
}
EndMainMenuBar :: () {
    __c__EndMainMenuBar()
}
BeginMenu :: (_label: ^char8, _enabled: bool) -> bool {
    mut result : bool = default
    __c__BeginMenu(^result, _label, _enabled)
    return result
}
EndMenu :: () {
    __c__EndMenu()
}
MenuItem :: (_label: ^char8, _shortcut: ^char8, _selected: bool, _enabled: bool) -> bool {
    mut result : bool = default
    __c__MenuItem(^result, _label, _shortcut, _selected, _enabled)
    return result
}
MenuItem_2 :: (_label: ^char8, _shortcut: ^char8, _p_selected: ^mut bool, _enabled: bool) -> bool {
    mut result : bool = default
    __c__MenuItem_2(^result, _label, _shortcut, _p_selected, _enabled)
    return result
}
BeginTooltip :: () {
    __c__BeginTooltip()
}
EndTooltip :: () {
    __c__EndTooltip()
}
SetTooltip :: (_fmt: ^char8) {
    __c__SetTooltip(_fmt)
}
SetTooltipV :: (_fmt: ^char8, _args: va_list) {
    __c__SetTooltipV(_fmt, _args)
}
BeginPopup :: (_str_id: ^char8, _flags: ImGuiWindowFlags) -> bool {
    mut result : bool = default
    __c__BeginPopup(^result, _str_id, _flags)
    return result
}
BeginPopupModal :: (_name: ^char8, _p_open: ^mut bool, _flags: ImGuiWindowFlags) -> bool {
    mut result : bool = default
    __c__BeginPopupModal(^result, _name, _p_open, _flags)
    return result
}
EndPopup :: () {
    __c__EndPopup()
}
OpenPopup :: (_str_id: ^char8, _popup_flags: ImGuiPopupFlags) {
    __c__OpenPopup(_str_id, _popup_flags)
}
OpenPopupContextItem :: (_str_id: ^char8, _popup_flags: ImGuiPopupFlags) -> bool {
    mut result : bool = default
    __c__OpenPopupContextItem(^result, _str_id, _popup_flags)
    return result
}
CloseCurrentPopup :: () {
    __c__CloseCurrentPopup()
}
BeginPopupContextItem :: (_str_id: ^char8, _popup_flags: ImGuiPopupFlags) -> bool {
    mut result : bool = default
    __c__BeginPopupContextItem(^result, _str_id, _popup_flags)
    return result
}
BeginPopupContextWindow :: (_str_id: ^char8, _popup_flags: ImGuiPopupFlags) -> bool {
    mut result : bool = default
    __c__BeginPopupContextWindow(^result, _str_id, _popup_flags)
    return result
}
BeginPopupContextVoid :: (_str_id: ^char8, _popup_flags: ImGuiPopupFlags) -> bool {
    mut result : bool = default
    __c__BeginPopupContextVoid(^result, _str_id, _popup_flags)
    return result
}
IsPopupOpen :: (_str_id: ^char8, _flags: ImGuiPopupFlags) -> bool {
    mut result : bool = default
    __c__IsPopupOpen(^result, _str_id, _flags)
    return result
}
Columns :: (_count: i32, _id: ^char8, _border: bool) {
    __c__Columns(_count, _id, _border)
}
NextColumn :: () {
    __c__NextColumn()
}
GetColumnIndex :: () -> i32 {
    mut result : i32 = default
    __c__GetColumnIndex(^result)
    return result
}
GetColumnWidth :: (_column_index: i32) -> f32 {
    mut result : f32 = default
    __c__GetColumnWidth(^result, _column_index)
    return result
}
SetColumnWidth :: (_column_index: i32, _width: f32) {
    __c__SetColumnWidth(_column_index, _width)
}
GetColumnOffset :: (_column_index: i32) -> f32 {
    mut result : f32 = default
    __c__GetColumnOffset(^result, _column_index)
    return result
}
SetColumnOffset :: (_column_index: i32, _offset_x: f32) {
    __c__SetColumnOffset(_column_index, _offset_x)
}
GetColumnsCount :: () -> i32 {
    mut result : i32 = default
    __c__GetColumnsCount(^result)
    return result
}
BeginTabBar :: (_str_id: ^char8, _flags: ImGuiTabBarFlags) -> bool {
    mut result : bool = default
    __c__BeginTabBar(^result, _str_id, _flags)
    return result
}
EndTabBar :: () {
    __c__EndTabBar()
}
BeginTabItem :: (_label: ^char8, _p_open: ^mut bool, _flags: ImGuiTabItemFlags) -> bool {
    mut result : bool = default
    __c__BeginTabItem(^result, _label, _p_open, _flags)
    return result
}
EndTabItem :: () {
    __c__EndTabItem()
}
SetTabItemClosed :: (_tab_or_docked_window_label: ^char8) {
    __c__SetTabItemClosed(_tab_or_docked_window_label)
}
DockSpace :: (_id: ImGuiID, _size: &mut ImVec2, _flags: ImGuiDockNodeFlags, _window_class: ^mut ImGuiWindowClass) {
    __c__DockSpace(_id, ^mut *_size, _flags, _window_class)
}
DockSpaceOverViewport :: (_viewport: ^mut ImGuiViewport, _flags: ImGuiDockNodeFlags, _window_class: ^mut ImGuiWindowClass) -> ImGuiID {
    mut result : ImGuiID = default
    __c__DockSpaceOverViewport(^result, _viewport, _flags, _window_class)
    return result
}
SetNextWindowDockID :: (_dock_id: ImGuiID, _cond: ImGuiCond) {
    __c__SetNextWindowDockID(_dock_id, _cond)
}
SetNextWindowClass :: (_window_class: ^mut ImGuiWindowClass) {
    __c__SetNextWindowClass(_window_class)
}
GetWindowDockID :: () -> ImGuiID {
    mut result : ImGuiID = default
    __c__GetWindowDockID(^result)
    return result
}
IsWindowDocked :: () -> bool {
    mut result : bool = default
    __c__IsWindowDocked(^result)
    return result
}
LogToTTY :: (_auto_open_depth: i32) {
    __c__LogToTTY(_auto_open_depth)
}
LogToFile :: (_auto_open_depth: i32, _filename: ^char8) {
    __c__LogToFile(_auto_open_depth, _filename)
}
LogToClipboard :: (_auto_open_depth: i32) {
    __c__LogToClipboard(_auto_open_depth)
}
LogFinish :: () {
    __c__LogFinish()
}
LogButtons :: () {
    __c__LogButtons()
}
LogText :: (_fmt: ^char8) {
    __c__LogText(_fmt)
}
BeginDragDropSource :: (_flags: ImGuiDragDropFlags) -> bool {
    mut result : bool = default
    __c__BeginDragDropSource(^result, _flags)
    return result
}
SetDragDropPayload :: (_type: ^char8, _data: ^mut void, _sz: size_t, _cond: ImGuiCond) -> bool {
    mut result : bool = default
    __c__SetDragDropPayload(^result, _type, _data, _sz, _cond)
    return result
}
EndDragDropSource :: () {
    __c__EndDragDropSource()
}
BeginDragDropTarget :: () -> bool {
    mut result : bool = default
    __c__BeginDragDropTarget(^result)
    return result
}
AcceptDragDropPayload :: (_type: ^char8, _flags: ImGuiDragDropFlags) -> ^mut ImGuiPayload {
    mut result : ^mut ImGuiPayload = default
    __c__AcceptDragDropPayload(^result, _type, _flags)
    return result
}
EndDragDropTarget :: () {
    __c__EndDragDropTarget()
}
GetDragDropPayload :: () -> ^mut ImGuiPayload {
    mut result : ^mut ImGuiPayload = default
    __c__GetDragDropPayload(^result)
    return result
}
PushClipRect :: (_clip_rect_min: &mut ImVec2, _clip_rect_max: &mut ImVec2, _intersect_with_current_clip_rect: bool) {
    __c__PushClipRect(^mut *_clip_rect_min, ^mut *_clip_rect_max, _intersect_with_current_clip_rect)
}
PopClipRect :: () {
    __c__PopClipRect()
}
SetItemDefaultFocus :: () {
    __c__SetItemDefaultFocus()
}
SetKeyboardFocusHere :: (_offset: i32) {
    __c__SetKeyboardFocusHere(_offset)
}
IsItemHovered :: (_flags: ImGuiHoveredFlags) -> bool {
    mut result : bool = default
    __c__IsItemHovered(^result, _flags)
    return result
}
IsItemActive :: () -> bool {
    mut result : bool = default
    __c__IsItemActive(^result)
    return result
}
IsItemFocused :: () -> bool {
    mut result : bool = default
    __c__IsItemFocused(^result)
    return result
}
IsItemClicked :: (_mouse_button: ImGuiMouseButton) -> bool {
    mut result : bool = default
    __c__IsItemClicked(^result, _mouse_button)
    return result
}
IsItemVisible :: () -> bool {
    mut result : bool = default
    __c__IsItemVisible(^result)
    return result
}
IsItemEdited :: () -> bool {
    mut result : bool = default
    __c__IsItemEdited(^result)
    return result
}
IsItemActivated :: () -> bool {
    mut result : bool = default
    __c__IsItemActivated(^result)
    return result
}
IsItemDeactivated :: () -> bool {
    mut result : bool = default
    __c__IsItemDeactivated(^result)
    return result
}
IsItemDeactivatedAfterEdit :: () -> bool {
    mut result : bool = default
    __c__IsItemDeactivatedAfterEdit(^result)
    return result
}
IsItemToggledOpen :: () -> bool {
    mut result : bool = default
    __c__IsItemToggledOpen(^result)
    return result
}
IsAnyItemHovered :: () -> bool {
    mut result : bool = default
    __c__IsAnyItemHovered(^result)
    return result
}
IsAnyItemActive :: () -> bool {
    mut result : bool = default
    __c__IsAnyItemActive(^result)
    return result
}
IsAnyItemFocused :: () -> bool {
    mut result : bool = default
    __c__IsAnyItemFocused(^result)
    return result
}
GetItemRectMin :: () -> ImVec2 {
    mut result : ImVec2 = default
    __c__GetItemRectMin(^result)
    return result
}
GetItemRectMax :: () -> ImVec2 {
    mut result : ImVec2 = default
    __c__GetItemRectMax(^result)
    return result
}
GetItemRectSize :: () -> ImVec2 {
    mut result : ImVec2 = default
    __c__GetItemRectSize(^result)
    return result
}
SetItemAllowOverlap :: () {
    __c__SetItemAllowOverlap()
}
IsRectVisible :: (_size: &mut ImVec2) -> bool {
    mut result : bool = default
    __c__IsRectVisible(^result, ^mut *_size)
    return result
}
IsRectVisible_2 :: (_rect_min: &mut ImVec2, _rect_max: &mut ImVec2) -> bool {
    mut result : bool = default
    __c__IsRectVisible_2(^result, ^mut *_rect_min, ^mut *_rect_max)
    return result
}
GetTime :: () -> f64 {
    mut result : f64 = default
    __c__GetTime(^result)
    return result
}
GetFrameCount :: () -> i32 {
    mut result : i32 = default
    __c__GetFrameCount(^result)
    return result
}
GetBackgroundDrawList :: () -> ^mut ImDrawList {
    mut result : ^mut ImDrawList = default
    __c__GetBackgroundDrawList(^result)
    return result
}
GetForegroundDrawList :: () -> ^mut ImDrawList {
    mut result : ^mut ImDrawList = default
    __c__GetForegroundDrawList(^result)
    return result
}
GetBackgroundDrawList_2 :: (_viewport: ^mut ImGuiViewport) -> ^mut ImDrawList {
    mut result : ^mut ImDrawList = default
    __c__GetBackgroundDrawList_2(^result, _viewport)
    return result
}
GetForegroundDrawList_2 :: (_viewport: ^mut ImGuiViewport) -> ^mut ImDrawList {
    mut result : ^mut ImDrawList = default
    __c__GetForegroundDrawList_2(^result, _viewport)
    return result
}
GetDrawListSharedData :: () -> ^mut ImDrawListSharedData {
    mut result : ^mut ImDrawListSharedData = default
    __c__GetDrawListSharedData(^result)
    return result
}
GetStyleColorName :: (_idx: ImGuiCol) -> ^char8 {
    mut result : ^char8 = default
    __c__GetStyleColorName(^result, _idx)
    return result
}
SetStateStorage :: (_storage: ^mut ImGuiStorage) {
    __c__SetStateStorage(_storage)
}
GetStateStorage :: () -> ^mut ImGuiStorage {
    mut result : ^mut ImGuiStorage = default
    __c__GetStateStorage(^result)
    return result
}
CalcListClipping :: (_items_count: i32, _items_height: f32, _out_items_display_start: ^mut i32, _out_items_display_end: ^mut i32) {
    __c__CalcListClipping(_items_count, _items_height, _out_items_display_start, _out_items_display_end)
}
BeginChildFrame :: (_id: ImGuiID, _size: &mut ImVec2, _flags: ImGuiWindowFlags) -> bool {
    mut result : bool = default
    __c__BeginChildFrame(^result, _id, ^mut *_size, _flags)
    return result
}
EndChildFrame :: () {
    __c__EndChildFrame()
}
CalcTextSize :: (_text: ^char8, _text_end: ^char8, _hide_text_after_double_hash: bool, _wrap_width: f32) -> ImVec2 {
    mut result : ImVec2 = default
    __c__CalcTextSize(^result, _text, _text_end, _hide_text_after_double_hash, _wrap_width)
    return result
}
ColorConvertU32ToFloat4 :: (_in: ImU32) -> ImVec4 {
    mut result : ImVec4 = default
    __c__ColorConvertU32ToFloat4(^result, _in)
    return result
}
ColorConvertFloat4ToU32 :: (_in: &mut ImVec4) -> ImU32 {
    mut result : ImU32 = default
    __c__ColorConvertFloat4ToU32(^result, ^mut *_in)
    return result
}
ColorConvertRGBtoHSV :: (_r: f32, _g: f32, _b: f32, _out_h: &mut f32, _out_s: &mut f32, _out_v: &mut f32) {
    __c__ColorConvertRGBtoHSV(_r, _g, _b, ^mut *_out_h, ^mut *_out_s, ^mut *_out_v)
}
ColorConvertHSVtoRGB :: (_h: f32, _s: f32, _v: f32, _out_r: &mut f32, _out_g: &mut f32, _out_b: &mut f32) {
    __c__ColorConvertHSVtoRGB(_h, _s, _v, ^mut *_out_r, ^mut *_out_g, ^mut *_out_b)
}
GetKeyIndex :: (_imgui_key: ImGuiKey) -> i32 {
    mut result : i32 = default
    __c__GetKeyIndex(^result, _imgui_key)
    return result
}
IsKeyDown :: (_user_key_index: i32) -> bool {
    mut result : bool = default
    __c__IsKeyDown(^result, _user_key_index)
    return result
}
IsKeyPressed :: (_user_key_index: i32, _repeat: bool) -> bool {
    mut result : bool = default
    __c__IsKeyPressed(^result, _user_key_index, _repeat)
    return result
}
IsKeyReleased :: (_user_key_index: i32) -> bool {
    mut result : bool = default
    __c__IsKeyReleased(^result, _user_key_index)
    return result
}
GetKeyPressedAmount :: (_key_index: i32, _repeat_delay: f32, _rate: f32) -> i32 {
    mut result : i32 = default
    __c__GetKeyPressedAmount(^result, _key_index, _repeat_delay, _rate)
    return result
}
CaptureKeyboardFromApp :: (_want_capture_keyboard_value: bool) {
    __c__CaptureKeyboardFromApp(_want_capture_keyboard_value)
}
IsMouseDown :: (_button: ImGuiMouseButton) -> bool {
    mut result : bool = default
    __c__IsMouseDown(^result, _button)
    return result
}
IsMouseClicked :: (_button: ImGuiMouseButton, _repeat: bool) -> bool {
    mut result : bool = default
    __c__IsMouseClicked(^result, _button, _repeat)
    return result
}
IsMouseReleased :: (_button: ImGuiMouseButton) -> bool {
    mut result : bool = default
    __c__IsMouseReleased(^result, _button)
    return result
}
IsMouseDoubleClicked :: (_button: ImGuiMouseButton) -> bool {
    mut result : bool = default
    __c__IsMouseDoubleClicked(^result, _button)
    return result
}
IsMouseHoveringRect :: (_r_min: &mut ImVec2, _r_max: &mut ImVec2, _clip: bool) -> bool {
    mut result : bool = default
    __c__IsMouseHoveringRect(^result, ^mut *_r_min, ^mut *_r_max, _clip)
    return result
}
IsMousePosValid :: (_mouse_pos: ^mut ImVec2) -> bool {
    mut result : bool = default
    __c__IsMousePosValid(^result, _mouse_pos)
    return result
}
IsAnyMouseDown :: () -> bool {
    mut result : bool = default
    __c__IsAnyMouseDown(^result)
    return result
}
GetMousePos :: () -> ImVec2 {
    mut result : ImVec2 = default
    __c__GetMousePos(^result)
    return result
}
GetMousePosOnOpeningCurrentPopup :: () -> ImVec2 {
    mut result : ImVec2 = default
    __c__GetMousePosOnOpeningCurrentPopup(^result)
    return result
}
IsMouseDragging :: (_button: ImGuiMouseButton, _lock_threshold: f32) -> bool {
    mut result : bool = default
    __c__IsMouseDragging(^result, _button, _lock_threshold)
    return result
}
GetMouseDragDelta :: (_button: ImGuiMouseButton, _lock_threshold: f32) -> ImVec2 {
    mut result : ImVec2 = default
    __c__GetMouseDragDelta(^result, _button, _lock_threshold)
    return result
}
ResetMouseDragDelta :: (_button: ImGuiMouseButton) {
    __c__ResetMouseDragDelta(_button)
}
GetMouseCursor :: () -> ImGuiMouseCursor {
    mut result : ImGuiMouseCursor = default
    __c__GetMouseCursor(^result)
    return result
}
SetMouseCursor :: (_cursor_type: ImGuiMouseCursor) {
    __c__SetMouseCursor(_cursor_type)
}
CaptureMouseFromApp :: (_want_capture_mouse_value: bool) {
    __c__CaptureMouseFromApp(_want_capture_mouse_value)
}
GetClipboardText :: () -> ^char8 {
    mut result : ^char8 = default
    __c__GetClipboardText(^result)
    return result
}
SetClipboardText :: (_text: ^char8) {
    __c__SetClipboardText(_text)
}
LoadIniSettingsFromDisk :: (_ini_filename: ^char8) {
    __c__LoadIniSettingsFromDisk(_ini_filename)
}
LoadIniSettingsFromMemory :: (_ini_data: ^char8, _ini_size: size_t) {
    __c__LoadIniSettingsFromMemory(_ini_data, _ini_size)
}
SaveIniSettingsToDisk :: (_ini_filename: ^char8) {
    __c__SaveIniSettingsToDisk(_ini_filename)
}
SaveIniSettingsToMemory :: (_out_ini_size: ^mut size_t) -> ^char8 {
    mut result : ^char8 = default
    __c__SaveIniSettingsToMemory(^result, _out_ini_size)
    return result
}
DebugCheckVersionAndDataLayout :: (_version_str: ^char8, _sz_io: size_t, _sz_style: size_t, _sz_vec2: size_t, _sz_vec4: size_t, _sz_drawvert: size_t, _sz_drawidx: size_t) -> bool {
    mut result : bool = default
    __c__DebugCheckVersionAndDataLayout(^result, _version_str, _sz_io, _sz_style, _sz_vec2, _sz_vec4, _sz_drawvert, _sz_drawidx)
    return result
}
SetAllocatorFunctions :: (_alloc_func: fn(size_t, ^mut void) -> ^mut void, _free_func: fn(^mut void, ^mut void) -> void, _user_data: ^mut void) {
    __c__SetAllocatorFunctions(_alloc_func, _free_func, _user_data)
}
MemAlloc :: (_size: size_t) -> ^mut void {
    mut result : ^mut void = default
    __c__MemAlloc(^result, _size)
    return result
}
MemFree :: (_ptr: ^mut void) {
    __c__MemFree(_ptr)
}
GetPlatformIO :: () -> &mut ImGuiPlatformIO {
    mut result : ^mut ImGuiPlatformIO = default
    __c__GetPlatformIO(^result)
    return &mut *result
}
GetMainViewport :: () -> ^mut ImGuiViewport {
    mut result : ^mut ImGuiViewport = default
    __c__GetMainViewport(^result)
    return result
}
UpdatePlatformWindows :: () {
    __c__UpdatePlatformWindows()
}
RenderPlatformWindowsDefault :: (_platform_render_arg: ^mut void, _renderer_render_arg: ^mut void) {
    __c__RenderPlatformWindowsDefault(_platform_render_arg, _renderer_render_arg)
}
DestroyPlatformWindows :: () {
    __c__DestroyPlatformWindows()
}
FindViewportByID :: (_id: ImGuiID) -> ^mut ImGuiViewport {
    mut result : ^mut ImGuiViewport = default
    __c__FindViewportByID(^result, _id)
    return result
}
FindViewportByPlatformHandle :: (_platform_handle: ^mut void) -> ^mut ImGuiViewport {
    mut result : ^mut ImGuiViewport = default
    __c__FindViewportByPlatformHandle(^result, _platform_handle)
    return result
}
DragScalar_2 :: (_label: ^char8, _data_type: ImGuiDataType, _p_data: ^mut void, _v_speed: f32, _p_min: ^mut void, _p_max: ^mut void, _format: ^char8, _power: f32) -> bool {
    mut result : bool = default
    __c__DragScalar_2(^result, _label, _data_type, _p_data, _v_speed, _p_min, _p_max, _format, _power)
    return result
}
DragScalarN_2 :: (_label: ^char8, _data_type: ImGuiDataType, _p_data: ^mut void, _components: i32, _v_speed: f32, _p_min: ^mut void, _p_max: ^mut void, _format: ^char8, _power: f32) -> bool {
    mut result : bool = default
    __c__DragScalarN_2(^result, _label, _data_type, _p_data, _components, _v_speed, _p_min, _p_max, _format, _power)
    return result
}
SliderScalar_2 :: (_label: ^char8, _data_type: ImGuiDataType, _p_data: ^mut void, _p_min: ^mut void, _p_max: ^mut void, _format: ^char8, _power: f32) -> bool {
    mut result : bool = default
    __c__SliderScalar_2(^result, _label, _data_type, _p_data, _p_min, _p_max, _format, _power)
    return result
}
SliderScalarN_2 :: (_label: ^char8, _data_type: ImGuiDataType, _p_data: ^mut void, _components: i32, _p_min: ^mut void, _p_max: ^mut void, _format: ^char8, _power: f32) -> bool {
    mut result : bool = default
    __c__SliderScalarN_2(^result, _label, _data_type, _p_data, _components, _p_min, _p_max, _format, _power)
    return result
}
InputFloat_2 :: (_label: ^char8, _v: ^mut f32, _step: f32, _step_fast: f32, _decimal_precision: i32, _flags: ImGuiInputTextFlags) -> bool {
    mut result : bool = default
    __c__InputFloat_2(^result, _label, _v, _step, _step_fast, _decimal_precision, _flags)
    return result
}
InputFloat2_2 :: (_label: ^char8, _v: ^mut f32, _decimal_precision: i32, _flags: ImGuiInputTextFlags) -> bool {
    mut result : bool = default
    __c__InputFloat2_2(^result, _label, _v, _decimal_precision, _flags)
    return result
}
InputFloat3_2 :: (_label: ^char8, _v: ^mut f32, _decimal_precision: i32, _flags: ImGuiInputTextFlags) -> bool {
    mut result : bool = default
    __c__InputFloat3_2(^result, _label, _v, _decimal_precision, _flags)
    return result
}
InputFloat4_2 :: (_label: ^char8, _v: ^mut f32, _decimal_precision: i32, _flags: ImGuiInputTextFlags) -> bool {
    mut result : bool = default
    __c__InputFloat4_2(^result, _label, _v, _decimal_precision, _flags)
    return result
}
ImHashData :: (_data: ^mut void, _data_size: size_t, _seed: ImU32) -> ImU32 {
    mut result : ImU32 = default
    __c__ImHashData(^result, _data, _data_size, _seed)
    return result
}
ImHashStr :: (_data: ^char8, _data_size: size_t, _seed: ImU32) -> ImU32 {
    mut result : ImU32 = default
    __c__ImHashStr(^result, _data, _data_size, _seed)
    return result
}
ImAlphaBlendColors :: (_col_a: ImU32, _col_b: ImU32) -> ImU32 {
    mut result : ImU32 = default
    __c__ImAlphaBlendColors(^result, _col_a, _col_b)
    return result
}
ImStricmp :: (_str1: ^char8, _str2: ^char8) -> i32 {
    mut result : i32 = default
    __c__ImStricmp(^result, _str1, _str2)
    return result
}
ImStrnicmp :: (_str1: ^char8, _str2: ^char8, _count: size_t) -> i32 {
    mut result : i32 = default
    __c__ImStrnicmp(^result, _str1, _str2, _count)
    return result
}
ImStrncpy :: (_dst: ^mut char8, _src: ^char8, _count: size_t) {
    __c__ImStrncpy(_dst, _src, _count)
}
ImStrdup :: (_str: ^char8) -> ^mut char8 {
    mut result : ^mut char8 = default
    __c__ImStrdup(^result, _str)
    return result
}
ImStrdupcpy :: (_dst: ^mut char8, _p_dst_size: ^mut size_t, _str: ^char8) -> ^mut char8 {
    mut result : ^mut char8 = default
    __c__ImStrdupcpy(^result, _dst, _p_dst_size, _str)
    return result
}
ImStrchrRange :: (_str_begin: ^char8, _str_end: ^char8, _c: char8) -> ^char8 {
    mut result : ^char8 = default
    __c__ImStrchrRange(^result, _str_begin, _str_end, _c)
    return result
}
ImStrlenW :: (_str: ^mut ImWchar) -> i32 {
    mut result : i32 = default
    __c__ImStrlenW(^result, _str)
    return result
}
ImStreolRange :: (_str: ^char8, _str_end: ^char8) -> ^char8 {
    mut result : ^char8 = default
    __c__ImStreolRange(^result, _str, _str_end)
    return result
}
ImStrbolW :: (_buf_mid_line: ^mut ImWchar, _buf_begin: ^mut ImWchar) -> ^mut ImWchar {
    mut result : ^mut ImWchar = default
    __c__ImStrbolW(^result, _buf_mid_line, _buf_begin)
    return result
}
ImStristr :: (_haystack: ^char8, _haystack_end: ^char8, _needle: ^char8, _needle_end: ^char8) -> ^char8 {
    mut result : ^char8 = default
    __c__ImStristr(^result, _haystack, _haystack_end, _needle, _needle_end)
    return result
}
ImStrTrimBlanks :: (_str: ^mut char8) {
    __c__ImStrTrimBlanks(_str)
}
ImStrSkipBlank :: (_str: ^char8) -> ^char8 {
    mut result : ^char8 = default
    __c__ImStrSkipBlank(^result, _str)
    return result
}
ImFormatString :: (_buf: ^mut char8, _buf_size: size_t, _fmt: ^char8) -> i32 {
    mut result : i32 = default
    __c__ImFormatString(^result, _buf, _buf_size, _fmt)
    return result
}
ImFormatStringV :: (_buf: ^mut char8, _buf_size: size_t, _fmt: ^char8, _args: va_list) -> i32 {
    mut result : i32 = default
    __c__ImFormatStringV(^result, _buf, _buf_size, _fmt, _args)
    return result
}
ImParseFormatFindStart :: (_format: ^char8) -> ^char8 {
    mut result : ^char8 = default
    __c__ImParseFormatFindStart(^result, _format)
    return result
}
ImParseFormatFindEnd :: (_format: ^char8) -> ^char8 {
    mut result : ^char8 = default
    __c__ImParseFormatFindEnd(^result, _format)
    return result
}
ImParseFormatTrimDecorations :: (_format: ^char8, _buf: ^mut char8, _buf_size: size_t) -> ^char8 {
    mut result : ^char8 = default
    __c__ImParseFormatTrimDecorations(^result, _format, _buf, _buf_size)
    return result
}
ImParseFormatPrecision :: (_format: ^char8, _default_value: i32) -> i32 {
    mut result : i32 = default
    __c__ImParseFormatPrecision(^result, _format, _default_value)
    return result
}
ImTextStrToUtf8 :: (_buf: ^mut char8, _buf_size: i32, _in_text: ^mut ImWchar, _in_text_end: ^mut ImWchar) -> i32 {
    mut result : i32 = default
    __c__ImTextStrToUtf8(^result, _buf, _buf_size, _in_text, _in_text_end)
    return result
}
ImTextCharFromUtf8 :: (_out_char: ^mut u32, _in_text: ^char8, _in_text_end: ^char8) -> i32 {
    mut result : i32 = default
    __c__ImTextCharFromUtf8(^result, _out_char, _in_text, _in_text_end)
    return result
}
ImTextStrFromUtf8 :: (_buf: ^mut ImWchar, _buf_size: i32, _in_text: ^char8, _in_text_end: ^char8, _in_remaining: ^mut ^char8) -> i32 {
    mut result : i32 = default
    __c__ImTextStrFromUtf8(^result, _buf, _buf_size, _in_text, _in_text_end, _in_remaining)
    return result
}
ImTextCountCharsFromUtf8 :: (_in_text: ^char8, _in_text_end: ^char8) -> i32 {
    mut result : i32 = default
    __c__ImTextCountCharsFromUtf8(^result, _in_text, _in_text_end)
    return result
}
ImTextCountUtf8BytesFromChar :: (_in_text: ^char8, _in_text_end: ^char8) -> i32 {
    mut result : i32 = default
    __c__ImTextCountUtf8BytesFromChar(^result, _in_text, _in_text_end)
    return result
}
ImTextCountUtf8BytesFromStr :: (_in_text: ^mut ImWchar, _in_text_end: ^mut ImWchar) -> i32 {
    mut result : i32 = default
    __c__ImTextCountUtf8BytesFromStr(^result, _in_text, _in_text_end)
    return result
}
ImFileOpen :: (_filename: ^char8, _mode: ^char8) -> ImFileHandle {
    mut result : ImFileHandle = default
    __c__ImFileOpen(^result, _filename, _mode)
    return result
}
ImFileClose :: (_file: ImFileHandle) -> bool {
    mut result : bool = default
    __c__ImFileClose(^result, _file)
    return result
}
ImFileGetSize :: (_file: ImFileHandle) -> ImU64 {
    mut result : ImU64 = default
    __c__ImFileGetSize(^result, _file)
    return result
}
ImFileRead :: (_data: ^mut void, _size: ImU64, _count: ImU64, _file: ImFileHandle) -> ImU64 {
    mut result : ImU64 = default
    __c__ImFileRead(^result, _data, _size, _count, _file)
    return result
}
ImFileWrite :: (_data: ^mut void, _size: ImU64, _count: ImU64, _file: ImFileHandle) -> ImU64 {
    mut result : ImU64 = default
    __c__ImFileWrite(^result, _data, _size, _count, _file)
    return result
}
ImFileLoadToMemory :: (_filename: ^char8, _mode: ^char8, _out_file_size: ^mut size_t, _padding_bytes: i32) -> ^mut void {
    mut result : ^mut void = default
    __c__ImFileLoadToMemory(^result, _filename, _mode, _out_file_size, _padding_bytes)
    return result
}
ImBezierCalc :: (_p1: &mut ImVec2, _p2: &mut ImVec2, _p3: &mut ImVec2, _p4: &mut ImVec2, _t: f32) -> ImVec2 {
    mut result : ImVec2 = default
    __c__ImBezierCalc(^result, ^mut *_p1, ^mut *_p2, ^mut *_p3, ^mut *_p4, _t)
    return result
}
ImBezierClosestPoint :: (_p1: &mut ImVec2, _p2: &mut ImVec2, _p3: &mut ImVec2, _p4: &mut ImVec2, _p: &mut ImVec2, _num_segments: i32) -> ImVec2 {
    mut result : ImVec2 = default
    __c__ImBezierClosestPoint(^result, ^mut *_p1, ^mut *_p2, ^mut *_p3, ^mut *_p4, ^mut *_p, _num_segments)
    return result
}
ImBezierClosestPointCasteljau :: (_p1: &mut ImVec2, _p2: &mut ImVec2, _p3: &mut ImVec2, _p4: &mut ImVec2, _p: &mut ImVec2, _tess_tol: f32) -> ImVec2 {
    mut result : ImVec2 = default
    __c__ImBezierClosestPointCasteljau(^result, ^mut *_p1, ^mut *_p2, ^mut *_p3, ^mut *_p4, ^mut *_p, _tess_tol)
    return result
}
ImLineClosestPoint :: (_a: &mut ImVec2, _b: &mut ImVec2, _p: &mut ImVec2) -> ImVec2 {
    mut result : ImVec2 = default
    __c__ImLineClosestPoint(^result, ^mut *_a, ^mut *_b, ^mut *_p)
    return result
}
ImTriangleContainsPoint :: (_a: &mut ImVec2, _b: &mut ImVec2, _c: &mut ImVec2, _p: &mut ImVec2) -> bool {
    mut result : bool = default
    __c__ImTriangleContainsPoint(^result, ^mut *_a, ^mut *_b, ^mut *_c, ^mut *_p)
    return result
}
ImTriangleClosestPoint :: (_a: &mut ImVec2, _b: &mut ImVec2, _c: &mut ImVec2, _p: &mut ImVec2) -> ImVec2 {
    mut result : ImVec2 = default
    __c__ImTriangleClosestPoint(^result, ^mut *_a, ^mut *_b, ^mut *_c, ^mut *_p)
    return result
}
ImTriangleBarycentricCoords :: (_a: &mut ImVec2, _b: &mut ImVec2, _c: &mut ImVec2, _p: &mut ImVec2, _out_u: &mut f32, _out_v: &mut f32, _out_w: &mut f32) {
    __c__ImTriangleBarycentricCoords(^mut *_a, ^mut *_b, ^mut *_c, ^mut *_p, ^mut *_out_u, ^mut *_out_v, ^mut *_out_w)
}
ImGetDirQuadrantFromDelta :: (_dx: f32, _dy: f32) -> ImGuiDir {
    mut result : ImGuiDir = default
    __c__ImGetDirQuadrantFromDelta(^result, _dx, _dy)
    return result
}
FindWindowByID :: (_id: ImGuiID) -> ^mut ImGuiWindow {
    mut result : ^mut ImGuiWindow = default
    __c__FindWindowByID(^result, _id)
    return result
}
FindWindowByName :: (_name: ^char8) -> ^mut ImGuiWindow {
    mut result : ^mut ImGuiWindow = default
    __c__FindWindowByName(^result, _name)
    return result
}
UpdateWindowParentAndRootLinks :: (_window: ^mut ImGuiWindow, _flags: ImGuiWindowFlags, _parent_window: ^mut ImGuiWindow) {
    __c__UpdateWindowParentAndRootLinks(_window, _flags, _parent_window)
}
CalcWindowExpectedSize :: (_window: ^mut ImGuiWindow) -> ImVec2 {
    mut result : ImVec2 = default
    __c__CalcWindowExpectedSize(^result, _window)
    return result
}
IsWindowChildOf :: (_window: ^mut ImGuiWindow, _potential_parent: ^mut ImGuiWindow) -> bool {
    mut result : bool = default
    __c__IsWindowChildOf(^result, _window, _potential_parent)
    return result
}
IsWindowNavFocusable :: (_window: ^mut ImGuiWindow) -> bool {
    mut result : bool = default
    __c__IsWindowNavFocusable(^result, _window)
    return result
}
GetWindowAllowedExtentRect :: (_window: ^mut ImGuiWindow) -> ImRect {
    mut result : ImRect = default
    __c__GetWindowAllowedExtentRect(^result, _window)
    return result
}
SetWindowPos_3 :: (_window: ^mut ImGuiWindow, _pos: &mut ImVec2, _cond: ImGuiCond) {
    __c__SetWindowPos_3(_window, ^mut *_pos, _cond)
}
SetWindowSize_3 :: (_window: ^mut ImGuiWindow, _size: &mut ImVec2, _cond: ImGuiCond) {
    __c__SetWindowSize_3(_window, ^mut *_size, _cond)
}
SetWindowCollapsed_3 :: (_window: ^mut ImGuiWindow, _collapsed: bool, _cond: ImGuiCond) {
    __c__SetWindowCollapsed_3(_window, _collapsed, _cond)
}
SetWindowHitTestHole :: (_window: ^mut ImGuiWindow, _pos: &mut ImVec2, _size: &mut ImVec2) {
    __c__SetWindowHitTestHole(_window, ^mut *_pos, ^mut *_size)
}
FocusWindow :: (_window: ^mut ImGuiWindow) {
    __c__FocusWindow(_window)
}
FocusTopMostWindowUnderOne :: (_under_this_window: ^mut ImGuiWindow, _ignore_window: ^mut ImGuiWindow) {
    __c__FocusTopMostWindowUnderOne(_under_this_window, _ignore_window)
}
BringWindowToFocusFront :: (_window: ^mut ImGuiWindow) {
    __c__BringWindowToFocusFront(_window)
}
BringWindowToDisplayFront :: (_window: ^mut ImGuiWindow) {
    __c__BringWindowToDisplayFront(_window)
}
BringWindowToDisplayBack :: (_window: ^mut ImGuiWindow) {
    __c__BringWindowToDisplayBack(_window)
}
SetCurrentFont :: (_font: ^mut ImFont) {
    __c__SetCurrentFont(_font)
}
Initialize :: (_context: ^mut ImGuiContext) {
    __c__Initialize(_context)
}
Shutdown :: (_context: ^mut ImGuiContext) {
    __c__Shutdown(_context)
}
UpdateHoveredWindowAndCaptureFlags :: () {
    __c__UpdateHoveredWindowAndCaptureFlags()
}
StartMouseMovingWindow :: (_window: ^mut ImGuiWindow) {
    __c__StartMouseMovingWindow(_window)
}
StartMouseMovingWindowOrNode :: (_window: ^mut ImGuiWindow, _node: ^mut ImGuiDockNode, _undock_floating_node: bool) {
    __c__StartMouseMovingWindowOrNode(_window, _node, _undock_floating_node)
}
UpdateMouseMovingWindowNewFrame :: () {
    __c__UpdateMouseMovingWindowNewFrame()
}
UpdateMouseMovingWindowEndFrame :: () {
    __c__UpdateMouseMovingWindowEndFrame()
}
TranslateWindowsInViewport :: (_viewport: ^mut ImGuiViewportP, _old_pos: &mut ImVec2, _new_pos: &mut ImVec2) {
    __c__TranslateWindowsInViewport(_viewport, ^mut *_old_pos, ^mut *_new_pos)
}
ScaleWindowsInViewport :: (_viewport: ^mut ImGuiViewportP, _scale: f32) {
    __c__ScaleWindowsInViewport(_viewport, _scale)
}
DestroyPlatformWindow :: (_viewport: ^mut ImGuiViewportP) {
    __c__DestroyPlatformWindow(_viewport)
}
ShowViewportThumbnails :: () {
    __c__ShowViewportThumbnails()
}
MarkIniSettingsDirty :: () {
    __c__MarkIniSettingsDirty()
}
MarkIniSettingsDirty_2 :: (_window: ^mut ImGuiWindow) {
    __c__MarkIniSettingsDirty_2(_window)
}
ClearIniSettings :: () {
    __c__ClearIniSettings()
}
CreateNewWindowSettings :: (_name: ^char8) -> ^mut ImGuiWindowSettings {
    mut result : ^mut ImGuiWindowSettings = default
    __c__CreateNewWindowSettings(^result, _name)
    return result
}
FindWindowSettings :: (_id: ImGuiID) -> ^mut ImGuiWindowSettings {
    mut result : ^mut ImGuiWindowSettings = default
    __c__FindWindowSettings(^result, _id)
    return result
}
FindOrCreateWindowSettings :: (_name: ^char8) -> ^mut ImGuiWindowSettings {
    mut result : ^mut ImGuiWindowSettings = default
    __c__FindOrCreateWindowSettings(^result, _name)
    return result
}
FindSettingsHandler :: (_type_name: ^char8) -> ^mut ImGuiSettingsHandler {
    mut result : ^mut ImGuiSettingsHandler = default
    __c__FindSettingsHandler(^result, _type_name)
    return result
}
SetNextWindowScroll :: (_scroll: &mut ImVec2) {
    __c__SetNextWindowScroll(^mut *_scroll)
}
SetScrollX_2 :: (_window: ^mut ImGuiWindow, _scroll_x: f32) {
    __c__SetScrollX_2(_window, _scroll_x)
}
SetScrollY_2 :: (_window: ^mut ImGuiWindow, _scroll_y: f32) {
    __c__SetScrollY_2(_window, _scroll_y)
}
SetScrollFromPosX_2 :: (_window: ^mut ImGuiWindow, _local_x: f32, _center_x_ratio: f32) {
    __c__SetScrollFromPosX_2(_window, _local_x, _center_x_ratio)
}
SetScrollFromPosY_2 :: (_window: ^mut ImGuiWindow, _local_y: f32, _center_y_ratio: f32) {
    __c__SetScrollFromPosY_2(_window, _local_y, _center_y_ratio)
}
ScrollToBringRectIntoView :: (_window: ^mut ImGuiWindow, _item_rect: &mut ImRect) -> ImVec2 {
    mut result : ImVec2 = default
    __c__ScrollToBringRectIntoView(^result, _window, ^mut *_item_rect)
    return result
}
SetActiveID :: (_id: ImGuiID, _window: ^mut ImGuiWindow) {
    __c__SetActiveID(_id, _window)
}
SetFocusID :: (_id: ImGuiID, _window: ^mut ImGuiWindow) {
    __c__SetFocusID(_id, _window)
}
ClearActiveID :: () {
    __c__ClearActiveID()
}
GetHoveredID :: () -> ImGuiID {
    mut result : ImGuiID = default
    __c__GetHoveredID(^result)
    return result
}
SetHoveredID :: (_id: ImGuiID) {
    __c__SetHoveredID(_id)
}
KeepAliveID :: (_id: ImGuiID) {
    __c__KeepAliveID(_id)
}
MarkItemEdited :: (_id: ImGuiID) {
    __c__MarkItemEdited(_id)
}
PushOverrideID :: (_id: ImGuiID) {
    __c__PushOverrideID(_id)
}
ItemSize :: (_size: &mut ImVec2, _text_baseline_y: f32) {
    __c__ItemSize(^mut *_size, _text_baseline_y)
}
ItemSize_2 :: (_bb: &mut ImRect, _text_baseline_y: f32) {
    __c__ItemSize_2(^mut *_bb, _text_baseline_y)
}
ItemAdd :: (_bb: &mut ImRect, _id: ImGuiID, _nav_bb: ^mut ImRect) -> bool {
    mut result : bool = default
    __c__ItemAdd(^result, ^mut *_bb, _id, _nav_bb)
    return result
}
ItemHoverable :: (_bb: &mut ImRect, _id: ImGuiID) -> bool {
    mut result : bool = default
    __c__ItemHoverable(^result, ^mut *_bb, _id)
    return result
}
IsClippedEx :: (_bb: &mut ImRect, _id: ImGuiID, _clip_even_when_logged: bool) -> bool {
    mut result : bool = default
    __c__IsClippedEx(^result, ^mut *_bb, _id, _clip_even_when_logged)
    return result
}
SetLastItemData :: (_window: ^mut ImGuiWindow, _item_id: ImGuiID, _status_flags: ImGuiItemStatusFlags, _item_rect: &mut ImRect) {
    __c__SetLastItemData(_window, _item_id, _status_flags, ^mut *_item_rect)
}
FocusableItemRegister :: (_window: ^mut ImGuiWindow, _id: ImGuiID) -> bool {
    mut result : bool = default
    __c__FocusableItemRegister(^result, _window, _id)
    return result
}
FocusableItemUnregister :: (_window: ^mut ImGuiWindow) {
    __c__FocusableItemUnregister(_window)
}
CalcItemSize :: (_size: ImVec2, _default_w: f32, _default_h: f32) -> ImVec2 {
    mut result : ImVec2 = default
    __c__CalcItemSize(^result, ^mut _size, _default_w, _default_h)
    return result
}
CalcWrapWidthForPos :: (_pos: &mut ImVec2, _wrap_pos_x: f32) -> f32 {
    mut result : f32 = default
    __c__CalcWrapWidthForPos(^result, ^mut *_pos, _wrap_pos_x)
    return result
}
PushMultiItemsWidths :: (_components: i32, _width_full: f32) {
    __c__PushMultiItemsWidths(_components, _width_full)
}
PushItemFlag :: (_option: ImGuiItemFlags, _enabled: bool) {
    __c__PushItemFlag(_option, _enabled)
}
PopItemFlag :: () {
    __c__PopItemFlag()
}
IsItemToggledSelection :: () -> bool {
    mut result : bool = default
    __c__IsItemToggledSelection(^result)
    return result
}
GetContentRegionMaxAbs :: () -> ImVec2 {
    mut result : ImVec2 = default
    __c__GetContentRegionMaxAbs(^result)
    return result
}
ShrinkWidths :: (_items: ^mut ImGuiShrinkWidthItem, _count: i32, _width_excess: f32) {
    __c__ShrinkWidths(_items, _count, _width_excess)
}
LogBegin :: (_type: ImGuiLogType, _auto_open_depth: i32) {
    __c__LogBegin(_type, _auto_open_depth)
}
LogToBuffer :: (_auto_open_depth: i32) {
    __c__LogToBuffer(_auto_open_depth)
}
BeginChildEx :: (_name: ^char8, _id: ImGuiID, _size_arg: &mut ImVec2, _border: bool, _flags: ImGuiWindowFlags) -> bool {
    mut result : bool = default
    __c__BeginChildEx(^result, _name, _id, ^mut *_size_arg, _border, _flags)
    return result
}
OpenPopupEx :: (_id: ImGuiID, _popup_flags: ImGuiPopupFlags) {
    __c__OpenPopupEx(_id, _popup_flags)
}
ClosePopupToLevel :: (_remaining: i32, _restore_focus_to_window_under_popup: bool) {
    __c__ClosePopupToLevel(_remaining, _restore_focus_to_window_under_popup)
}
ClosePopupsOverWindow :: (_ref_window: ^mut ImGuiWindow, _restore_focus_to_window_under_popup: bool) {
    __c__ClosePopupsOverWindow(_ref_window, _restore_focus_to_window_under_popup)
}
IsPopupOpen_2 :: (_id: ImGuiID, _popup_flags: ImGuiPopupFlags) -> bool {
    mut result : bool = default
    __c__IsPopupOpen_2(^result, _id, _popup_flags)
    return result
}
BeginPopupEx :: (_id: ImGuiID, _extra_flags: ImGuiWindowFlags) -> bool {
    mut result : bool = default
    __c__BeginPopupEx(^result, _id, _extra_flags)
    return result
}
BeginTooltipEx :: (_extra_flags: ImGuiWindowFlags, _tooltip_flags: ImGuiTooltipFlags) {
    __c__BeginTooltipEx(_extra_flags, _tooltip_flags)
}
GetTopMostPopupModal :: () -> ^mut ImGuiWindow {
    mut result : ^mut ImGuiWindow = default
    __c__GetTopMostPopupModal(^result)
    return result
}
FindBestWindowPosForPopup :: (_window: ^mut ImGuiWindow) -> ImVec2 {
    mut result : ImVec2 = default
    __c__FindBestWindowPosForPopup(^result, _window)
    return result
}
FindBestWindowPosForPopupEx :: (_ref_pos: &mut ImVec2, _size: &mut ImVec2, _last_dir: ^mut ImGuiDir, _r_outer: &mut ImRect, _r_avoid: &mut ImRect, _policy: ImGuiPopupPositionPolicy) -> ImVec2 {
    mut result : ImVec2 = default
    __c__FindBestWindowPosForPopupEx(^result, ^mut *_ref_pos, ^mut *_size, _last_dir, ^mut *_r_outer, ^mut *_r_avoid, _policy)
    return result
}
NavInitWindow :: (_window: ^mut ImGuiWindow, _force_reinit: bool) {
    __c__NavInitWindow(_window, _force_reinit)
}
NavMoveRequestButNoResultYet :: () -> bool {
    mut result : bool = default
    __c__NavMoveRequestButNoResultYet(^result)
    return result
}
NavMoveRequestCancel :: () {
    __c__NavMoveRequestCancel()
}
NavMoveRequestForward :: (_move_dir: ImGuiDir, _clip_dir: ImGuiDir, _bb_rel: &mut ImRect, _move_flags: ImGuiNavMoveFlags) {
    __c__NavMoveRequestForward(_move_dir, _clip_dir, ^mut *_bb_rel, _move_flags)
}
NavMoveRequestTryWrapping :: (_window: ^mut ImGuiWindow, _move_flags: ImGuiNavMoveFlags) {
    __c__NavMoveRequestTryWrapping(_window, _move_flags)
}
GetNavInputAmount :: (_n: ImGuiNavInput, _mode: ImGuiInputReadMode) -> f32 {
    mut result : f32 = default
    __c__GetNavInputAmount(^result, _n, _mode)
    return result
}
GetNavInputAmount2d :: (_dir_sources: ImGuiNavDirSourceFlags, _mode: ImGuiInputReadMode, _slow_factor: f32, _fast_factor: f32) -> ImVec2 {
    mut result : ImVec2 = default
    __c__GetNavInputAmount2d(^result, _dir_sources, _mode, _slow_factor, _fast_factor)
    return result
}
CalcTypematicRepeatAmount :: (_t0: f32, _t1: f32, _repeat_delay: f32, _repeat_rate: f32) -> i32 {
    mut result : i32 = default
    __c__CalcTypematicRepeatAmount(^result, _t0, _t1, _repeat_delay, _repeat_rate)
    return result
}
ActivateItem :: (_id: ImGuiID) {
    __c__ActivateItem(_id)
}
SetNavID :: (_id: ImGuiID, _nav_layer: i32, _focus_scope_id: ImGuiID) {
    __c__SetNavID(_id, _nav_layer, _focus_scope_id)
}
SetNavIDWithRectRel :: (_id: ImGuiID, _nav_layer: i32, _focus_scope_id: ImGuiID, _rect_rel: &mut ImRect) {
    __c__SetNavIDWithRectRel(_id, _nav_layer, _focus_scope_id, ^mut *_rect_rel)
}
PushFocusScope :: (_id: ImGuiID) {
    __c__PushFocusScope(_id)
}
PopFocusScope :: () {
    __c__PopFocusScope()
}
IsMouseDragPastThreshold :: (_button: ImGuiMouseButton, _lock_threshold: f32) -> bool {
    mut result : bool = default
    __c__IsMouseDragPastThreshold(^result, _button, _lock_threshold)
    return result
}
GetMergedKeyModFlags :: () -> ImGuiKeyModFlags {
    mut result : ImGuiKeyModFlags = default
    __c__GetMergedKeyModFlags(^result)
    return result
}
DockContextInitialize :: (_ctx: ^mut ImGuiContext) {
    __c__DockContextInitialize(_ctx)
}
DockContextShutdown :: (_ctx: ^mut ImGuiContext) {
    __c__DockContextShutdown(_ctx)
}
DockContextClearNodes :: (_ctx: ^mut ImGuiContext, _root_id: ImGuiID, _clear_settings_refs: bool) {
    __c__DockContextClearNodes(_ctx, _root_id, _clear_settings_refs)
}
DockContextRebuildNodes :: (_ctx: ^mut ImGuiContext) {
    __c__DockContextRebuildNodes(_ctx)
}
DockContextUpdateUndocking :: (_ctx: ^mut ImGuiContext) {
    __c__DockContextUpdateUndocking(_ctx)
}
DockContextUpdateDocking :: (_ctx: ^mut ImGuiContext) {
    __c__DockContextUpdateDocking(_ctx)
}
DockContextGenNodeID :: (_ctx: ^mut ImGuiContext) -> ImGuiID {
    mut result : ImGuiID = default
    __c__DockContextGenNodeID(^result, _ctx)
    return result
}
DockContextQueueDock :: (_ctx: ^mut ImGuiContext, _target: ^mut ImGuiWindow, _target_node: ^mut ImGuiDockNode, _payload: ^mut ImGuiWindow, _split_dir: ImGuiDir, _split_ratio: f32, _split_outer: bool) {
    __c__DockContextQueueDock(_ctx, _target, _target_node, _payload, _split_dir, _split_ratio, _split_outer)
}
DockContextQueueUndockWindow :: (_ctx: ^mut ImGuiContext, _window: ^mut ImGuiWindow) {
    __c__DockContextQueueUndockWindow(_ctx, _window)
}
DockContextQueueUndockNode :: (_ctx: ^mut ImGuiContext, _node: ^mut ImGuiDockNode) {
    __c__DockContextQueueUndockNode(_ctx, _node)
}
DockContextCalcDropPosForDocking :: (_target: ^mut ImGuiWindow, _target_node: ^mut ImGuiDockNode, _payload: ^mut ImGuiWindow, _split_dir: ImGuiDir, _split_outer: bool, _out_pos: ^mut ImVec2) -> bool {
    mut result : bool = default
    __c__DockContextCalcDropPosForDocking(^result, _target, _target_node, _payload, _split_dir, _split_outer, _out_pos)
    return result
}
GetWindowAlwaysWantOwnTabBar :: (_window: ^mut ImGuiWindow) -> bool {
    mut result : bool = default
    __c__GetWindowAlwaysWantOwnTabBar(^result, _window)
    return result
}
BeginDocked :: (_window: ^mut ImGuiWindow, _p_open: ^mut bool) {
    __c__BeginDocked(_window, _p_open)
}
BeginDockableDragDropSource :: (_window: ^mut ImGuiWindow) {
    __c__BeginDockableDragDropSource(_window)
}
BeginDockableDragDropTarget :: (_window: ^mut ImGuiWindow) {
    __c__BeginDockableDragDropTarget(_window)
}
SetWindowDock :: (_window: ^mut ImGuiWindow, _dock_id: ImGuiID, _cond: ImGuiCond) {
    __c__SetWindowDock(_window, _dock_id, _cond)
}
DockBuilderDockWindow :: (_window_name: ^char8, _node_id: ImGuiID) {
    __c__DockBuilderDockWindow(_window_name, _node_id)
}
DockBuilderGetNode :: (_node_id: ImGuiID) -> ^mut ImGuiDockNode {
    mut result : ^mut ImGuiDockNode = default
    __c__DockBuilderGetNode(^result, _node_id)
    return result
}
DockBuilderAddNode :: (_node_id: ImGuiID, _flags: ImGuiDockNodeFlags) -> ImGuiID {
    mut result : ImGuiID = default
    __c__DockBuilderAddNode(^result, _node_id, _flags)
    return result
}
DockBuilderRemoveNode :: (_node_id: ImGuiID) {
    __c__DockBuilderRemoveNode(_node_id)
}
DockBuilderRemoveNodeDockedWindows :: (_node_id: ImGuiID, _clear_settings_refs: bool) {
    __c__DockBuilderRemoveNodeDockedWindows(_node_id, _clear_settings_refs)
}
DockBuilderRemoveNodeChildNodes :: (_node_id: ImGuiID) {
    __c__DockBuilderRemoveNodeChildNodes(_node_id)
}
DockBuilderSetNodePos :: (_node_id: ImGuiID, _pos: ImVec2) {
    __c__DockBuilderSetNodePos(_node_id, ^mut _pos)
}
DockBuilderSetNodeSize :: (_node_id: ImGuiID, _size: ImVec2) {
    __c__DockBuilderSetNodeSize(_node_id, ^mut _size)
}
DockBuilderSplitNode :: (_node_id: ImGuiID, _split_dir: ImGuiDir, _size_ratio_for_node_at_dir: f32, _out_id_at_dir: ^mut ImGuiID, _out_id_at_opposite_dir: ^mut ImGuiID) -> ImGuiID {
    mut result : ImGuiID = default
    __c__DockBuilderSplitNode(^result, _node_id, _split_dir, _size_ratio_for_node_at_dir, _out_id_at_dir, _out_id_at_opposite_dir)
    return result
}
DockBuilderCopyDockSpace :: (_src_dockspace_id: ImGuiID, _dst_dockspace_id: ImGuiID, _in_window_remap_pairs: ^mut __UNKNOWN_0) {
    __c__DockBuilderCopyDockSpace(_src_dockspace_id, _dst_dockspace_id, _in_window_remap_pairs)
}
DockBuilderCopyNode :: (_src_node_id: ImGuiID, _dst_node_id: ImGuiID, _out_node_remap_pairs: ^mut __UNKNOWN_16) {
    __c__DockBuilderCopyNode(_src_node_id, _dst_node_id, _out_node_remap_pairs)
}
DockBuilderCopyWindowSettings :: (_src_name: ^char8, _dst_name: ^char8) {
    __c__DockBuilderCopyWindowSettings(_src_name, _dst_name)
}
DockBuilderFinish :: (_node_id: ImGuiID) {
    __c__DockBuilderFinish(_node_id)
}
BeginDragDropTargetCustom :: (_bb: &mut ImRect, _id: ImGuiID) -> bool {
    mut result : bool = default
    __c__BeginDragDropTargetCustom(^result, ^mut *_bb, _id)
    return result
}
ClearDragDrop :: () {
    __c__ClearDragDrop()
}
IsDragDropPayloadBeingAccepted :: () -> bool {
    mut result : bool = default
    __c__IsDragDropPayloadBeingAccepted(^result)
    return result
}
SetWindowClipRectBeforeSetChannel :: (_window: ^mut ImGuiWindow, _clip_rect: &mut ImRect) {
    __c__SetWindowClipRectBeforeSetChannel(_window, ^mut *_clip_rect)
}
BeginColumns :: (_str_id: ^char8, _count: i32, _flags: ImGuiColumnsFlags) {
    __c__BeginColumns(_str_id, _count, _flags)
}
EndColumns :: () {
    __c__EndColumns()
}
PushColumnClipRect :: (_column_index: i32) {
    __c__PushColumnClipRect(_column_index)
}
PushColumnsBackground :: () {
    __c__PushColumnsBackground()
}
PopColumnsBackground :: () {
    __c__PopColumnsBackground()
}
GetColumnsID :: (_str_id: ^char8, _count: i32) -> ImGuiID {
    mut result : ImGuiID = default
    __c__GetColumnsID(^result, _str_id, _count)
    return result
}
FindOrCreateColumns :: (_window: ^mut ImGuiWindow, _id: ImGuiID) -> ^mut ImGuiColumns {
    mut result : ^mut ImGuiColumns = default
    __c__FindOrCreateColumns(^result, _window, _id)
    return result
}
GetColumnOffsetFromNorm :: (_columns: ^mut ImGuiColumns, _offset_norm: f32) -> f32 {
    mut result : f32 = default
    __c__GetColumnOffsetFromNorm(^result, _columns, _offset_norm)
    return result
}
GetColumnNormFromOffset :: (_columns: ^mut ImGuiColumns, _offset: f32) -> f32 {
    mut result : f32 = default
    __c__GetColumnNormFromOffset(^result, _columns, _offset)
    return result
}
BeginTabBarEx :: (_tab_bar: ^mut ImGuiTabBar, _bb: &mut ImRect, _flags: ImGuiTabBarFlags, _dock_node: ^mut ImGuiDockNode) -> bool {
    mut result : bool = default
    __c__BeginTabBarEx(^result, _tab_bar, ^mut *_bb, _flags, _dock_node)
    return result
}
TabBarFindTabByID :: (_tab_bar: ^mut ImGuiTabBar, _tab_id: ImGuiID) -> ^mut ImGuiTabItem {
    mut result : ^mut ImGuiTabItem = default
    __c__TabBarFindTabByID(^result, _tab_bar, _tab_id)
    return result
}
TabBarFindMostRecentlySelectedTabForActiveWindow :: (_tab_bar: ^mut ImGuiTabBar) -> ^mut ImGuiTabItem {
    mut result : ^mut ImGuiTabItem = default
    __c__TabBarFindMostRecentlySelectedTabForActiveWindow(^result, _tab_bar)
    return result
}
TabBarAddTab :: (_tab_bar: ^mut ImGuiTabBar, _tab_flags: ImGuiTabItemFlags, _window: ^mut ImGuiWindow) {
    __c__TabBarAddTab(_tab_bar, _tab_flags, _window)
}
TabBarRemoveTab :: (_tab_bar: ^mut ImGuiTabBar, _tab_id: ImGuiID) {
    __c__TabBarRemoveTab(_tab_bar, _tab_id)
}
TabBarCloseTab :: (_tab_bar: ^mut ImGuiTabBar, _tab: ^mut ImGuiTabItem) {
    __c__TabBarCloseTab(_tab_bar, _tab)
}
TabBarQueueReorder :: (_tab_bar: ^mut ImGuiTabBar, _tab: ^mut ImGuiTabItem, _dir: i32) {
    __c__TabBarQueueReorder(_tab_bar, _tab, _dir)
}
TabBarProcessReorder :: (_tab_bar: ^mut ImGuiTabBar) -> bool {
    mut result : bool = default
    __c__TabBarProcessReorder(^result, _tab_bar)
    return result
}
TabItemEx :: (_tab_bar: ^mut ImGuiTabBar, _label: ^char8, _p_open: ^mut bool, _flags: ImGuiTabItemFlags, _docked_window: ^mut ImGuiWindow) -> bool {
    mut result : bool = default
    __c__TabItemEx(^result, _tab_bar, _label, _p_open, _flags, _docked_window)
    return result
}
TabItemCalcSize :: (_label: ^char8, _has_close_button: bool) -> ImVec2 {
    mut result : ImVec2 = default
    __c__TabItemCalcSize(^result, _label, _has_close_button)
    return result
}
TabItemBackground :: (_draw_list: ^mut ImDrawList, _bb: &mut ImRect, _flags: ImGuiTabItemFlags, _col: ImU32) {
    __c__TabItemBackground(_draw_list, ^mut *_bb, _flags, _col)
}
TabItemLabelAndCloseButton :: (_draw_list: ^mut ImDrawList, _bb: &mut ImRect, _flags: ImGuiTabItemFlags, _frame_padding: ImVec2, _label: ^char8, _tab_id: ImGuiID, _close_button_id: ImGuiID, _is_contents_visible: bool) -> bool {
    mut result : bool = default
    __c__TabItemLabelAndCloseButton(^result, _draw_list, ^mut *_bb, _flags, ^mut _frame_padding, _label, _tab_id, _close_button_id, _is_contents_visible)
    return result
}
RenderText :: (_pos: ImVec2, _text: ^char8, _text_end: ^char8, _hide_text_after_hash: bool) {
    __c__RenderText(^mut _pos, _text, _text_end, _hide_text_after_hash)
}
RenderTextWrapped :: (_pos: ImVec2, _text: ^char8, _text_end: ^char8, _wrap_width: f32) {
    __c__RenderTextWrapped(^mut _pos, _text, _text_end, _wrap_width)
}
RenderTextClipped :: (_pos_min: &mut ImVec2, _pos_max: &mut ImVec2, _text: ^char8, _text_end: ^char8, _text_size_if_known: ^mut ImVec2, _align: &mut ImVec2, _clip_rect: ^mut ImRect) {
    __c__RenderTextClipped(^mut *_pos_min, ^mut *_pos_max, _text, _text_end, _text_size_if_known, ^mut *_align, _clip_rect)
}
RenderTextClippedEx :: (_draw_list: ^mut ImDrawList, _pos_min: &mut ImVec2, _pos_max: &mut ImVec2, _text: ^char8, _text_end: ^char8, _text_size_if_known: ^mut ImVec2, _align: &mut ImVec2, _clip_rect: ^mut ImRect) {
    __c__RenderTextClippedEx(_draw_list, ^mut *_pos_min, ^mut *_pos_max, _text, _text_end, _text_size_if_known, ^mut *_align, _clip_rect)
}
RenderTextEllipsis :: (_draw_list: ^mut ImDrawList, _pos_min: &mut ImVec2, _pos_max: &mut ImVec2, _clip_max_x: f32, _ellipsis_max_x: f32, _text: ^char8, _text_end: ^char8, _text_size_if_known: ^mut ImVec2) {
    __c__RenderTextEllipsis(_draw_list, ^mut *_pos_min, ^mut *_pos_max, _clip_max_x, _ellipsis_max_x, _text, _text_end, _text_size_if_known)
}
RenderFrame :: (_p_min: ImVec2, _p_max: ImVec2, _fill_col: ImU32, _border: bool, _rounding: f32) {
    __c__RenderFrame(^mut _p_min, ^mut _p_max, _fill_col, _border, _rounding)
}
RenderFrameBorder :: (_p_min: ImVec2, _p_max: ImVec2, _rounding: f32) {
    __c__RenderFrameBorder(^mut _p_min, ^mut _p_max, _rounding)
}
RenderColorRectWithAlphaCheckerboard :: (_draw_list: ^mut ImDrawList, _p_min: ImVec2, _p_max: ImVec2, _fill_col: ImU32, _grid_step: f32, _grid_off: ImVec2, _rounding: f32, _rounding_corners_flags: i32) {
    __c__RenderColorRectWithAlphaCheckerboard(_draw_list, ^mut _p_min, ^mut _p_max, _fill_col, _grid_step, ^mut _grid_off, _rounding, _rounding_corners_flags)
}
RenderNavHighlight :: (_bb: &mut ImRect, _id: ImGuiID, _flags: ImGuiNavHighlightFlags) {
    __c__RenderNavHighlight(^mut *_bb, _id, _flags)
}
FindRenderedTextEnd :: (_text: ^char8, _text_end: ^char8) -> ^char8 {
    mut result : ^char8 = default
    __c__FindRenderedTextEnd(^result, _text, _text_end)
    return result
}
LogRenderedText :: (_ref_pos: ^mut ImVec2, _text: ^char8, _text_end: ^char8) {
    __c__LogRenderedText(_ref_pos, _text, _text_end)
}
RenderArrow :: (_draw_list: ^mut ImDrawList, _pos: ImVec2, _col: ImU32, _dir: ImGuiDir, _scale: f32) {
    __c__RenderArrow(_draw_list, ^mut _pos, _col, _dir, _scale)
}
RenderBullet :: (_draw_list: ^mut ImDrawList, _pos: ImVec2, _col: ImU32) {
    __c__RenderBullet(_draw_list, ^mut _pos, _col)
}
RenderCheckMark :: (_draw_list: ^mut ImDrawList, _pos: ImVec2, _col: ImU32, _sz: f32) {
    __c__RenderCheckMark(_draw_list, ^mut _pos, _col, _sz)
}
RenderMouseCursor :: (_draw_list: ^mut ImDrawList, _pos: ImVec2, _scale: f32, _mouse_cursor: ImGuiMouseCursor, _col_fill: ImU32, _col_border: ImU32, _col_shadow: ImU32) {
    __c__RenderMouseCursor(_draw_list, ^mut _pos, _scale, _mouse_cursor, _col_fill, _col_border, _col_shadow)
}
RenderArrowPointingAt :: (_draw_list: ^mut ImDrawList, _pos: ImVec2, _half_sz: ImVec2, _direction: ImGuiDir, _col: ImU32) {
    __c__RenderArrowPointingAt(_draw_list, ^mut _pos, ^mut _half_sz, _direction, _col)
}
RenderArrowDockMenu :: (_draw_list: ^mut ImDrawList, _p_min: ImVec2, _sz: f32, _col: ImU32) {
    __c__RenderArrowDockMenu(_draw_list, ^mut _p_min, _sz, _col)
}
RenderRectFilledRangeH :: (_draw_list: ^mut ImDrawList, _rect: &mut ImRect, _col: ImU32, _x_start_norm: f32, _x_end_norm: f32, _rounding: f32) {
    __c__RenderRectFilledRangeH(_draw_list, ^mut *_rect, _col, _x_start_norm, _x_end_norm, _rounding)
}
RenderRectFilledWithHole :: (_draw_list: ^mut ImDrawList, _outer: ImRect, _inner: ImRect, _col: ImU32, _rounding: f32) {
    __c__RenderRectFilledWithHole(_draw_list, ^mut _outer, ^mut _inner, _col, _rounding)
}
TextEx :: (_text: ^char8, _text_end: ^char8, _flags: ImGuiTextFlags) {
    __c__TextEx(_text, _text_end, _flags)
}
ButtonEx :: (_label: ^char8, _size_arg: &mut ImVec2, _flags: ImGuiButtonFlags) -> bool {
    mut result : bool = default
    __c__ButtonEx(^result, _label, ^mut *_size_arg, _flags)
    return result
}
CloseButton :: (_id: ImGuiID, _pos: &mut ImVec2) -> bool {
    mut result : bool = default
    __c__CloseButton(^result, _id, ^mut *_pos)
    return result
}
CollapseButton :: (_id: ImGuiID, _pos: &mut ImVec2, _dock_node: ^mut ImGuiDockNode) -> bool {
    mut result : bool = default
    __c__CollapseButton(^result, _id, ^mut *_pos, _dock_node)
    return result
}
ArrowButtonEx :: (_str_id: ^char8, _dir: ImGuiDir, _size_arg: ImVec2, _flags: ImGuiButtonFlags) -> bool {
    mut result : bool = default
    __c__ArrowButtonEx(^result, _str_id, _dir, ^mut _size_arg, _flags)
    return result
}
Scrollbar :: (_axis: ImGuiAxis) {
    __c__Scrollbar(_axis)
}
ScrollbarEx :: (_bb: &mut ImRect, _id: ImGuiID, _axis: ImGuiAxis, _p_scroll_v: ^mut f32, _avail_v: f32, _contents_v: f32, _rounding_corners: ImDrawCornerFlags) -> bool {
    mut result : bool = default
    __c__ScrollbarEx(^result, ^mut *_bb, _id, _axis, _p_scroll_v, _avail_v, _contents_v, _rounding_corners)
    return result
}
ImageButtonEx :: (_id: ImGuiID, _texture_id: ImTextureID, _size: &mut ImVec2, _uv0: &mut ImVec2, _uv1: &mut ImVec2, _padding: &mut ImVec2, _bg_col: &mut ImVec4, _tint_col: &mut ImVec4) -> bool {
    mut result : bool = default
    __c__ImageButtonEx(^result, _id, _texture_id, ^mut *_size, ^mut *_uv0, ^mut *_uv1, ^mut *_padding, ^mut *_bg_col, ^mut *_tint_col)
    return result
}
GetWindowScrollbarRect :: (_window: ^mut ImGuiWindow, _axis: ImGuiAxis) -> ImRect {
    mut result : ImRect = default
    __c__GetWindowScrollbarRect(^result, _window, _axis)
    return result
}
GetWindowScrollbarID :: (_window: ^mut ImGuiWindow, _axis: ImGuiAxis) -> ImGuiID {
    mut result : ImGuiID = default
    __c__GetWindowScrollbarID(^result, _window, _axis)
    return result
}
GetWindowResizeID :: (_window: ^mut ImGuiWindow, _n: i32) -> ImGuiID {
    mut result : ImGuiID = default
    __c__GetWindowResizeID(^result, _window, _n)
    return result
}
SeparatorEx :: (_flags: ImGuiSeparatorFlags) {
    __c__SeparatorEx(_flags)
}
ButtonBehavior :: (_bb: &mut ImRect, _id: ImGuiID, _out_hovered: ^mut bool, _out_held: ^mut bool, _flags: ImGuiButtonFlags) -> bool {
    mut result : bool = default
    __c__ButtonBehavior(^result, ^mut *_bb, _id, _out_hovered, _out_held, _flags)
    return result
}
DragBehavior :: (_id: ImGuiID, _data_type: ImGuiDataType, _p_v: ^mut void, _v_speed: f32, _p_min: ^mut void, _p_max: ^mut void, _format: ^char8, _flags: ImGuiSliderFlags) -> bool {
    mut result : bool = default
    __c__DragBehavior(^result, _id, _data_type, _p_v, _v_speed, _p_min, _p_max, _format, _flags)
    return result
}
SliderBehavior :: (_bb: &mut ImRect, _id: ImGuiID, _data_type: ImGuiDataType, _p_v: ^mut void, _p_min: ^mut void, _p_max: ^mut void, _format: ^char8, _flags: ImGuiSliderFlags, _out_grab_bb: ^mut ImRect) -> bool {
    mut result : bool = default
    __c__SliderBehavior(^result, ^mut *_bb, _id, _data_type, _p_v, _p_min, _p_max, _format, _flags, _out_grab_bb)
    return result
}
SplitterBehavior :: (_bb: &mut ImRect, _id: ImGuiID, _axis: ImGuiAxis, _size1: ^mut f32, _size2: ^mut f32, _min_size1: f32, _min_size2: f32, _hover_extend: f32, _hover_visibility_delay: f32) -> bool {
    mut result : bool = default
    __c__SplitterBehavior(^result, ^mut *_bb, _id, _axis, _size1, _size2, _min_size1, _min_size2, _hover_extend, _hover_visibility_delay)
    return result
}
TreeNodeBehavior :: (_id: ImGuiID, _flags: ImGuiTreeNodeFlags, _label: ^char8, _label_end: ^char8) -> bool {
    mut result : bool = default
    __c__TreeNodeBehavior(^result, _id, _flags, _label, _label_end)
    return result
}
TreeNodeBehaviorIsOpen :: (_id: ImGuiID, _flags: ImGuiTreeNodeFlags) -> bool {
    mut result : bool = default
    __c__TreeNodeBehaviorIsOpen(^result, _id, _flags)
    return result
}
TreePushOverrideID :: (_id: ImGuiID) {
    __c__TreePushOverrideID(_id)
}
DataTypeGetInfo :: (_data_type: ImGuiDataType) -> ^mut ImGuiDataTypeInfo {
    mut result : ^mut ImGuiDataTypeInfo = default
    __c__DataTypeGetInfo(^result, _data_type)
    return result
}
DataTypeFormatString :: (_buf: ^mut char8, _buf_size: i32, _data_type: ImGuiDataType, _p_data: ^mut void, _format: ^char8) -> i32 {
    mut result : i32 = default
    __c__DataTypeFormatString(^result, _buf, _buf_size, _data_type, _p_data, _format)
    return result
}
DataTypeApplyOp :: (_data_type: ImGuiDataType, _op: i32, _output: ^mut void, _arg_1: ^mut void, _arg_2: ^mut void) {
    __c__DataTypeApplyOp(_data_type, _op, _output, _arg_1, _arg_2)
}
DataTypeApplyOpFromText :: (_buf: ^char8, _initial_value_buf: ^char8, _data_type: ImGuiDataType, _p_data: ^mut void, _format: ^char8) -> bool {
    mut result : bool = default
    __c__DataTypeApplyOpFromText(^result, _buf, _initial_value_buf, _data_type, _p_data, _format)
    return result
}
DataTypeCompare :: (_data_type: ImGuiDataType, _arg_1: ^mut void, _arg_2: ^mut void) -> i32 {
    mut result : i32 = default
    __c__DataTypeCompare(^result, _data_type, _arg_1, _arg_2)
    return result
}
DataTypeClamp :: (_data_type: ImGuiDataType, _p_data: ^mut void, _p_min: ^mut void, _p_max: ^mut void) -> bool {
    mut result : bool = default
    __c__DataTypeClamp(^result, _data_type, _p_data, _p_min, _p_max)
    return result
}
InputTextEx :: (_label: ^char8, _hint: ^char8, _buf: ^mut char8, _buf_size: i32, _size_arg: &mut ImVec2, _flags: ImGuiInputTextFlags, _callback: ImGuiInputTextCallback, _user_data: ^mut void) -> bool {
    mut result : bool = default
    __c__InputTextEx(^result, _label, _hint, _buf, _buf_size, ^mut *_size_arg, _flags, _callback, _user_data)
    return result
}
TempInputText :: (_bb: &mut ImRect, _id: ImGuiID, _label: ^char8, _buf: ^mut char8, _buf_size: i32, _flags: ImGuiInputTextFlags) -> bool {
    mut result : bool = default
    __c__TempInputText(^result, ^mut *_bb, _id, _label, _buf, _buf_size, _flags)
    return result
}
TempInputScalar :: (_bb: &mut ImRect, _id: ImGuiID, _label: ^char8, _data_type: ImGuiDataType, _p_data: ^mut void, _format: ^char8, _p_clamp_min: ^mut void, _p_clamp_max: ^mut void) -> bool {
    mut result : bool = default
    __c__TempInputScalar(^result, ^mut *_bb, _id, _label, _data_type, _p_data, _format, _p_clamp_min, _p_clamp_max)
    return result
}
ColorTooltip :: (_text: ^char8, _col: ^f32, _flags: ImGuiColorEditFlags) {
    __c__ColorTooltip(_text, _col, _flags)
}
ColorEditOptionsPopup :: (_col: ^f32, _flags: ImGuiColorEditFlags) {
    __c__ColorEditOptionsPopup(_col, _flags)
}
ColorPickerOptionsPopup :: (_ref_col: ^f32, _flags: ImGuiColorEditFlags) {
    __c__ColorPickerOptionsPopup(_ref_col, _flags)
}
PlotEx :: (_plot_type: ImGuiPlotType, _label: ^char8, _values_getter: fn(^mut void, i32) -> f32, _data: ^mut void, _values_count: i32, _values_offset: i32, _overlay_text: ^char8, _scale_min: f32, _scale_max: f32, _frame_size: ImVec2) -> i32 {
    mut result : i32 = default
    __c__PlotEx(^result, _plot_type, _label, _values_getter, _data, _values_count, _values_offset, _overlay_text, _scale_min, _scale_max, ^mut _frame_size)
    return result
}
ShadeVertsLinearColorGradientKeepAlpha :: (_draw_list: ^mut ImDrawList, _vert_start_idx: i32, _vert_end_idx: i32, _gradient_p0: ImVec2, _gradient_p1: ImVec2, _col0: ImU32, _col1: ImU32) {
    __c__ShadeVertsLinearColorGradientKeepAlpha(_draw_list, _vert_start_idx, _vert_end_idx, ^mut _gradient_p0, ^mut _gradient_p1, _col0, _col1)
}
ShadeVertsLinearUV :: (_draw_list: ^mut ImDrawList, _vert_start_idx: i32, _vert_end_idx: i32, _a: &mut ImVec2, _b: &mut ImVec2, _uv_a: &mut ImVec2, _uv_b: &mut ImVec2, _clamp: bool) {
    __c__ShadeVertsLinearUV(_draw_list, _vert_start_idx, _vert_end_idx, ^mut *_a, ^mut *_b, ^mut *_uv_a, ^mut *_uv_b, _clamp)
}
GcCompactTransientWindowBuffers :: (_window: ^mut ImGuiWindow) {
    __c__GcCompactTransientWindowBuffers(_window)
}
GcAwakeTransientWindowBuffers :: (_window: ^mut ImGuiWindow) {
    __c__GcAwakeTransientWindowBuffers(_window)
}
ImFontAtlasBuildWithStbTruetype :: (_atlas: ^mut ImFontAtlas) -> bool {
    mut result : bool = default
    __c__ImFontAtlasBuildWithStbTruetype(^result, _atlas)
    return result
}
ImFontAtlasBuildInit :: (_atlas: ^mut ImFontAtlas) {
    __c__ImFontAtlasBuildInit(_atlas)
}
ImFontAtlasBuildSetupFont :: (_atlas: ^mut ImFontAtlas, _font: ^mut ImFont, _font_config: ^mut ImFontConfig, _ascent: f32, _descent: f32) {
    __c__ImFontAtlasBuildSetupFont(_atlas, _font, _font_config, _ascent, _descent)
}
ImFontAtlasBuildPackCustomRects :: (_atlas: ^mut ImFontAtlas, _stbrp_context_opaque: ^mut void) {
    __c__ImFontAtlasBuildPackCustomRects(_atlas, _stbrp_context_opaque)
}
ImFontAtlasBuildFinish :: (_atlas: ^mut ImFontAtlas) {
    __c__ImFontAtlasBuildFinish(_atlas)
}
ImFontAtlasBuildRender1bppRectFromString :: (_atlas: ^mut ImFontAtlas, _atlas_x: i32, _atlas_y: i32, _w: i32, _h: i32, _in_str: ^char8, _in_marker_char: char8, _in_marker_pixel_value: u8) {
    __c__ImFontAtlasBuildRender1bppRectFromString(_atlas, _atlas_x, _atlas_y, _w, _h, _in_str, _in_marker_char, _in_marker_pixel_value)
}
ImFontAtlasBuildMultiplyCalcLookupTable :: (_out_table: ^mut u8, _in_multiply_factor: f32) {
    __c__ImFontAtlasBuildMultiplyCalcLookupTable(_out_table, _in_multiply_factor)
}
ImFontAtlasBuildMultiplyRectAlpha8 :: (_table: ^u8, _pixels: ^mut u8, _x: i32, _y: i32, _w: i32, _h: i32, _stride: i32) {
    __c__ImFontAtlasBuildMultiplyRectAlpha8(_table, _pixels, _x, _y, _w, _h, _stride)
}
ImGui_ImplGlfw_InitForOpenGL :: (_window: ^mut GLFWwindow, _install_callbacks: bool) -> bool {
    mut result : bool = default
    __c__ImGui_ImplGlfw_InitForOpenGL(^result, _window, _install_callbacks)
    return result
}
ImGui_ImplGlfw_InitForVulkan :: (_window: ^mut GLFWwindow, _install_callbacks: bool) -> bool {
    mut result : bool = default
    __c__ImGui_ImplGlfw_InitForVulkan(^result, _window, _install_callbacks)
    return result
}
ImGui_ImplGlfw_Shutdown :: () {
    __c__ImGui_ImplGlfw_Shutdown()
}
ImGui_ImplGlfw_NewFrame :: () {
    __c__ImGui_ImplGlfw_NewFrame()
}
ImGui_ImplGlfw_MouseButtonCallback :: (_window: ^mut GLFWwindow, _button: i32, _action: i32, _mods: i32) {
    __c__ImGui_ImplGlfw_MouseButtonCallback(_window, _button, _action, _mods)
}
ImGui_ImplGlfw_ScrollCallback :: (_window: ^mut GLFWwindow, _xoffset: f64, _yoffset: f64) {
    __c__ImGui_ImplGlfw_ScrollCallback(_window, _xoffset, _yoffset)
}
ImGui_ImplGlfw_KeyCallback :: (_window: ^mut GLFWwindow, _key: i32, _scancode: i32, _action: i32, _mods: i32) {
    __c__ImGui_ImplGlfw_KeyCallback(_window, _key, _scancode, _action, _mods)
}
ImGui_ImplGlfw_CharCallback :: (_window: ^mut GLFWwindow, _c: u32) {
    __c__ImGui_ImplGlfw_CharCallback(_window, _c)
}
ImGui_ImplGlfw_MonitorCallback :: (_monitor: ^mut GLFWmonitor, _event: i32) {
    __c__ImGui_ImplGlfw_MonitorCallback(_monitor, _event)
}
__security_cookie : uintptr_t #extern
EmptyString : [1]char8 #extern
GImGui : ^mut ImGuiContext #extern

// ==========================================================
// ==========================================================
// ==========================================================

#file_scope

__c__ImVec2_new_2 :: (self: ^mut ImVec2);
__c__ImVec2_new_3 :: (self: ^mut ImVec2, __x: f32, __y: f32);
__c__ImVec4_new_4 :: (self: ^mut ImVec4);
__c__ImVec4_new_5 :: (self: ^mut ImVec4, __x: f32, __y: f32, __z: f32, __w: f32);
__c__ImGuiStyle_new_39 :: (self: ^mut ImGuiStyle);
__c__ImGuiStyle_ScaleAllSizes_40 :: (self: ^mut ImGuiStyle, _scale_factor: f32);
__c__ImGuiIO_AddInputCharacter_53 :: (self: ^mut ImGuiIO, _c: u32);
__c__ImGuiIO_AddInputCharacterUTF16_54 :: (self: ^mut ImGuiIO, _c: ImWchar16);
__c__ImGuiIO_AddInputCharactersUTF8_55 :: (self: ^mut ImGuiIO, _str: ^char8);
__c__ImGuiIO_ClearInputCharacters_56 :: (self: ^mut ImGuiIO);
__c__ImGuiIO_new_91 :: (self: ^mut ImGuiIO);
__c__ImGuiInputTextCallbackData_new_12 :: (self: ^mut ImGuiInputTextCallbackData);
__c__ImGuiInputTextCallbackData_DeleteChars_13 :: (self: ^mut ImGuiInputTextCallbackData, _pos: i32, _bytes_count: i32);
__c__ImGuiInputTextCallbackData_InsertChars_14 :: (self: ^mut ImGuiInputTextCallbackData, _pos: i32, _text: ^char8, _text_end: ^char8);
__c__ImGuiInputTextCallbackData_SelectAll_15 :: (self: ^mut ImGuiInputTextCallbackData);
__c__ImGuiInputTextCallbackData_ClearSelection_16 :: (self: ^mut ImGuiInputTextCallbackData);
__c__ImGuiInputTextCallbackData_HasSelection_17 :: (self: ^mut ImGuiInputTextCallbackData, ret: ^bool);
__c__ImGuiWindowClass_new_8 :: (self: ^mut ImGuiWindowClass);
__c__ImGuiPayload_new_8 :: (self: ^mut ImGuiPayload);
__c__ImGuiPayload_Clear_9 :: (self: ^mut ImGuiPayload);
__c__ImGuiPayload_IsDataType_10 :: (self: ^mut ImGuiPayload, ret: ^bool, _type: ^char8);
__c__ImGuiPayload_IsPreview_11 :: (self: ^mut ImGuiPayload, ret: ^bool);
__c__ImGuiPayload_IsDelivery_12 :: (self: ^mut ImGuiPayload, ret: ^bool);
__c__ImGuiOnceUponAFrame_new_0 :: (self: ^mut ImGuiOnceUponAFrame);
__c__ImGuiTextFilter_new_0 :: (self: ^mut ImGuiTextFilter, _default_filter: ^char8);
__c__ImGuiTextFilter_Draw_1 :: (self: ^mut ImGuiTextFilter, ret: ^bool, _label: ^char8, _width: f32);
__c__ImGuiTextFilter_PassFilter_2 :: (self: ^mut ImGuiTextFilter, ret: ^bool, _text: ^char8, _text_end: ^char8);
__c__ImGuiTextFilter_Build_3 :: (self: ^mut ImGuiTextFilter);
__c__ImGuiTextFilter_Clear_4 :: (self: ^mut ImGuiTextFilter);
__c__ImGuiTextFilter_IsActive_5 :: (self: ^mut ImGuiTextFilter, ret: ^bool);
__c__ImGuiTextRange_new_2 :: (self: ^mut ImGuiTextRange);
__c__ImGuiTextRange_new_3 :: (self: ^mut ImGuiTextRange, __b: ^char8, __e: ^char8);
__c__ImGuiTextRange_empty_4 :: (self: ^mut ImGuiTextRange, ret: ^bool);
__c__ImGuiTextRange_split_5 :: (self: ^mut ImGuiTextRange, _separator: char8, _out: ^mut __UNKNOWN_16);
__c__ImGuiTextBuffer_new_2 :: (self: ^mut ImGuiTextBuffer);
__c__ImGuiTextBuffer_begin_4 :: (self: ^mut ImGuiTextBuffer, ret: ^^char8);
__c__ImGuiTextBuffer_end_5 :: (self: ^mut ImGuiTextBuffer, ret: ^^char8);
__c__ImGuiTextBuffer_size_6 :: (self: ^mut ImGuiTextBuffer, ret: ^i32);
__c__ImGuiTextBuffer_empty_7 :: (self: ^mut ImGuiTextBuffer, ret: ^bool);
__c__ImGuiTextBuffer_clear_8 :: (self: ^mut ImGuiTextBuffer);
__c__ImGuiTextBuffer_reserve_9 :: (self: ^mut ImGuiTextBuffer, _capacity: i32);
__c__ImGuiTextBuffer_c_str_10 :: (self: ^mut ImGuiTextBuffer, ret: ^^char8);
__c__ImGuiTextBuffer_append_11 :: (self: ^mut ImGuiTextBuffer, _str: ^char8, _str_end: ^char8);
__c__ImGuiTextBuffer_appendf_12 :: (self: ^mut ImGuiTextBuffer, _fmt: ^char8);
__c__ImGuiTextBuffer_appendfv_13 :: (self: ^mut ImGuiTextBuffer, _fmt: ^char8, _args: va_list);
__c__ImGuiStorage_Clear_2 :: (self: ^mut ImGuiStorage);
__c__ImGuiStorage_GetInt_3 :: (self: ^mut ImGuiStorage, ret: ^i32, _key: ImGuiID, _default_val: i32);
__c__ImGuiStorage_SetInt_4 :: (self: ^mut ImGuiStorage, _key: ImGuiID, _val: i32);
__c__ImGuiStorage_GetBool_5 :: (self: ^mut ImGuiStorage, ret: ^bool, _key: ImGuiID, _default_val: bool);
__c__ImGuiStorage_SetBool_6 :: (self: ^mut ImGuiStorage, _key: ImGuiID, _val: bool);
__c__ImGuiStorage_GetFloat_7 :: (self: ^mut ImGuiStorage, ret: ^f32, _key: ImGuiID, _default_val: f32);
__c__ImGuiStorage_SetFloat_8 :: (self: ^mut ImGuiStorage, _key: ImGuiID, _val: f32);
__c__ImGuiStorage_GetVoidPtr_9 :: (self: ^mut ImGuiStorage, ret: ^^mut void, _key: ImGuiID);
__c__ImGuiStorage_SetVoidPtr_10 :: (self: ^mut ImGuiStorage, _key: ImGuiID, _val: ^mut void);
__c__ImGuiStorage_GetIntRef_11 :: (self: ^mut ImGuiStorage, ret: ^^mut i32, _key: ImGuiID, _default_val: i32);
__c__ImGuiStorage_GetBoolRef_12 :: (self: ^mut ImGuiStorage, ret: ^^mut bool, _key: ImGuiID, _default_val: bool);
__c__ImGuiStorage_GetFloatRef_13 :: (self: ^mut ImGuiStorage, ret: ^^mut f32, _key: ImGuiID, _default_val: f32);
__c__ImGuiStorage_GetVoidPtrRef_14 :: (self: ^mut ImGuiStorage, ret: ^^mut ^mut void, _key: ImGuiID, _default_val: ^mut void);
__c__ImGuiStorage_SetAllInt_15 :: (self: ^mut ImGuiStorage, _val: i32);
__c__ImGuiStorage_BuildSortByKey_16 :: (self: ^mut ImGuiStorage);
__c__ImGuiStoragePair_new_2 :: (self: ^mut ImGuiStoragePair, __key: ImGuiID, __val_i: i32);
__c__ImGuiStoragePair_new_3 :: (self: ^mut ImGuiStoragePair, __key: ImGuiID, __val_f: f32);
__c__ImGuiStoragePair_new_4 :: (self: ^mut ImGuiStoragePair, __key: ImGuiID, __val_p: ^mut void);
__c__ImGuiListClipper_new_6 :: (self: ^mut ImGuiListClipper, _items_count: i32, _items_height: f32);
__c__ImGuiListClipper_dtor :: (self: ^mut ImGuiListClipper);
__c__ImGuiListClipper_Step_8 :: (self: ^mut ImGuiListClipper, ret: ^bool);
__c__ImGuiListClipper_Begin_9 :: (self: ^mut ImGuiListClipper, _items_count: i32, _items_height: f32);
__c__ImGuiListClipper_End_10 :: (self: ^mut ImGuiListClipper);
__c__ImColor_new_1 :: (self: ^mut ImColor);
__c__ImColor_new_2 :: (self: ^mut ImColor, _r: i32, _g: i32, _b: i32, _a: i32);
__c__ImColor_new_3 :: (self: ^mut ImColor, _rgba: ImU32);
__c__ImColor_new_4 :: (self: ^mut ImColor, _r: f32, _g: f32, _b: f32, _a: f32);
__c__ImColor_new_5 :: (self: ^mut ImColor, _col: ^mut ImVec4);
__c__ImColor_SetHSV_8 :: (self: ^mut ImColor, _h: f32, _s: f32, _v: f32, _a: f32);
__c__ImColor_HSV_9 :: (self: ^mut ImColor, ret: ^ImColor, _h: f32, _s: f32, _v: f32, _a: f32);
__c__ImDrawCmd_new_7 :: (self: ^mut ImDrawCmd);
__c__ImDrawListSplitter_new_3 :: (self: ^mut ImDrawListSplitter);
__c__ImDrawListSplitter_dtor :: (self: ^mut ImDrawListSplitter);
__c__ImDrawListSplitter_Clear_5 :: (self: ^mut ImDrawListSplitter);
__c__ImDrawListSplitter_ClearFreeMemory_6 :: (self: ^mut ImDrawListSplitter);
__c__ImDrawListSplitter_Split_7 :: (self: ^mut ImDrawListSplitter, _draw_list: ^mut ImDrawList, _count: i32);
__c__ImDrawListSplitter_Merge_8 :: (self: ^mut ImDrawListSplitter, _draw_list: ^mut ImDrawList);
__c__ImDrawListSplitter_SetCurrentChannel_9 :: (self: ^mut ImDrawListSplitter, _draw_list: ^mut ImDrawList, _channel_idx: i32);
__c__ImDrawList_new_14 :: (self: ^mut ImDrawList, _shared_data: ^mut ImDrawListSharedData);
__c__ImDrawList_dtor :: (self: ^mut ImDrawList);
__c__ImDrawList_PushClipRect_16 :: (self: ^mut ImDrawList, _clip_rect_min: ^mut ImVec2, _clip_rect_max: ^mut ImVec2, _intersect_with_current_clip_rect: bool);
__c__ImDrawList_PushClipRectFullScreen_17 :: (self: ^mut ImDrawList);
__c__ImDrawList_PopClipRect_18 :: (self: ^mut ImDrawList);
__c__ImDrawList_PushTextureID_19 :: (self: ^mut ImDrawList, _texture_id: ImTextureID);
__c__ImDrawList_PopTextureID_20 :: (self: ^mut ImDrawList);
__c__ImDrawList_GetClipRectMin_21 :: (self: ^mut ImDrawList, ret: ^ImVec2);
__c__ImDrawList_GetClipRectMax_22 :: (self: ^mut ImDrawList, ret: ^ImVec2);
__c__ImDrawList_AddLine_23 :: (self: ^mut ImDrawList, _p1: ^mut ImVec2, _p2: ^mut ImVec2, _col: ImU32, _thickness: f32);
__c__ImDrawList_AddRect_24 :: (self: ^mut ImDrawList, _p_min: ^mut ImVec2, _p_max: ^mut ImVec2, _col: ImU32, _rounding: f32, _rounding_corners: ImDrawCornerFlags, _thickness: f32);
__c__ImDrawList_AddRectFilled_25 :: (self: ^mut ImDrawList, _p_min: ^mut ImVec2, _p_max: ^mut ImVec2, _col: ImU32, _rounding: f32, _rounding_corners: ImDrawCornerFlags);
__c__ImDrawList_AddRectFilledMultiColor_26 :: (self: ^mut ImDrawList, _p_min: ^mut ImVec2, _p_max: ^mut ImVec2, _col_upr_left: ImU32, _col_upr_right: ImU32, _col_bot_right: ImU32, _col_bot_left: ImU32);
__c__ImDrawList_AddQuad_27 :: (self: ^mut ImDrawList, _p1: ^mut ImVec2, _p2: ^mut ImVec2, _p3: ^mut ImVec2, _p4: ^mut ImVec2, _col: ImU32, _thickness: f32);
__c__ImDrawList_AddQuadFilled_28 :: (self: ^mut ImDrawList, _p1: ^mut ImVec2, _p2: ^mut ImVec2, _p3: ^mut ImVec2, _p4: ^mut ImVec2, _col: ImU32);
__c__ImDrawList_AddTriangle_29 :: (self: ^mut ImDrawList, _p1: ^mut ImVec2, _p2: ^mut ImVec2, _p3: ^mut ImVec2, _col: ImU32, _thickness: f32);
__c__ImDrawList_AddTriangleFilled_30 :: (self: ^mut ImDrawList, _p1: ^mut ImVec2, _p2: ^mut ImVec2, _p3: ^mut ImVec2, _col: ImU32);
__c__ImDrawList_AddCircle_31 :: (self: ^mut ImDrawList, _center: ^mut ImVec2, _radius: f32, _col: ImU32, _num_segments: i32, _thickness: f32);
__c__ImDrawList_AddCircleFilled_32 :: (self: ^mut ImDrawList, _center: ^mut ImVec2, _radius: f32, _col: ImU32, _num_segments: i32);
__c__ImDrawList_AddNgon_33 :: (self: ^mut ImDrawList, _center: ^mut ImVec2, _radius: f32, _col: ImU32, _num_segments: i32, _thickness: f32);
__c__ImDrawList_AddNgonFilled_34 :: (self: ^mut ImDrawList, _center: ^mut ImVec2, _radius: f32, _col: ImU32, _num_segments: i32);
__c__ImDrawList_AddText_35 :: (self: ^mut ImDrawList, _pos: ^mut ImVec2, _col: ImU32, _text_begin: ^char8, _text_end: ^char8);
__c__ImDrawList_AddText_36 :: (self: ^mut ImDrawList, _font: ^mut ImFont, _font_size: f32, _pos: ^mut ImVec2, _col: ImU32, _text_begin: ^char8, _text_end: ^char8, _wrap_width: f32, _cpu_fine_clip_rect: ^mut ImVec4);
__c__ImDrawList_AddPolyline_37 :: (self: ^mut ImDrawList, _points: ^mut ImVec2, _num_points: i32, _col: ImU32, _closed: bool, _thickness: f32);
__c__ImDrawList_AddConvexPolyFilled_38 :: (self: ^mut ImDrawList, _points: ^mut ImVec2, _num_points: i32, _col: ImU32);
__c__ImDrawList_AddBezierCurve_39 :: (self: ^mut ImDrawList, _p1: ^mut ImVec2, _p2: ^mut ImVec2, _p3: ^mut ImVec2, _p4: ^mut ImVec2, _col: ImU32, _thickness: f32, _num_segments: i32);
__c__ImDrawList_AddImage_40 :: (self: ^mut ImDrawList, _user_texture_id: ImTextureID, _p_min: ^mut ImVec2, _p_max: ^mut ImVec2, _uv_min: ^mut ImVec2, _uv_max: ^mut ImVec2, _col: ImU32);
__c__ImDrawList_AddImageQuad_41 :: (self: ^mut ImDrawList, _user_texture_id: ImTextureID, _p1: ^mut ImVec2, _p2: ^mut ImVec2, _p3: ^mut ImVec2, _p4: ^mut ImVec2, _uv1: ^mut ImVec2, _uv2: ^mut ImVec2, _uv3: ^mut ImVec2, _uv4: ^mut ImVec2, _col: ImU32);
__c__ImDrawList_AddImageRounded_42 :: (self: ^mut ImDrawList, _user_texture_id: ImTextureID, _p_min: ^mut ImVec2, _p_max: ^mut ImVec2, _uv_min: ^mut ImVec2, _uv_max: ^mut ImVec2, _col: ImU32, _rounding: f32, _rounding_corners: ImDrawCornerFlags);
__c__ImDrawList_PathClear_43 :: (self: ^mut ImDrawList);
__c__ImDrawList_PathLineTo_44 :: (self: ^mut ImDrawList, _pos: ^mut ImVec2);
__c__ImDrawList_PathLineToMergeDuplicate_45 :: (self: ^mut ImDrawList, _pos: ^mut ImVec2);
__c__ImDrawList_PathFillConvex_46 :: (self: ^mut ImDrawList, _col: ImU32);
__c__ImDrawList_PathStroke_47 :: (self: ^mut ImDrawList, _col: ImU32, _closed: bool, _thickness: f32);
__c__ImDrawList_PathArcTo_48 :: (self: ^mut ImDrawList, _center: ^mut ImVec2, _radius: f32, _a_min: f32, _a_max: f32, _num_segments: i32);
__c__ImDrawList_PathArcToFast_49 :: (self: ^mut ImDrawList, _center: ^mut ImVec2, _radius: f32, _a_min_of_12: i32, _a_max_of_12: i32);
__c__ImDrawList_PathBezierCurveTo_50 :: (self: ^mut ImDrawList, _p2: ^mut ImVec2, _p3: ^mut ImVec2, _p4: ^mut ImVec2, _num_segments: i32);
__c__ImDrawList_PathRect_51 :: (self: ^mut ImDrawList, _rect_min: ^mut ImVec2, _rect_max: ^mut ImVec2, _rounding: f32, _rounding_corners: ImDrawCornerFlags);
__c__ImDrawList_AddCallback_52 :: (self: ^mut ImDrawList, _callback: ImDrawCallback, _callback_data: ^mut void);
__c__ImDrawList_AddDrawCmd_53 :: (self: ^mut ImDrawList);
__c__ImDrawList_CloneOutput_54 :: (self: ^mut ImDrawList, ret: ^^mut ImDrawList);
__c__ImDrawList_ChannelsSplit_55 :: (self: ^mut ImDrawList, _count: i32);
__c__ImDrawList_ChannelsMerge_56 :: (self: ^mut ImDrawList);
__c__ImDrawList_ChannelsSetCurrent_57 :: (self: ^mut ImDrawList, _n: i32);
__c__ImDrawList_PrimReserve_58 :: (self: ^mut ImDrawList, _idx_count: i32, _vtx_count: i32);
__c__ImDrawList_PrimUnreserve_59 :: (self: ^mut ImDrawList, _idx_count: i32, _vtx_count: i32);
__c__ImDrawList_PrimRect_60 :: (self: ^mut ImDrawList, _a: ^mut ImVec2, _b: ^mut ImVec2, _col: ImU32);
__c__ImDrawList_PrimRectUV_61 :: (self: ^mut ImDrawList, _a: ^mut ImVec2, _b: ^mut ImVec2, _uv_a: ^mut ImVec2, _uv_b: ^mut ImVec2, _col: ImU32);
__c__ImDrawList_PrimQuadUV_62 :: (self: ^mut ImDrawList, _a: ^mut ImVec2, _b: ^mut ImVec2, _c: ^mut ImVec2, _d: ^mut ImVec2, _uv_a: ^mut ImVec2, _uv_b: ^mut ImVec2, _uv_c: ^mut ImVec2, _uv_d: ^mut ImVec2, _col: ImU32);
__c__ImDrawList_PrimWriteVtx_63 :: (self: ^mut ImDrawList, _pos: ^mut ImVec2, _uv: ^mut ImVec2, _col: ImU32);
__c__ImDrawList_PrimWriteIdx_64 :: (self: ^mut ImDrawList, _idx: ImDrawIdx);
__c__ImDrawList_PrimVtx_65 :: (self: ^mut ImDrawList, _pos: ^mut ImVec2, _uv: ^mut ImVec2, _col: ImU32);
__c__ImDrawList__ResetForNewFrame_66 :: (self: ^mut ImDrawList);
__c__ImDrawList__ClearFreeMemory_67 :: (self: ^mut ImDrawList);
__c__ImDrawList__PopUnusedDrawCmd_68 :: (self: ^mut ImDrawList);
__c__ImDrawList__OnChangedClipRect_69 :: (self: ^mut ImDrawList);
__c__ImDrawList__OnChangedTextureID_70 :: (self: ^mut ImDrawList);
__c__ImDrawList__OnChangedVtxOffset_71 :: (self: ^mut ImDrawList);
__c__ImDrawData_new_9 :: (self: ^mut ImDrawData);
__c__ImDrawData_dtor :: (self: ^mut ImDrawData);
__c__ImDrawData_Clear_11 :: (self: ^mut ImDrawData);
__c__ImDrawData_DeIndexAllBuffers_12 :: (self: ^mut ImDrawData);
__c__ImDrawData_ScaleClipRects_13 :: (self: ^mut ImDrawData, _fb_scale: ^mut ImVec2);
__c__ImFontConfig_new_19 :: (self: ^mut ImFontConfig);
__c__ImFontGlyphRangesBuilder_new_1 :: (self: ^mut ImFontGlyphRangesBuilder);
__c__ImFontGlyphRangesBuilder_Clear_2 :: (self: ^mut ImFontGlyphRangesBuilder);
__c__ImFontGlyphRangesBuilder_GetBit_3 :: (self: ^mut ImFontGlyphRangesBuilder, ret: ^bool, _n: size_t);
__c__ImFontGlyphRangesBuilder_SetBit_4 :: (self: ^mut ImFontGlyphRangesBuilder, _n: size_t);
__c__ImFontGlyphRangesBuilder_AddChar_5 :: (self: ^mut ImFontGlyphRangesBuilder, _c: ImWchar);
__c__ImFontGlyphRangesBuilder_AddText_6 :: (self: ^mut ImFontGlyphRangesBuilder, _text: ^char8, _text_end: ^char8);
__c__ImFontGlyphRangesBuilder_AddRanges_7 :: (self: ^mut ImFontGlyphRangesBuilder, _ranges: ^mut ImWchar);
__c__ImFontGlyphRangesBuilder_BuildRanges_8 :: (self: ^mut ImFontGlyphRangesBuilder, _out_ranges: ^mut __UNKNOWN_16);
__c__ImFontAtlasCustomRect_new_8 :: (self: ^mut ImFontAtlasCustomRect);
__c__ImFontAtlasCustomRect_IsPacked_9 :: (self: ^mut ImFontAtlasCustomRect, ret: ^bool);
__c__ImFontAtlas_new_0 :: (self: ^mut ImFontAtlas);
__c__ImFontAtlas_dtor :: (self: ^mut ImFontAtlas);
__c__ImFontAtlas_AddFont_2 :: (self: ^mut ImFontAtlas, ret: ^^mut ImFont, _font_cfg: ^mut ImFontConfig);
__c__ImFontAtlas_AddFontDefault_3 :: (self: ^mut ImFontAtlas, ret: ^^mut ImFont, _font_cfg: ^mut ImFontConfig);
__c__ImFontAtlas_AddFontFromFileTTF_4 :: (self: ^mut ImFontAtlas, ret: ^^mut ImFont, _filename: ^char8, _size_pixels: f32, _font_cfg: ^mut ImFontConfig, _glyph_ranges: ^mut ImWchar);
__c__ImFontAtlas_AddFontFromMemoryTTF_5 :: (self: ^mut ImFontAtlas, ret: ^^mut ImFont, _font_data: ^mut void, _font_size: i32, _size_pixels: f32, _font_cfg: ^mut ImFontConfig, _glyph_ranges: ^mut ImWchar);
__c__ImFontAtlas_AddFontFromMemoryCompressedTTF_6 :: (self: ^mut ImFontAtlas, ret: ^^mut ImFont, _compressed_font_data: ^mut void, _compressed_font_size: i32, _size_pixels: f32, _font_cfg: ^mut ImFontConfig, _glyph_ranges: ^mut ImWchar);
__c__ImFontAtlas_AddFontFromMemoryCompressedBase85TTF_7 :: (self: ^mut ImFontAtlas, ret: ^^mut ImFont, _compressed_font_data_base85: ^char8, _size_pixels: f32, _font_cfg: ^mut ImFontConfig, _glyph_ranges: ^mut ImWchar);
__c__ImFontAtlas_ClearInputData_8 :: (self: ^mut ImFontAtlas);
__c__ImFontAtlas_ClearTexData_9 :: (self: ^mut ImFontAtlas);
__c__ImFontAtlas_ClearFonts_10 :: (self: ^mut ImFontAtlas);
__c__ImFontAtlas_Clear_11 :: (self: ^mut ImFontAtlas);
__c__ImFontAtlas_Build_12 :: (self: ^mut ImFontAtlas, ret: ^bool);
__c__ImFontAtlas_GetTexDataAsAlpha8_13 :: (self: ^mut ImFontAtlas, _out_pixels: ^mut ^mut u8, _out_width: ^mut i32, _out_height: ^mut i32, _out_bytes_per_pixel: ^mut i32);
__c__ImFontAtlas_GetTexDataAsRGBA32_14 :: (self: ^mut ImFontAtlas, _out_pixels: ^mut ^mut u8, _out_width: ^mut i32, _out_height: ^mut i32, _out_bytes_per_pixel: ^mut i32);
__c__ImFontAtlas_IsBuilt_15 :: (self: ^mut ImFontAtlas, ret: ^bool);
__c__ImFontAtlas_SetTexID_16 :: (self: ^mut ImFontAtlas, _id: ImTextureID);
__c__ImFontAtlas_GetGlyphRangesDefault_17 :: (self: ^mut ImFontAtlas, ret: ^^mut ImWchar);
__c__ImFontAtlas_GetGlyphRangesKorean_18 :: (self: ^mut ImFontAtlas, ret: ^^mut ImWchar);
__c__ImFontAtlas_GetGlyphRangesJapanese_19 :: (self: ^mut ImFontAtlas, ret: ^^mut ImWchar);
__c__ImFontAtlas_GetGlyphRangesChineseFull_20 :: (self: ^mut ImFontAtlas, ret: ^^mut ImWchar);
__c__ImFontAtlas_GetGlyphRangesChineseSimplifiedCommon_21 :: (self: ^mut ImFontAtlas, ret: ^^mut ImWchar);
__c__ImFontAtlas_GetGlyphRangesCyrillic_22 :: (self: ^mut ImFontAtlas, ret: ^^mut ImWchar);
__c__ImFontAtlas_GetGlyphRangesThai_23 :: (self: ^mut ImFontAtlas, ret: ^^mut ImWchar);
__c__ImFontAtlas_GetGlyphRangesVietnamese_24 :: (self: ^mut ImFontAtlas, ret: ^^mut ImWchar);
__c__ImFontAtlas_AddCustomRectRegular_25 :: (self: ^mut ImFontAtlas, ret: ^i32, _width: i32, _height: i32);
__c__ImFontAtlas_AddCustomRectFontGlyph_26 :: (self: ^mut ImFontAtlas, ret: ^i32, _font: ^mut ImFont, _id: ImWchar, _width: i32, _height: i32, _advance_x: f32, _offset: ^mut ImVec2);
__c__ImFontAtlas_GetCustomRectByIndex_27 :: (self: ^mut ImFontAtlas, ret: ^^mut ImFontAtlasCustomRect, _index: i32);
__c__ImFontAtlas_CalcCustomRectUV_28 :: (self: ^mut ImFontAtlas, _rect: ^mut ImFontAtlasCustomRect, _out_uv_min: ^mut ImVec2, _out_uv_max: ^mut ImVec2);
__c__ImFontAtlas_GetMouseCursorTexData_29 :: (self: ^mut ImFontAtlas, ret: ^bool, _cursor: ImGuiMouseCursor, _out_offset: ^mut ImVec2, _out_size: ^mut ImVec2, _out_uv_border: ^mut ImVec2, _out_uv_fill: ^mut ImVec2);
__c__ImFont_new_18 :: (self: ^mut ImFont);
__c__ImFont_dtor :: (self: ^mut ImFont);
__c__ImFont_FindGlyph_20 :: (self: ^mut ImFont, ret: ^^mut ImFontGlyph, _c: ImWchar);
__c__ImFont_FindGlyphNoFallback_21 :: (self: ^mut ImFont, ret: ^^mut ImFontGlyph, _c: ImWchar);
__c__ImFont_GetCharAdvance_22 :: (self: ^mut ImFont, ret: ^f32, _c: ImWchar);
__c__ImFont_IsLoaded_23 :: (self: ^mut ImFont, ret: ^bool);
__c__ImFont_GetDebugName_24 :: (self: ^mut ImFont, ret: ^^char8);
__c__ImFont_CalcTextSizeA_25 :: (self: ^mut ImFont, ret: ^ImVec2, _size: f32, _max_width: f32, _wrap_width: f32, _text_begin: ^char8, _text_end: ^char8, _remaining: ^mut ^char8);
__c__ImFont_CalcWordWrapPositionA_26 :: (self: ^mut ImFont, ret: ^^char8, _scale: f32, _text: ^char8, _text_end: ^char8, _wrap_width: f32);
__c__ImFont_RenderChar_27 :: (self: ^mut ImFont, _draw_list: ^mut ImDrawList, _size: f32, _pos: ^mut ImVec2, _col: ImU32, _c: ImWchar);
__c__ImFont_RenderText_28 :: (self: ^mut ImFont, _draw_list: ^mut ImDrawList, _size: f32, _pos: ^mut ImVec2, _col: ImU32, _clip_rect: ^mut ImVec4, _text_begin: ^char8, _text_end: ^char8, _wrap_width: f32, _cpu_fine_clip: bool);
__c__ImFont_BuildLookupTable_29 :: (self: ^mut ImFont);
__c__ImFont_ClearOutputData_30 :: (self: ^mut ImFont);
__c__ImFont_GrowIndex_31 :: (self: ^mut ImFont, _new_size: i32);
__c__ImFont_AddGlyph_32 :: (self: ^mut ImFont, _src_cfg: ^mut ImFontConfig, _c: ImWchar, _x0: f32, _y0: f32, _x1: f32, _y1: f32, _u0: f32, _v0: f32, _u1: f32, _v1: f32, _advance_x: f32);
__c__ImFont_AddRemapChar_33 :: (self: ^mut ImFont, _dst: ImWchar, _src: ImWchar, _overwrite_dst: bool);
__c__ImFont_SetGlyphVisible_34 :: (self: ^mut ImFont, _c: ImWchar, _visible: bool);
__c__ImFont_SetFallbackChar_35 :: (self: ^mut ImFont, _c: ImWchar);
__c__ImFont_IsGlyphRangeUnused_36 :: (self: ^mut ImFont, ret: ^bool, _c_begin: u32, _c_last: u32);
__c__ImGuiPlatformIO_new_27 :: (self: ^mut ImGuiPlatformIO);
__c__ImGuiPlatformMonitor_new_5 :: (self: ^mut ImGuiPlatformMonitor);
__c__ImGuiViewport_new_16 :: (self: ^mut ImGuiViewport);
__c__ImGuiViewport_dtor :: (self: ^mut ImGuiViewport);
__c__ImGuiViewport_GetCenter_18 :: (self: ^mut ImGuiViewport, ret: ^ImVec2);
__c__ImGuiViewport_GetWorkPos_19 :: (self: ^mut ImGuiViewport, ret: ^ImVec2);
__c__ImGuiViewport_GetWorkSize_20 :: (self: ^mut ImGuiViewport, ret: ^ImVec2);
__c__ImVec1_new_1 :: (self: ^mut ImVec1);
__c__ImVec1_new_2 :: (self: ^mut ImVec1, __x: f32);
__c__ImVec2ih_new_2 :: (self: ^mut ImVec2ih);
__c__ImVec2ih_new_3 :: (self: ^mut ImVec2ih, __x: i16, __y: i16);
__c__ImVec2ih_new_4 :: (self: ^mut ImVec2ih, _rhs: ^mut ImVec2);
__c__ImRect_new_2 :: (self: ^mut ImRect);
__c__ImRect_new_3 :: (self: ^mut ImRect, _min: ^mut ImVec2, _max: ^mut ImVec2);
__c__ImRect_new_4 :: (self: ^mut ImRect, _v: ^mut ImVec4);
__c__ImRect_new_5 :: (self: ^mut ImRect, _x1: f32, _y1: f32, _x2: f32, _y2: f32);
__c__ImRect_GetCenter_6 :: (self: ^mut ImRect, ret: ^ImVec2);
__c__ImRect_GetSize_7 :: (self: ^mut ImRect, ret: ^ImVec2);
__c__ImRect_GetWidth_8 :: (self: ^mut ImRect, ret: ^f32);
__c__ImRect_GetHeight_9 :: (self: ^mut ImRect, ret: ^f32);
__c__ImRect_GetTL_10 :: (self: ^mut ImRect, ret: ^ImVec2);
__c__ImRect_GetTR_11 :: (self: ^mut ImRect, ret: ^ImVec2);
__c__ImRect_GetBL_12 :: (self: ^mut ImRect, ret: ^ImVec2);
__c__ImRect_GetBR_13 :: (self: ^mut ImRect, ret: ^ImVec2);
__c__ImRect_Contains_14 :: (self: ^mut ImRect, ret: ^bool, _p: ^mut ImVec2);
__c__ImRect_Contains_15 :: (self: ^mut ImRect, ret: ^bool, _r: ^mut ImRect);
__c__ImRect_Overlaps_16 :: (self: ^mut ImRect, ret: ^bool, _r: ^mut ImRect);
__c__ImRect_Add_17 :: (self: ^mut ImRect, _p: ^mut ImVec2);
__c__ImRect_Add_18 :: (self: ^mut ImRect, _r: ^mut ImRect);
__c__ImRect_Expand_19 :: (self: ^mut ImRect, _amount: f32);
__c__ImRect_Expand_20 :: (self: ^mut ImRect, _amount: ^mut ImVec2);
__c__ImRect_Translate_21 :: (self: ^mut ImRect, _d: ^mut ImVec2);
__c__ImRect_TranslateX_22 :: (self: ^mut ImRect, _dx: f32);
__c__ImRect_TranslateY_23 :: (self: ^mut ImRect, _dy: f32);
__c__ImRect_ClipWith_24 :: (self: ^mut ImRect, _r: ^mut ImRect);
__c__ImRect_ClipWithFull_25 :: (self: ^mut ImRect, _r: ^mut ImRect);
__c__ImRect_Floor_26 :: (self: ^mut ImRect);
__c__ImRect_IsInverted_27 :: (self: ^mut ImRect, ret: ^bool);
__c__ImRect_ToVec4_28 :: (self: ^mut ImRect, ret: ^ImVec4);
__c__ImBitVector_Create_1 :: (self: ^mut ImBitVector, _sz: i32);
__c__ImBitVector_Clear_2 :: (self: ^mut ImBitVector);
__c__ImBitVector_TestBit_3 :: (self: ^mut ImBitVector, ret: ^bool, _n: i32);
__c__ImBitVector_SetBit_4 :: (self: ^mut ImBitVector, _n: i32);
__c__ImBitVector_ClearBit_5 :: (self: ^mut ImBitVector, _n: i32);
__c__ImDrawListSharedData_new_10 :: (self: ^mut ImDrawListSharedData);
__c__ImDrawListSharedData_SetCircleSegmentMaxError_11 :: (self: ^mut ImDrawListSharedData, _max_error: f32);
__c__ImDrawDataBuilder_Clear_1 :: (self: ^mut ImDrawDataBuilder);
__c__ImDrawDataBuilder_ClearFreeMemory_2 :: (self: ^mut ImDrawDataBuilder);
__c__ImDrawDataBuilder_FlattenIntoSingleLayer_3 :: (self: ^mut ImDrawDataBuilder);
__c__ImGuiStyleMod_new_2 :: (self: ^mut ImGuiStyleMod, _idx: ImGuiStyleVar, _v: i32);
__c__ImGuiStyleMod_new_3 :: (self: ^mut ImGuiStyleMod, _idx: ImGuiStyleVar, _v: f32);
__c__ImGuiStyleMod_new_4 :: (self: ^mut ImGuiStyleMod, _idx: ImGuiStyleVar, _v: ^mut ImVec2);
__c__ImGuiMenuColumns_new_5 :: (self: ^mut ImGuiMenuColumns);
__c__ImGuiMenuColumns_Update_6 :: (self: ^mut ImGuiMenuColumns, _count: i32, _spacing: f32, _clear: bool);
__c__ImGuiMenuColumns_DeclColumns_7 :: (self: ^mut ImGuiMenuColumns, ret: ^f32, _w0: f32, _w1: f32, _w2: f32);
__c__ImGuiMenuColumns_CalcExtraSpace_8 :: (self: ^mut ImGuiMenuColumns, ret: ^f32, _avail_w: f32);
__c__ImGuiInputTextState_new_17 :: (self: ^mut ImGuiInputTextState);
__c__ImGuiInputTextState_ClearText_18 :: (self: ^mut ImGuiInputTextState);
__c__ImGuiInputTextState_ClearFreeMemory_19 :: (self: ^mut ImGuiInputTextState);
__c__ImGuiInputTextState_GetUndoAvailCount_20 :: (self: ^mut ImGuiInputTextState, ret: ^i32);
__c__ImGuiInputTextState_GetRedoAvailCount_21 :: (self: ^mut ImGuiInputTextState, ret: ^i32);
__c__ImGuiInputTextState_OnKeyPressed_22 :: (self: ^mut ImGuiInputTextState, _key: i32);
__c__ImGuiInputTextState_CursorAnimReset_23 :: (self: ^mut ImGuiInputTextState);
__c__ImGuiInputTextState_CursorClamp_24 :: (self: ^mut ImGuiInputTextState);
__c__ImGuiInputTextState_HasSelection_25 :: (self: ^mut ImGuiInputTextState, ret: ^bool);
__c__ImGuiInputTextState_ClearSelection_26 :: (self: ^mut ImGuiInputTextState);
__c__ImGuiInputTextState_SelectAll_27 :: (self: ^mut ImGuiInputTextState);
__c__ImGuiPopupData_new_7 :: (self: ^mut ImGuiPopupData);
__c__ImGuiNavMoveResult_new_7 :: (self: ^mut ImGuiNavMoveResult);
__c__ImGuiNavMoveResult_Clear_8 :: (self: ^mut ImGuiNavMoveResult);
__c__ImGuiNextWindowData_new_20 :: (self: ^mut ImGuiNextWindowData);
__c__ImGuiNextWindowData_ClearFlags_21 :: (self: ^mut ImGuiNextWindowData);
__c__ImGuiNextItemData_new_5 :: (self: ^mut ImGuiNextItemData);
__c__ImGuiNextItemData_ClearFlags_6 :: (self: ^mut ImGuiNextItemData);
__c__ImGuiPtrOrIndex_new_2 :: (self: ^mut ImGuiPtrOrIndex, _ptr: ^mut void);
__c__ImGuiPtrOrIndex_new_3 :: (self: ^mut ImGuiPtrOrIndex, _index: i32);
__c__ImGuiColumnData_new_4 :: (self: ^mut ImGuiColumnData);
__c__ImGuiColumns_new_17 :: (self: ^mut ImGuiColumns);
__c__ImGuiColumns_Clear_18 :: (self: ^mut ImGuiColumns);
__c__ImGuiDockNode_new_37 :: (self: ^mut ImGuiDockNode, _id: ImGuiID);
__c__ImGuiDockNode_dtor :: (self: ^mut ImGuiDockNode);
__c__ImGuiDockNode_IsRootNode_39 :: (self: ^mut ImGuiDockNode, ret: ^bool);
__c__ImGuiDockNode_IsDockSpace_40 :: (self: ^mut ImGuiDockNode, ret: ^bool);
__c__ImGuiDockNode_IsFloatingNode_41 :: (self: ^mut ImGuiDockNode, ret: ^bool);
__c__ImGuiDockNode_IsCentralNode_42 :: (self: ^mut ImGuiDockNode, ret: ^bool);
__c__ImGuiDockNode_IsHiddenTabBar_43 :: (self: ^mut ImGuiDockNode, ret: ^bool);
__c__ImGuiDockNode_IsNoTabBar_44 :: (self: ^mut ImGuiDockNode, ret: ^bool);
__c__ImGuiDockNode_IsSplitNode_45 :: (self: ^mut ImGuiDockNode, ret: ^bool);
__c__ImGuiDockNode_IsLeafNode_46 :: (self: ^mut ImGuiDockNode, ret: ^bool);
__c__ImGuiDockNode_IsEmpty_47 :: (self: ^mut ImGuiDockNode, ret: ^bool);
__c__ImGuiDockNode_GetMergedFlags_48 :: (self: ^mut ImGuiDockNode, ret: ^ImGuiDockNodeFlags);
__c__ImGuiDockNode_Rect_49 :: (self: ^mut ImGuiDockNode, ret: ^ImRect);
__c__ImGuiDockContext_new_4 :: (self: ^mut ImGuiDockContext);
__c__ImGuiViewportP_new_20 :: (self: ^mut ImGuiViewportP);
__c__ImGuiViewportP_dtor :: (self: ^mut ImGuiViewportP);
__c__ImGuiViewportP_GetMainRect_22 :: (self: ^mut ImGuiViewportP, ret: ^ImRect);
__c__ImGuiViewportP_GetWorkRect_23 :: (self: ^mut ImGuiViewportP, ret: ^ImRect);
__c__ImGuiViewportP_ClearRequestFlags_24 :: (self: ^mut ImGuiViewportP);
__c__ImGuiWindowSettings_new_10 :: (self: ^mut ImGuiWindowSettings);
__c__ImGuiWindowSettings_GetName_11 :: (self: ^mut ImGuiWindowSettings, ret: ^^mut char8);
__c__ImGuiSettingsHandler_new_9 :: (self: ^mut ImGuiSettingsHandler);
__c__ImGuiContext_new_199 :: (self: ^mut ImGuiContext, _shared_font_atlas: ^mut ImFontAtlas);
__c__ImGuiWindowTempData_new_42 :: (self: ^mut ImGuiWindowTempData);
__c__ImGuiWindow_new_100 :: (self: ^mut ImGuiWindow, _context: ^mut ImGuiContext, _name: ^char8);
__c__ImGuiWindow_dtor :: (self: ^mut ImGuiWindow);
__c__ImGuiWindow_GetID_102 :: (self: ^mut ImGuiWindow, ret: ^ImGuiID, _str: ^char8, _str_end: ^char8);
__c__ImGuiWindow_GetID_103 :: (self: ^mut ImGuiWindow, ret: ^ImGuiID, _ptr: ^mut void);
__c__ImGuiWindow_GetID_104 :: (self: ^mut ImGuiWindow, ret: ^ImGuiID, _n: i32);
__c__ImGuiWindow_GetIDNoKeepAlive_105 :: (self: ^mut ImGuiWindow, ret: ^ImGuiID, _str: ^char8, _str_end: ^char8);
__c__ImGuiWindow_GetIDNoKeepAlive_106 :: (self: ^mut ImGuiWindow, ret: ^ImGuiID, _ptr: ^mut void);
__c__ImGuiWindow_GetIDNoKeepAlive_107 :: (self: ^mut ImGuiWindow, ret: ^ImGuiID, _n: i32);
__c__ImGuiWindow_GetIDFromRectangle_108 :: (self: ^mut ImGuiWindow, ret: ^ImGuiID, _r_abs: ^mut ImRect);
__c__ImGuiWindow_Rect_109 :: (self: ^mut ImGuiWindow, ret: ^ImRect);
__c__ImGuiWindow_CalcFontSize_110 :: (self: ^mut ImGuiWindow, ret: ^f32);
__c__ImGuiWindow_TitleBarHeight_111 :: (self: ^mut ImGuiWindow, ret: ^f32);
__c__ImGuiWindow_TitleBarRect_112 :: (self: ^mut ImGuiWindow, ret: ^ImRect);
__c__ImGuiWindow_MenuBarHeight_113 :: (self: ^mut ImGuiWindow, ret: ^f32);
__c__ImGuiWindow_MenuBarRect_114 :: (self: ^mut ImGuiWindow, ret: ^ImRect);
__c__ImGuiLastItemDataBackup_new_4 :: (self: ^mut ImGuiLastItemDataBackup);
__c__ImGuiLastItemDataBackup_Backup_5 :: (self: ^mut ImGuiLastItemDataBackup);
__c__ImGuiLastItemDataBackup_Restore_6 :: (self: ^mut ImGuiLastItemDataBackup);
__c__ImGuiTabItem_new_11 :: (self: ^mut ImGuiTabItem);
__c__ImGuiTabBar_new_25 :: (self: ^mut ImGuiTabBar);
__c__ImGuiTabBar_GetTabOrder_26 :: (self: ^mut ImGuiTabBar, ret: ^i32, _tab: ^mut ImGuiTabItem);
__c__ImGuiTabBar_GetTabName_27 :: (self: ^mut ImGuiTabBar, ret: ^^char8, _tab: ^mut ImGuiTabItem);
__c__CreateContext :: (ret: ^mut ^mut ImGuiContext, _shared_font_atlas: ^mut ImFontAtlas);
__c__DestroyContext :: (_ctx: ^mut ImGuiContext);
__c__GetCurrentContext :: (ret: ^mut ^mut ImGuiContext);
__c__SetCurrentContext :: (_ctx: ^mut ImGuiContext);
__c__GetIO :: (ret: ^mut ^mut ImGuiIO);
__c__GetStyle :: (ret: ^mut ^mut ImGuiStyle);
__c__NewFrame :: ();
__c__EndFrame :: ();
__c__Render :: ();
__c__GetDrawData :: (ret: ^mut ^mut ImDrawData);
__c__ShowDemoWindow :: (_p_open: ^mut bool);
__c__ShowAboutWindow :: (_p_open: ^mut bool);
__c__ShowMetricsWindow :: (_p_open: ^mut bool);
__c__ShowStyleEditor :: (_ref: ^mut ImGuiStyle);
__c__ShowStyleSelector :: (ret: ^mut bool, _label: ^char8);
__c__ShowFontSelector :: (_label: ^char8);
__c__ShowUserGuide :: ();
__c__GetVersion :: (ret: ^mut ^char8);
__c__StyleColorsDark :: (_dst: ^mut ImGuiStyle);
__c__StyleColorsClassic :: (_dst: ^mut ImGuiStyle);
__c__StyleColorsLight :: (_dst: ^mut ImGuiStyle);
__c__Begin :: (ret: ^mut bool, _name: ^char8, _p_open: ^mut bool, _flags: ImGuiWindowFlags);
__c__End :: ();
__c__BeginChild :: (ret: ^mut bool, _str_id: ^char8, _size: ^mut ImVec2, _border: bool, _flags: ImGuiWindowFlags);
__c__BeginChild_2 :: (ret: ^mut bool, _id: ImGuiID, _size: ^mut ImVec2, _border: bool, _flags: ImGuiWindowFlags);
__c__EndChild :: ();
__c__IsWindowAppearing :: (ret: ^mut bool);
__c__IsWindowCollapsed :: (ret: ^mut bool);
__c__IsWindowFocused :: (ret: ^mut bool, _flags: ImGuiFocusedFlags);
__c__IsWindowHovered :: (ret: ^mut bool, _flags: ImGuiHoveredFlags);
__c__GetWindowDrawList :: (ret: ^mut ^mut ImDrawList);
__c__GetWindowDpiScale :: (ret: ^mut f32);
__c__GetWindowViewport :: (ret: ^mut ^mut ImGuiViewport);
__c__GetWindowPos :: (ret: ^mut ImVec2);
__c__GetWindowSize :: (ret: ^mut ImVec2);
__c__GetWindowWidth :: (ret: ^mut f32);
__c__GetWindowHeight :: (ret: ^mut f32);
__c__SetNextWindowPos :: (_pos: ^mut ImVec2, _cond: ImGuiCond, _pivot: ^mut ImVec2);
__c__SetNextWindowSize :: (_size: ^mut ImVec2, _cond: ImGuiCond);
__c__SetNextWindowSizeConstraints :: (_size_min: ^mut ImVec2, _size_max: ^mut ImVec2, _custom_callback: ImGuiSizeCallback, _custom_callback_data: ^mut void);
__c__SetNextWindowContentSize :: (_size: ^mut ImVec2);
__c__SetNextWindowCollapsed :: (_collapsed: bool, _cond: ImGuiCond);
__c__SetNextWindowFocus :: ();
__c__SetNextWindowBgAlpha :: (_alpha: f32);
__c__SetNextWindowViewport :: (_viewport_id: ImGuiID);
__c__SetWindowPos :: (_pos: ^mut ImVec2, _cond: ImGuiCond);
__c__SetWindowSize :: (_size: ^mut ImVec2, _cond: ImGuiCond);
__c__SetWindowCollapsed :: (_collapsed: bool, _cond: ImGuiCond);
__c__SetWindowFocus :: ();
__c__SetWindowFontScale :: (_scale: f32);
__c__SetWindowPos_2 :: (_name: ^char8, _pos: ^mut ImVec2, _cond: ImGuiCond);
__c__SetWindowSize_2 :: (_name: ^char8, _size: ^mut ImVec2, _cond: ImGuiCond);
__c__SetWindowCollapsed_2 :: (_name: ^char8, _collapsed: bool, _cond: ImGuiCond);
__c__SetWindowFocus_2 :: (_name: ^char8);
__c__GetContentRegionMax :: (ret: ^mut ImVec2);
__c__GetContentRegionAvail :: (ret: ^mut ImVec2);
__c__GetWindowContentRegionMin :: (ret: ^mut ImVec2);
__c__GetWindowContentRegionMax :: (ret: ^mut ImVec2);
__c__GetWindowContentRegionWidth :: (ret: ^mut f32);
__c__GetScrollX :: (ret: ^mut f32);
__c__GetScrollY :: (ret: ^mut f32);
__c__GetScrollMaxX :: (ret: ^mut f32);
__c__GetScrollMaxY :: (ret: ^mut f32);
__c__SetScrollX :: (_scroll_x: f32);
__c__SetScrollY :: (_scroll_y: f32);
__c__SetScrollHereX :: (_center_x_ratio: f32);
__c__SetScrollHereY :: (_center_y_ratio: f32);
__c__SetScrollFromPosX :: (_local_x: f32, _center_x_ratio: f32);
__c__SetScrollFromPosY :: (_local_y: f32, _center_y_ratio: f32);
__c__PushFont :: (_font: ^mut ImFont);
__c__PopFont :: ();
__c__PushStyleColor :: (_idx: ImGuiCol, _col: ImU32);
__c__PushStyleColor_2 :: (_idx: ImGuiCol, _col: ^mut ImVec4);
__c__PopStyleColor :: (_count: i32);
__c__PushStyleVar :: (_idx: ImGuiStyleVar, _val: f32);
__c__PushStyleVar_2 :: (_idx: ImGuiStyleVar, _val: ^mut ImVec2);
__c__PopStyleVar :: (_count: i32);
__c__GetStyleColorVec4 :: (ret: ^mut ^mut ImVec4, _idx: ImGuiCol);
__c__GetFont :: (ret: ^mut ^mut ImFont);
__c__GetFontSize :: (ret: ^mut f32);
__c__GetFontTexUvWhitePixel :: (ret: ^mut ImVec2);
__c__GetColorU32 :: (ret: ^mut ImU32, _idx: ImGuiCol, _alpha_mul: f32);
__c__GetColorU32_2 :: (ret: ^mut ImU32, _col: ^mut ImVec4);
__c__GetColorU32_3 :: (ret: ^mut ImU32, _col: ImU32);
__c__PushItemWidth :: (_item_width: f32);
__c__PopItemWidth :: ();
__c__SetNextItemWidth :: (_item_width: f32);
__c__CalcItemWidth :: (ret: ^mut f32);
__c__PushTextWrapPos :: (_wrap_local_pos_x: f32);
__c__PopTextWrapPos :: ();
__c__PushAllowKeyboardFocus :: (_allow_keyboard_focus: bool);
__c__PopAllowKeyboardFocus :: ();
__c__PushButtonRepeat :: (_repeat: bool);
__c__PopButtonRepeat :: ();
__c__Separator :: ();
__c__SameLine :: (_offset_from_start_x: f32, _spacing: f32);
__c__NewLine :: ();
__c__Spacing :: ();
__c__Dummy :: (_size: ^mut ImVec2);
__c__Indent :: (_indent_w: f32);
__c__Unindent :: (_indent_w: f32);
__c__BeginGroup :: ();
__c__EndGroup :: ();
__c__GetCursorPos :: (ret: ^mut ImVec2);
__c__GetCursorPosX :: (ret: ^mut f32);
__c__GetCursorPosY :: (ret: ^mut f32);
__c__SetCursorPos :: (_local_pos: ^mut ImVec2);
__c__SetCursorPosX :: (_local_x: f32);
__c__SetCursorPosY :: (_local_y: f32);
__c__GetCursorStartPos :: (ret: ^mut ImVec2);
__c__GetCursorScreenPos :: (ret: ^mut ImVec2);
__c__SetCursorScreenPos :: (_pos: ^mut ImVec2);
__c__AlignTextToFramePadding :: ();
__c__GetTextLineHeight :: (ret: ^mut f32);
__c__GetTextLineHeightWithSpacing :: (ret: ^mut f32);
__c__GetFrameHeight :: (ret: ^mut f32);
__c__GetFrameHeightWithSpacing :: (ret: ^mut f32);
__c__PushID :: (_str_id: ^char8);
__c__PushID_2 :: (_str_id_begin: ^char8, _str_id_end: ^char8);
__c__PushID_3 :: (_ptr_id: ^mut void);
__c__PushID_4 :: (_int_id: i32);
__c__PopID :: ();
__c__GetID :: (ret: ^mut ImGuiID, _str_id: ^char8);
__c__GetID_2 :: (ret: ^mut ImGuiID, _str_id_begin: ^char8, _str_id_end: ^char8);
__c__GetID_3 :: (ret: ^mut ImGuiID, _ptr_id: ^mut void);
__c__TextUnformatted :: (_text: ^char8, _text_end: ^char8);
__c__Text :: (_fmt: ^char8);
__c__TextV :: (_fmt: ^char8, _args: va_list);
__c__TextColored :: (_col: ^mut ImVec4, _fmt: ^char8);
__c__TextColoredV :: (_col: ^mut ImVec4, _fmt: ^char8, _args: va_list);
__c__TextDisabled :: (_fmt: ^char8);
__c__TextDisabledV :: (_fmt: ^char8, _args: va_list);
__c__TextWrapped :: (_fmt: ^char8);
__c__TextWrappedV :: (_fmt: ^char8, _args: va_list);
__c__LabelText :: (_label: ^char8, _fmt: ^char8);
__c__LabelTextV :: (_label: ^char8, _fmt: ^char8, _args: va_list);
__c__BulletText :: (_fmt: ^char8);
__c__BulletTextV :: (_fmt: ^char8, _args: va_list);
__c__Button :: (ret: ^mut bool, _label: ^char8, _size: ^mut ImVec2);
__c__SmallButton :: (ret: ^mut bool, _label: ^char8);
__c__InvisibleButton :: (ret: ^mut bool, _str_id: ^char8, _size: ^mut ImVec2, _flags: ImGuiButtonFlags);
__c__ArrowButton :: (ret: ^mut bool, _str_id: ^char8, _dir: ImGuiDir);
__c__Image :: (_user_texture_id: ImTextureID, _size: ^mut ImVec2, _uv0: ^mut ImVec2, _uv1: ^mut ImVec2, _tint_col: ^mut ImVec4, _border_col: ^mut ImVec4);
__c__ImageButton :: (ret: ^mut bool, _user_texture_id: ImTextureID, _size: ^mut ImVec2, _uv0: ^mut ImVec2, _uv1: ^mut ImVec2, _frame_padding: i32, _bg_col: ^mut ImVec4, _tint_col: ^mut ImVec4);
__c__Checkbox :: (ret: ^mut bool, _label: ^char8, _v: ^mut bool);
__c__CheckboxFlags :: (ret: ^mut bool, _label: ^char8, _flags: ^mut u32, _flags_value: u32);
__c__RadioButton :: (ret: ^mut bool, _label: ^char8, _active: bool);
__c__RadioButton_2 :: (ret: ^mut bool, _label: ^char8, _v: ^mut i32, _v_button: i32);
__c__ProgressBar :: (_fraction: f32, _size_arg: ^mut ImVec2, _overlay: ^char8);
__c__Bullet :: ();
__c__BeginCombo :: (ret: ^mut bool, _label: ^char8, _preview_value: ^char8, _flags: ImGuiComboFlags);
__c__EndCombo :: ();
__c__Combo :: (ret: ^mut bool, _label: ^char8, _current_item: ^mut i32, _items: ^mut ^char8, _items_count: i32, _popup_max_height_in_items: i32);
__c__Combo_2 :: (ret: ^mut bool, _label: ^char8, _current_item: ^mut i32, _items_separated_by_zeros: ^char8, _popup_max_height_in_items: i32);
__c__Combo_3 :: (ret: ^mut bool, _label: ^char8, _current_item: ^mut i32, _items_getter: fn(^mut void, i32, ^mut ^char8) -> bool, _data: ^mut void, _items_count: i32, _popup_max_height_in_items: i32);
__c__DragFloat :: (ret: ^mut bool, _label: ^char8, _v: ^mut f32, _v_speed: f32, _v_min: f32, _v_max: f32, _format: ^char8, _flags: ImGuiSliderFlags);
__c__DragFloat2 :: (ret: ^mut bool, _label: ^char8, _v: ^mut f32, _v_speed: f32, _v_min: f32, _v_max: f32, _format: ^char8, _flags: ImGuiSliderFlags);
__c__DragFloat3 :: (ret: ^mut bool, _label: ^char8, _v: ^mut f32, _v_speed: f32, _v_min: f32, _v_max: f32, _format: ^char8, _flags: ImGuiSliderFlags);
__c__DragFloat4 :: (ret: ^mut bool, _label: ^char8, _v: ^mut f32, _v_speed: f32, _v_min: f32, _v_max: f32, _format: ^char8, _flags: ImGuiSliderFlags);
__c__DragFloatRange2 :: (ret: ^mut bool, _label: ^char8, _v_current_min: ^mut f32, _v_current_max: ^mut f32, _v_speed: f32, _v_min: f32, _v_max: f32, _format: ^char8, _format_max: ^char8, _flags: ImGuiSliderFlags);
__c__DragInt :: (ret: ^mut bool, _label: ^char8, _v: ^mut i32, _v_speed: f32, _v_min: i32, _v_max: i32, _format: ^char8, _flags: ImGuiSliderFlags);
__c__DragInt2 :: (ret: ^mut bool, _label: ^char8, _v: ^mut i32, _v_speed: f32, _v_min: i32, _v_max: i32, _format: ^char8, _flags: ImGuiSliderFlags);
__c__DragInt3 :: (ret: ^mut bool, _label: ^char8, _v: ^mut i32, _v_speed: f32, _v_min: i32, _v_max: i32, _format: ^char8, _flags: ImGuiSliderFlags);
__c__DragInt4 :: (ret: ^mut bool, _label: ^char8, _v: ^mut i32, _v_speed: f32, _v_min: i32, _v_max: i32, _format: ^char8, _flags: ImGuiSliderFlags);
__c__DragIntRange2 :: (ret: ^mut bool, _label: ^char8, _v_current_min: ^mut i32, _v_current_max: ^mut i32, _v_speed: f32, _v_min: i32, _v_max: i32, _format: ^char8, _format_max: ^char8, _flags: ImGuiSliderFlags);
__c__DragScalar :: (ret: ^mut bool, _label: ^char8, _data_type: ImGuiDataType, _p_data: ^mut void, _v_speed: f32, _p_min: ^mut void, _p_max: ^mut void, _format: ^char8, _flags: ImGuiSliderFlags);
__c__DragScalarN :: (ret: ^mut bool, _label: ^char8, _data_type: ImGuiDataType, _p_data: ^mut void, _components: i32, _v_speed: f32, _p_min: ^mut void, _p_max: ^mut void, _format: ^char8, _flags: ImGuiSliderFlags);
__c__SliderFloat :: (ret: ^mut bool, _label: ^char8, _v: ^mut f32, _v_min: f32, _v_max: f32, _format: ^char8, _flags: ImGuiSliderFlags);
__c__SliderFloat2 :: (ret: ^mut bool, _label: ^char8, _v: ^mut f32, _v_min: f32, _v_max: f32, _format: ^char8, _flags: ImGuiSliderFlags);
__c__SliderFloat3 :: (ret: ^mut bool, _label: ^char8, _v: ^mut f32, _v_min: f32, _v_max: f32, _format: ^char8, _flags: ImGuiSliderFlags);
__c__SliderFloat4 :: (ret: ^mut bool, _label: ^char8, _v: ^mut f32, _v_min: f32, _v_max: f32, _format: ^char8, _flags: ImGuiSliderFlags);
__c__SliderAngle :: (ret: ^mut bool, _label: ^char8, _v_rad: ^mut f32, _v_degrees_min: f32, _v_degrees_max: f32, _format: ^char8, _flags: ImGuiSliderFlags);
__c__SliderInt :: (ret: ^mut bool, _label: ^char8, _v: ^mut i32, _v_min: i32, _v_max: i32, _format: ^char8, _flags: ImGuiSliderFlags);
__c__SliderInt2 :: (ret: ^mut bool, _label: ^char8, _v: ^mut i32, _v_min: i32, _v_max: i32, _format: ^char8, _flags: ImGuiSliderFlags);
__c__SliderInt3 :: (ret: ^mut bool, _label: ^char8, _v: ^mut i32, _v_min: i32, _v_max: i32, _format: ^char8, _flags: ImGuiSliderFlags);
__c__SliderInt4 :: (ret: ^mut bool, _label: ^char8, _v: ^mut i32, _v_min: i32, _v_max: i32, _format: ^char8, _flags: ImGuiSliderFlags);
__c__SliderScalar :: (ret: ^mut bool, _label: ^char8, _data_type: ImGuiDataType, _p_data: ^mut void, _p_min: ^mut void, _p_max: ^mut void, _format: ^char8, _flags: ImGuiSliderFlags);
__c__SliderScalarN :: (ret: ^mut bool, _label: ^char8, _data_type: ImGuiDataType, _p_data: ^mut void, _components: i32, _p_min: ^mut void, _p_max: ^mut void, _format: ^char8, _flags: ImGuiSliderFlags);
__c__VSliderFloat :: (ret: ^mut bool, _label: ^char8, _size: ^mut ImVec2, _v: ^mut f32, _v_min: f32, _v_max: f32, _format: ^char8, _flags: ImGuiSliderFlags);
__c__VSliderInt :: (ret: ^mut bool, _label: ^char8, _size: ^mut ImVec2, _v: ^mut i32, _v_min: i32, _v_max: i32, _format: ^char8, _flags: ImGuiSliderFlags);
__c__VSliderScalar :: (ret: ^mut bool, _label: ^char8, _size: ^mut ImVec2, _data_type: ImGuiDataType, _p_data: ^mut void, _p_min: ^mut void, _p_max: ^mut void, _format: ^char8, _flags: ImGuiSliderFlags);
__c__InputText :: (ret: ^mut bool, _label: ^char8, _buf: ^mut char8, _buf_size: size_t, _flags: ImGuiInputTextFlags, _callback: ImGuiInputTextCallback, _user_data: ^mut void);
__c__InputTextMultiline :: (ret: ^mut bool, _label: ^char8, _buf: ^mut char8, _buf_size: size_t, _size: ^mut ImVec2, _flags: ImGuiInputTextFlags, _callback: ImGuiInputTextCallback, _user_data: ^mut void);
__c__InputTextWithHint :: (ret: ^mut bool, _label: ^char8, _hint: ^char8, _buf: ^mut char8, _buf_size: size_t, _flags: ImGuiInputTextFlags, _callback: ImGuiInputTextCallback, _user_data: ^mut void);
__c__InputFloat :: (ret: ^mut bool, _label: ^char8, _v: ^mut f32, _step: f32, _step_fast: f32, _format: ^char8, _flags: ImGuiInputTextFlags);
__c__InputFloat2 :: (ret: ^mut bool, _label: ^char8, _v: ^mut f32, _format: ^char8, _flags: ImGuiInputTextFlags);
__c__InputFloat3 :: (ret: ^mut bool, _label: ^char8, _v: ^mut f32, _format: ^char8, _flags: ImGuiInputTextFlags);
__c__InputFloat4 :: (ret: ^mut bool, _label: ^char8, _v: ^mut f32, _format: ^char8, _flags: ImGuiInputTextFlags);
__c__InputInt :: (ret: ^mut bool, _label: ^char8, _v: ^mut i32, _step: i32, _step_fast: i32, _flags: ImGuiInputTextFlags);
__c__InputInt2 :: (ret: ^mut bool, _label: ^char8, _v: ^mut i32, _flags: ImGuiInputTextFlags);
__c__InputInt3 :: (ret: ^mut bool, _label: ^char8, _v: ^mut i32, _flags: ImGuiInputTextFlags);
__c__InputInt4 :: (ret: ^mut bool, _label: ^char8, _v: ^mut i32, _flags: ImGuiInputTextFlags);
__c__InputDouble :: (ret: ^mut bool, _label: ^char8, _v: ^mut f64, _step: f64, _step_fast: f64, _format: ^char8, _flags: ImGuiInputTextFlags);
__c__InputScalar :: (ret: ^mut bool, _label: ^char8, _data_type: ImGuiDataType, _p_data: ^mut void, _p_step: ^mut void, _p_step_fast: ^mut void, _format: ^char8, _flags: ImGuiInputTextFlags);
__c__InputScalarN :: (ret: ^mut bool, _label: ^char8, _data_type: ImGuiDataType, _p_data: ^mut void, _components: i32, _p_step: ^mut void, _p_step_fast: ^mut void, _format: ^char8, _flags: ImGuiInputTextFlags);
__c__ColorEdit3 :: (ret: ^mut bool, _label: ^char8, _col: ^mut f32, _flags: ImGuiColorEditFlags);
__c__ColorEdit4 :: (ret: ^mut bool, _label: ^char8, _col: ^mut f32, _flags: ImGuiColorEditFlags);
__c__ColorPicker3 :: (ret: ^mut bool, _label: ^char8, _col: ^mut f32, _flags: ImGuiColorEditFlags);
__c__ColorPicker4 :: (ret: ^mut bool, _label: ^char8, _col: ^mut f32, _flags: ImGuiColorEditFlags, _ref_col: ^f32);
__c__ColorButton :: (ret: ^mut bool, _desc_id: ^char8, _col: ^mut ImVec4, _flags: ImGuiColorEditFlags, _size: ^mut ImVec2);
__c__SetColorEditOptions :: (_flags: ImGuiColorEditFlags);
__c__TreeNode :: (ret: ^mut bool, _label: ^char8);
__c__TreeNode_2 :: (ret: ^mut bool, _str_id: ^char8, _fmt: ^char8);
__c__TreeNode_3 :: (ret: ^mut bool, _ptr_id: ^mut void, _fmt: ^char8);
__c__TreeNodeV :: (ret: ^mut bool, _str_id: ^char8, _fmt: ^char8, _args: va_list);
__c__TreeNodeV_2 :: (ret: ^mut bool, _ptr_id: ^mut void, _fmt: ^char8, _args: va_list);
__c__TreeNodeEx :: (ret: ^mut bool, _label: ^char8, _flags: ImGuiTreeNodeFlags);
__c__TreeNodeEx_2 :: (ret: ^mut bool, _str_id: ^char8, _flags: ImGuiTreeNodeFlags, _fmt: ^char8);
__c__TreeNodeEx_3 :: (ret: ^mut bool, _ptr_id: ^mut void, _flags: ImGuiTreeNodeFlags, _fmt: ^char8);
__c__TreeNodeExV :: (ret: ^mut bool, _str_id: ^char8, _flags: ImGuiTreeNodeFlags, _fmt: ^char8, _args: va_list);
__c__TreeNodeExV_2 :: (ret: ^mut bool, _ptr_id: ^mut void, _flags: ImGuiTreeNodeFlags, _fmt: ^char8, _args: va_list);
__c__TreePush :: (_str_id: ^char8);
__c__TreePush_2 :: (_ptr_id: ^mut void);
__c__TreePop :: ();
__c__GetTreeNodeToLabelSpacing :: (ret: ^mut f32);
__c__CollapsingHeader :: (ret: ^mut bool, _label: ^char8, _flags: ImGuiTreeNodeFlags);
__c__CollapsingHeader_2 :: (ret: ^mut bool, _label: ^char8, _p_open: ^mut bool, _flags: ImGuiTreeNodeFlags);
__c__SetNextItemOpen :: (_is_open: bool, _cond: ImGuiCond);
__c__Selectable :: (ret: ^mut bool, _label: ^char8, _selected: bool, _flags: ImGuiSelectableFlags, _size: ^mut ImVec2);
__c__Selectable_2 :: (ret: ^mut bool, _label: ^char8, _p_selected: ^mut bool, _flags: ImGuiSelectableFlags, _size: ^mut ImVec2);
__c__ListBox :: (ret: ^mut bool, _label: ^char8, _current_item: ^mut i32, _items: ^mut ^char8, _items_count: i32, _height_in_items: i32);
__c__ListBox_2 :: (ret: ^mut bool, _label: ^char8, _current_item: ^mut i32, _items_getter: fn(^mut void, i32, ^mut ^char8) -> bool, _data: ^mut void, _items_count: i32, _height_in_items: i32);
__c__ListBoxHeader :: (ret: ^mut bool, _label: ^char8, _size: ^mut ImVec2);
__c__ListBoxHeader_2 :: (ret: ^mut bool, _label: ^char8, _items_count: i32, _height_in_items: i32);
__c__ListBoxFooter :: ();
__c__PlotLines :: (_label: ^char8, _values: ^f32, _values_count: i32, _values_offset: i32, _overlay_text: ^char8, _scale_min: f32, _scale_max: f32, _graph_size: ^mut ImVec2, _stride: i32);
__c__PlotLines_2 :: (_label: ^char8, _values_getter: fn(^mut void, i32) -> f32, _data: ^mut void, _values_count: i32, _values_offset: i32, _overlay_text: ^char8, _scale_min: f32, _scale_max: f32, _graph_size: ^mut ImVec2);
__c__PlotHistogram :: (_label: ^char8, _values: ^f32, _values_count: i32, _values_offset: i32, _overlay_text: ^char8, _scale_min: f32, _scale_max: f32, _graph_size: ^mut ImVec2, _stride: i32);
__c__PlotHistogram_2 :: (_label: ^char8, _values_getter: fn(^mut void, i32) -> f32, _data: ^mut void, _values_count: i32, _values_offset: i32, _overlay_text: ^char8, _scale_min: f32, _scale_max: f32, _graph_size: ^mut ImVec2);
__c__Value :: (_prefix: ^char8, _b: bool);
__c__Value_2 :: (_prefix: ^char8, _v: i32);
__c__Value_3 :: (_prefix: ^char8, _v: u32);
__c__Value_4 :: (_prefix: ^char8, _v: f32, _float_format: ^char8);
__c__BeginMenuBar :: (ret: ^mut bool);
__c__EndMenuBar :: ();
__c__BeginMainMenuBar :: (ret: ^mut bool);
__c__EndMainMenuBar :: ();
__c__BeginMenu :: (ret: ^mut bool, _label: ^char8, _enabled: bool);
__c__EndMenu :: ();
__c__MenuItem :: (ret: ^mut bool, _label: ^char8, _shortcut: ^char8, _selected: bool, _enabled: bool);
__c__MenuItem_2 :: (ret: ^mut bool, _label: ^char8, _shortcut: ^char8, _p_selected: ^mut bool, _enabled: bool);
__c__BeginTooltip :: ();
__c__EndTooltip :: ();
__c__SetTooltip :: (_fmt: ^char8);
__c__SetTooltipV :: (_fmt: ^char8, _args: va_list);
__c__BeginPopup :: (ret: ^mut bool, _str_id: ^char8, _flags: ImGuiWindowFlags);
__c__BeginPopupModal :: (ret: ^mut bool, _name: ^char8, _p_open: ^mut bool, _flags: ImGuiWindowFlags);
__c__EndPopup :: ();
__c__OpenPopup :: (_str_id: ^char8, _popup_flags: ImGuiPopupFlags);
__c__OpenPopupContextItem :: (ret: ^mut bool, _str_id: ^char8, _popup_flags: ImGuiPopupFlags);
__c__CloseCurrentPopup :: ();
__c__BeginPopupContextItem :: (ret: ^mut bool, _str_id: ^char8, _popup_flags: ImGuiPopupFlags);
__c__BeginPopupContextWindow :: (ret: ^mut bool, _str_id: ^char8, _popup_flags: ImGuiPopupFlags);
__c__BeginPopupContextVoid :: (ret: ^mut bool, _str_id: ^char8, _popup_flags: ImGuiPopupFlags);
__c__IsPopupOpen :: (ret: ^mut bool, _str_id: ^char8, _flags: ImGuiPopupFlags);
__c__Columns :: (_count: i32, _id: ^char8, _border: bool);
__c__NextColumn :: ();
__c__GetColumnIndex :: (ret: ^mut i32);
__c__GetColumnWidth :: (ret: ^mut f32, _column_index: i32);
__c__SetColumnWidth :: (_column_index: i32, _width: f32);
__c__GetColumnOffset :: (ret: ^mut f32, _column_index: i32);
__c__SetColumnOffset :: (_column_index: i32, _offset_x: f32);
__c__GetColumnsCount :: (ret: ^mut i32);
__c__BeginTabBar :: (ret: ^mut bool, _str_id: ^char8, _flags: ImGuiTabBarFlags);
__c__EndTabBar :: ();
__c__BeginTabItem :: (ret: ^mut bool, _label: ^char8, _p_open: ^mut bool, _flags: ImGuiTabItemFlags);
__c__EndTabItem :: ();
__c__SetTabItemClosed :: (_tab_or_docked_window_label: ^char8);
__c__DockSpace :: (_id: ImGuiID, _size: ^mut ImVec2, _flags: ImGuiDockNodeFlags, _window_class: ^mut ImGuiWindowClass);
__c__DockSpaceOverViewport :: (ret: ^mut ImGuiID, _viewport: ^mut ImGuiViewport, _flags: ImGuiDockNodeFlags, _window_class: ^mut ImGuiWindowClass);
__c__SetNextWindowDockID :: (_dock_id: ImGuiID, _cond: ImGuiCond);
__c__SetNextWindowClass :: (_window_class: ^mut ImGuiWindowClass);
__c__GetWindowDockID :: (ret: ^mut ImGuiID);
__c__IsWindowDocked :: (ret: ^mut bool);
__c__LogToTTY :: (_auto_open_depth: i32);
__c__LogToFile :: (_auto_open_depth: i32, _filename: ^char8);
__c__LogToClipboard :: (_auto_open_depth: i32);
__c__LogFinish :: ();
__c__LogButtons :: ();
__c__LogText :: (_fmt: ^char8);
__c__BeginDragDropSource :: (ret: ^mut bool, _flags: ImGuiDragDropFlags);
__c__SetDragDropPayload :: (ret: ^mut bool, _type: ^char8, _data: ^mut void, _sz: size_t, _cond: ImGuiCond);
__c__EndDragDropSource :: ();
__c__BeginDragDropTarget :: (ret: ^mut bool);
__c__AcceptDragDropPayload :: (ret: ^mut ^mut ImGuiPayload, _type: ^char8, _flags: ImGuiDragDropFlags);
__c__EndDragDropTarget :: ();
__c__GetDragDropPayload :: (ret: ^mut ^mut ImGuiPayload);
__c__PushClipRect :: (_clip_rect_min: ^mut ImVec2, _clip_rect_max: ^mut ImVec2, _intersect_with_current_clip_rect: bool);
__c__PopClipRect :: ();
__c__SetItemDefaultFocus :: ();
__c__SetKeyboardFocusHere :: (_offset: i32);
__c__IsItemHovered :: (ret: ^mut bool, _flags: ImGuiHoveredFlags);
__c__IsItemActive :: (ret: ^mut bool);
__c__IsItemFocused :: (ret: ^mut bool);
__c__IsItemClicked :: (ret: ^mut bool, _mouse_button: ImGuiMouseButton);
__c__IsItemVisible :: (ret: ^mut bool);
__c__IsItemEdited :: (ret: ^mut bool);
__c__IsItemActivated :: (ret: ^mut bool);
__c__IsItemDeactivated :: (ret: ^mut bool);
__c__IsItemDeactivatedAfterEdit :: (ret: ^mut bool);
__c__IsItemToggledOpen :: (ret: ^mut bool);
__c__IsAnyItemHovered :: (ret: ^mut bool);
__c__IsAnyItemActive :: (ret: ^mut bool);
__c__IsAnyItemFocused :: (ret: ^mut bool);
__c__GetItemRectMin :: (ret: ^mut ImVec2);
__c__GetItemRectMax :: (ret: ^mut ImVec2);
__c__GetItemRectSize :: (ret: ^mut ImVec2);
__c__SetItemAllowOverlap :: ();
__c__IsRectVisible :: (ret: ^mut bool, _size: ^mut ImVec2);
__c__IsRectVisible_2 :: (ret: ^mut bool, _rect_min: ^mut ImVec2, _rect_max: ^mut ImVec2);
__c__GetTime :: (ret: ^mut f64);
__c__GetFrameCount :: (ret: ^mut i32);
__c__GetBackgroundDrawList :: (ret: ^mut ^mut ImDrawList);
__c__GetForegroundDrawList :: (ret: ^mut ^mut ImDrawList);
__c__GetBackgroundDrawList_2 :: (ret: ^mut ^mut ImDrawList, _viewport: ^mut ImGuiViewport);
__c__GetForegroundDrawList_2 :: (ret: ^mut ^mut ImDrawList, _viewport: ^mut ImGuiViewport);
__c__GetDrawListSharedData :: (ret: ^mut ^mut ImDrawListSharedData);
__c__GetStyleColorName :: (ret: ^mut ^char8, _idx: ImGuiCol);
__c__SetStateStorage :: (_storage: ^mut ImGuiStorage);
__c__GetStateStorage :: (ret: ^mut ^mut ImGuiStorage);
__c__CalcListClipping :: (_items_count: i32, _items_height: f32, _out_items_display_start: ^mut i32, _out_items_display_end: ^mut i32);
__c__BeginChildFrame :: (ret: ^mut bool, _id: ImGuiID, _size: ^mut ImVec2, _flags: ImGuiWindowFlags);
__c__EndChildFrame :: ();
__c__CalcTextSize :: (ret: ^mut ImVec2, _text: ^char8, _text_end: ^char8, _hide_text_after_double_hash: bool, _wrap_width: f32);
__c__ColorConvertU32ToFloat4 :: (ret: ^mut ImVec4, _in: ImU32);
__c__ColorConvertFloat4ToU32 :: (ret: ^mut ImU32, _in: ^mut ImVec4);
__c__ColorConvertRGBtoHSV :: (_r: f32, _g: f32, _b: f32, _out_h: ^mut f32, _out_s: ^mut f32, _out_v: ^mut f32);
__c__ColorConvertHSVtoRGB :: (_h: f32, _s: f32, _v: f32, _out_r: ^mut f32, _out_g: ^mut f32, _out_b: ^mut f32);
__c__GetKeyIndex :: (ret: ^mut i32, _imgui_key: ImGuiKey);
__c__IsKeyDown :: (ret: ^mut bool, _user_key_index: i32);
__c__IsKeyPressed :: (ret: ^mut bool, _user_key_index: i32, _repeat: bool);
__c__IsKeyReleased :: (ret: ^mut bool, _user_key_index: i32);
__c__GetKeyPressedAmount :: (ret: ^mut i32, _key_index: i32, _repeat_delay: f32, _rate: f32);
__c__CaptureKeyboardFromApp :: (_want_capture_keyboard_value: bool);
__c__IsMouseDown :: (ret: ^mut bool, _button: ImGuiMouseButton);
__c__IsMouseClicked :: (ret: ^mut bool, _button: ImGuiMouseButton, _repeat: bool);
__c__IsMouseReleased :: (ret: ^mut bool, _button: ImGuiMouseButton);
__c__IsMouseDoubleClicked :: (ret: ^mut bool, _button: ImGuiMouseButton);
__c__IsMouseHoveringRect :: (ret: ^mut bool, _r_min: ^mut ImVec2, _r_max: ^mut ImVec2, _clip: bool);
__c__IsMousePosValid :: (ret: ^mut bool, _mouse_pos: ^mut ImVec2);
__c__IsAnyMouseDown :: (ret: ^mut bool);
__c__GetMousePos :: (ret: ^mut ImVec2);
__c__GetMousePosOnOpeningCurrentPopup :: (ret: ^mut ImVec2);
__c__IsMouseDragging :: (ret: ^mut bool, _button: ImGuiMouseButton, _lock_threshold: f32);
__c__GetMouseDragDelta :: (ret: ^mut ImVec2, _button: ImGuiMouseButton, _lock_threshold: f32);
__c__ResetMouseDragDelta :: (_button: ImGuiMouseButton);
__c__GetMouseCursor :: (ret: ^mut ImGuiMouseCursor);
__c__SetMouseCursor :: (_cursor_type: ImGuiMouseCursor);
__c__CaptureMouseFromApp :: (_want_capture_mouse_value: bool);
__c__GetClipboardText :: (ret: ^mut ^char8);
__c__SetClipboardText :: (_text: ^char8);
__c__LoadIniSettingsFromDisk :: (_ini_filename: ^char8);
__c__LoadIniSettingsFromMemory :: (_ini_data: ^char8, _ini_size: size_t);
__c__SaveIniSettingsToDisk :: (_ini_filename: ^char8);
__c__SaveIniSettingsToMemory :: (ret: ^mut ^char8, _out_ini_size: ^mut size_t);
__c__DebugCheckVersionAndDataLayout :: (ret: ^mut bool, _version_str: ^char8, _sz_io: size_t, _sz_style: size_t, _sz_vec2: size_t, _sz_vec4: size_t, _sz_drawvert: size_t, _sz_drawidx: size_t);
__c__SetAllocatorFunctions :: (_alloc_func: fn(size_t, ^mut void) -> ^mut void, _free_func: fn(^mut void, ^mut void) -> void, _user_data: ^mut void);
__c__MemAlloc :: (ret: ^mut ^mut void, _size: size_t);
__c__MemFree :: (_ptr: ^mut void);
__c__GetPlatformIO :: (ret: ^mut ^mut ImGuiPlatformIO);
__c__GetMainViewport :: (ret: ^mut ^mut ImGuiViewport);
__c__UpdatePlatformWindows :: ();
__c__RenderPlatformWindowsDefault :: (_platform_render_arg: ^mut void, _renderer_render_arg: ^mut void);
__c__DestroyPlatformWindows :: ();
__c__FindViewportByID :: (ret: ^mut ^mut ImGuiViewport, _id: ImGuiID);
__c__FindViewportByPlatformHandle :: (ret: ^mut ^mut ImGuiViewport, _platform_handle: ^mut void);
__c__DragScalar_2 :: (ret: ^mut bool, _label: ^char8, _data_type: ImGuiDataType, _p_data: ^mut void, _v_speed: f32, _p_min: ^mut void, _p_max: ^mut void, _format: ^char8, _power: f32);
__c__DragScalarN_2 :: (ret: ^mut bool, _label: ^char8, _data_type: ImGuiDataType, _p_data: ^mut void, _components: i32, _v_speed: f32, _p_min: ^mut void, _p_max: ^mut void, _format: ^char8, _power: f32);
__c__SliderScalar_2 :: (ret: ^mut bool, _label: ^char8, _data_type: ImGuiDataType, _p_data: ^mut void, _p_min: ^mut void, _p_max: ^mut void, _format: ^char8, _power: f32);
__c__SliderScalarN_2 :: (ret: ^mut bool, _label: ^char8, _data_type: ImGuiDataType, _p_data: ^mut void, _components: i32, _p_min: ^mut void, _p_max: ^mut void, _format: ^char8, _power: f32);
__c__InputFloat_2 :: (ret: ^mut bool, _label: ^char8, _v: ^mut f32, _step: f32, _step_fast: f32, _decimal_precision: i32, _flags: ImGuiInputTextFlags);
__c__InputFloat2_2 :: (ret: ^mut bool, _label: ^char8, _v: ^mut f32, _decimal_precision: i32, _flags: ImGuiInputTextFlags);
__c__InputFloat3_2 :: (ret: ^mut bool, _label: ^char8, _v: ^mut f32, _decimal_precision: i32, _flags: ImGuiInputTextFlags);
__c__InputFloat4_2 :: (ret: ^mut bool, _label: ^char8, _v: ^mut f32, _decimal_precision: i32, _flags: ImGuiInputTextFlags);
__c__ImHashData :: (ret: ^mut ImU32, _data: ^mut void, _data_size: size_t, _seed: ImU32);
__c__ImHashStr :: (ret: ^mut ImU32, _data: ^char8, _data_size: size_t, _seed: ImU32);
__c__ImAlphaBlendColors :: (ret: ^mut ImU32, _col_a: ImU32, _col_b: ImU32);
__c__ImStricmp :: (ret: ^mut i32, _str1: ^char8, _str2: ^char8);
__c__ImStrnicmp :: (ret: ^mut i32, _str1: ^char8, _str2: ^char8, _count: size_t);
__c__ImStrncpy :: (_dst: ^mut char8, _src: ^char8, _count: size_t);
__c__ImStrdup :: (ret: ^mut ^mut char8, _str: ^char8);
__c__ImStrdupcpy :: (ret: ^mut ^mut char8, _dst: ^mut char8, _p_dst_size: ^mut size_t, _str: ^char8);
__c__ImStrchrRange :: (ret: ^mut ^char8, _str_begin: ^char8, _str_end: ^char8, _c: char8);
__c__ImStrlenW :: (ret: ^mut i32, _str: ^mut ImWchar);
__c__ImStreolRange :: (ret: ^mut ^char8, _str: ^char8, _str_end: ^char8);
__c__ImStrbolW :: (ret: ^mut ^mut ImWchar, _buf_mid_line: ^mut ImWchar, _buf_begin: ^mut ImWchar);
__c__ImStristr :: (ret: ^mut ^char8, _haystack: ^char8, _haystack_end: ^char8, _needle: ^char8, _needle_end: ^char8);
__c__ImStrTrimBlanks :: (_str: ^mut char8);
__c__ImStrSkipBlank :: (ret: ^mut ^char8, _str: ^char8);
__c__ImFormatString :: (ret: ^mut i32, _buf: ^mut char8, _buf_size: size_t, _fmt: ^char8);
__c__ImFormatStringV :: (ret: ^mut i32, _buf: ^mut char8, _buf_size: size_t, _fmt: ^char8, _args: va_list);
__c__ImParseFormatFindStart :: (ret: ^mut ^char8, _format: ^char8);
__c__ImParseFormatFindEnd :: (ret: ^mut ^char8, _format: ^char8);
__c__ImParseFormatTrimDecorations :: (ret: ^mut ^char8, _format: ^char8, _buf: ^mut char8, _buf_size: size_t);
__c__ImParseFormatPrecision :: (ret: ^mut i32, _format: ^char8, _default_value: i32);
__c__ImTextStrToUtf8 :: (ret: ^mut i32, _buf: ^mut char8, _buf_size: i32, _in_text: ^mut ImWchar, _in_text_end: ^mut ImWchar);
__c__ImTextCharFromUtf8 :: (ret: ^mut i32, _out_char: ^mut u32, _in_text: ^char8, _in_text_end: ^char8);
__c__ImTextStrFromUtf8 :: (ret: ^mut i32, _buf: ^mut ImWchar, _buf_size: i32, _in_text: ^char8, _in_text_end: ^char8, _in_remaining: ^mut ^char8);
__c__ImTextCountCharsFromUtf8 :: (ret: ^mut i32, _in_text: ^char8, _in_text_end: ^char8);
__c__ImTextCountUtf8BytesFromChar :: (ret: ^mut i32, _in_text: ^char8, _in_text_end: ^char8);
__c__ImTextCountUtf8BytesFromStr :: (ret: ^mut i32, _in_text: ^mut ImWchar, _in_text_end: ^mut ImWchar);
__c__ImFileOpen :: (ret: ^mut ImFileHandle, _filename: ^char8, _mode: ^char8);
__c__ImFileClose :: (ret: ^mut bool, _file: ImFileHandle);
__c__ImFileGetSize :: (ret: ^mut ImU64, _file: ImFileHandle);
__c__ImFileRead :: (ret: ^mut ImU64, _data: ^mut void, _size: ImU64, _count: ImU64, _file: ImFileHandle);
__c__ImFileWrite :: (ret: ^mut ImU64, _data: ^mut void, _size: ImU64, _count: ImU64, _file: ImFileHandle);
__c__ImFileLoadToMemory :: (ret: ^mut ^mut void, _filename: ^char8, _mode: ^char8, _out_file_size: ^mut size_t, _padding_bytes: i32);
__c__ImBezierCalc :: (ret: ^mut ImVec2, _p1: ^mut ImVec2, _p2: ^mut ImVec2, _p3: ^mut ImVec2, _p4: ^mut ImVec2, _t: f32);
__c__ImBezierClosestPoint :: (ret: ^mut ImVec2, _p1: ^mut ImVec2, _p2: ^mut ImVec2, _p3: ^mut ImVec2, _p4: ^mut ImVec2, _p: ^mut ImVec2, _num_segments: i32);
__c__ImBezierClosestPointCasteljau :: (ret: ^mut ImVec2, _p1: ^mut ImVec2, _p2: ^mut ImVec2, _p3: ^mut ImVec2, _p4: ^mut ImVec2, _p: ^mut ImVec2, _tess_tol: f32);
__c__ImLineClosestPoint :: (ret: ^mut ImVec2, _a: ^mut ImVec2, _b: ^mut ImVec2, _p: ^mut ImVec2);
__c__ImTriangleContainsPoint :: (ret: ^mut bool, _a: ^mut ImVec2, _b: ^mut ImVec2, _c: ^mut ImVec2, _p: ^mut ImVec2);
__c__ImTriangleClosestPoint :: (ret: ^mut ImVec2, _a: ^mut ImVec2, _b: ^mut ImVec2, _c: ^mut ImVec2, _p: ^mut ImVec2);
__c__ImTriangleBarycentricCoords :: (_a: ^mut ImVec2, _b: ^mut ImVec2, _c: ^mut ImVec2, _p: ^mut ImVec2, _out_u: ^mut f32, _out_v: ^mut f32, _out_w: ^mut f32);
__c__ImGetDirQuadrantFromDelta :: (ret: ^mut ImGuiDir, _dx: f32, _dy: f32);
__c__FindWindowByID :: (ret: ^mut ^mut ImGuiWindow, _id: ImGuiID);
__c__FindWindowByName :: (ret: ^mut ^mut ImGuiWindow, _name: ^char8);
__c__UpdateWindowParentAndRootLinks :: (_window: ^mut ImGuiWindow, _flags: ImGuiWindowFlags, _parent_window: ^mut ImGuiWindow);
__c__CalcWindowExpectedSize :: (ret: ^mut ImVec2, _window: ^mut ImGuiWindow);
__c__IsWindowChildOf :: (ret: ^mut bool, _window: ^mut ImGuiWindow, _potential_parent: ^mut ImGuiWindow);
__c__IsWindowNavFocusable :: (ret: ^mut bool, _window: ^mut ImGuiWindow);
__c__GetWindowAllowedExtentRect :: (ret: ^mut ImRect, _window: ^mut ImGuiWindow);
__c__SetWindowPos_3 :: (_window: ^mut ImGuiWindow, _pos: ^mut ImVec2, _cond: ImGuiCond);
__c__SetWindowSize_3 :: (_window: ^mut ImGuiWindow, _size: ^mut ImVec2, _cond: ImGuiCond);
__c__SetWindowCollapsed_3 :: (_window: ^mut ImGuiWindow, _collapsed: bool, _cond: ImGuiCond);
__c__SetWindowHitTestHole :: (_window: ^mut ImGuiWindow, _pos: ^mut ImVec2, _size: ^mut ImVec2);
__c__FocusWindow :: (_window: ^mut ImGuiWindow);
__c__FocusTopMostWindowUnderOne :: (_under_this_window: ^mut ImGuiWindow, _ignore_window: ^mut ImGuiWindow);
__c__BringWindowToFocusFront :: (_window: ^mut ImGuiWindow);
__c__BringWindowToDisplayFront :: (_window: ^mut ImGuiWindow);
__c__BringWindowToDisplayBack :: (_window: ^mut ImGuiWindow);
__c__SetCurrentFont :: (_font: ^mut ImFont);
__c__Initialize :: (_context: ^mut ImGuiContext);
__c__Shutdown :: (_context: ^mut ImGuiContext);
__c__UpdateHoveredWindowAndCaptureFlags :: ();
__c__StartMouseMovingWindow :: (_window: ^mut ImGuiWindow);
__c__StartMouseMovingWindowOrNode :: (_window: ^mut ImGuiWindow, _node: ^mut ImGuiDockNode, _undock_floating_node: bool);
__c__UpdateMouseMovingWindowNewFrame :: ();
__c__UpdateMouseMovingWindowEndFrame :: ();
__c__TranslateWindowsInViewport :: (_viewport: ^mut ImGuiViewportP, _old_pos: ^mut ImVec2, _new_pos: ^mut ImVec2);
__c__ScaleWindowsInViewport :: (_viewport: ^mut ImGuiViewportP, _scale: f32);
__c__DestroyPlatformWindow :: (_viewport: ^mut ImGuiViewportP);
__c__ShowViewportThumbnails :: ();
__c__MarkIniSettingsDirty :: ();
__c__MarkIniSettingsDirty_2 :: (_window: ^mut ImGuiWindow);
__c__ClearIniSettings :: ();
__c__CreateNewWindowSettings :: (ret: ^mut ^mut ImGuiWindowSettings, _name: ^char8);
__c__FindWindowSettings :: (ret: ^mut ^mut ImGuiWindowSettings, _id: ImGuiID);
__c__FindOrCreateWindowSettings :: (ret: ^mut ^mut ImGuiWindowSettings, _name: ^char8);
__c__FindSettingsHandler :: (ret: ^mut ^mut ImGuiSettingsHandler, _type_name: ^char8);
__c__SetNextWindowScroll :: (_scroll: ^mut ImVec2);
__c__SetScrollX_2 :: (_window: ^mut ImGuiWindow, _scroll_x: f32);
__c__SetScrollY_2 :: (_window: ^mut ImGuiWindow, _scroll_y: f32);
__c__SetScrollFromPosX_2 :: (_window: ^mut ImGuiWindow, _local_x: f32, _center_x_ratio: f32);
__c__SetScrollFromPosY_2 :: (_window: ^mut ImGuiWindow, _local_y: f32, _center_y_ratio: f32);
__c__ScrollToBringRectIntoView :: (ret: ^mut ImVec2, _window: ^mut ImGuiWindow, _item_rect: ^mut ImRect);
__c__SetActiveID :: (_id: ImGuiID, _window: ^mut ImGuiWindow);
__c__SetFocusID :: (_id: ImGuiID, _window: ^mut ImGuiWindow);
__c__ClearActiveID :: ();
__c__GetHoveredID :: (ret: ^mut ImGuiID);
__c__SetHoveredID :: (_id: ImGuiID);
__c__KeepAliveID :: (_id: ImGuiID);
__c__MarkItemEdited :: (_id: ImGuiID);
__c__PushOverrideID :: (_id: ImGuiID);
__c__ItemSize :: (_size: ^mut ImVec2, _text_baseline_y: f32);
__c__ItemSize_2 :: (_bb: ^mut ImRect, _text_baseline_y: f32);
__c__ItemAdd :: (ret: ^mut bool, _bb: ^mut ImRect, _id: ImGuiID, _nav_bb: ^mut ImRect);
__c__ItemHoverable :: (ret: ^mut bool, _bb: ^mut ImRect, _id: ImGuiID);
__c__IsClippedEx :: (ret: ^mut bool, _bb: ^mut ImRect, _id: ImGuiID, _clip_even_when_logged: bool);
__c__SetLastItemData :: (_window: ^mut ImGuiWindow, _item_id: ImGuiID, _status_flags: ImGuiItemStatusFlags, _item_rect: ^mut ImRect);
__c__FocusableItemRegister :: (ret: ^mut bool, _window: ^mut ImGuiWindow, _id: ImGuiID);
__c__FocusableItemUnregister :: (_window: ^mut ImGuiWindow);
__c__CalcItemSize :: (ret: ^mut ImVec2, _size: ^mut ImVec2, _default_w: f32, _default_h: f32);
__c__CalcWrapWidthForPos :: (ret: ^mut f32, _pos: ^mut ImVec2, _wrap_pos_x: f32);
__c__PushMultiItemsWidths :: (_components: i32, _width_full: f32);
__c__PushItemFlag :: (_option: ImGuiItemFlags, _enabled: bool);
__c__PopItemFlag :: ();
__c__IsItemToggledSelection :: (ret: ^mut bool);
__c__GetContentRegionMaxAbs :: (ret: ^mut ImVec2);
__c__ShrinkWidths :: (_items: ^mut ImGuiShrinkWidthItem, _count: i32, _width_excess: f32);
__c__LogBegin :: (_type: ImGuiLogType, _auto_open_depth: i32);
__c__LogToBuffer :: (_auto_open_depth: i32);
__c__BeginChildEx :: (ret: ^mut bool, _name: ^char8, _id: ImGuiID, _size_arg: ^mut ImVec2, _border: bool, _flags: ImGuiWindowFlags);
__c__OpenPopupEx :: (_id: ImGuiID, _popup_flags: ImGuiPopupFlags);
__c__ClosePopupToLevel :: (_remaining: i32, _restore_focus_to_window_under_popup: bool);
__c__ClosePopupsOverWindow :: (_ref_window: ^mut ImGuiWindow, _restore_focus_to_window_under_popup: bool);
__c__IsPopupOpen_2 :: (ret: ^mut bool, _id: ImGuiID, _popup_flags: ImGuiPopupFlags);
__c__BeginPopupEx :: (ret: ^mut bool, _id: ImGuiID, _extra_flags: ImGuiWindowFlags);
__c__BeginTooltipEx :: (_extra_flags: ImGuiWindowFlags, _tooltip_flags: ImGuiTooltipFlags);
__c__GetTopMostPopupModal :: (ret: ^mut ^mut ImGuiWindow);
__c__FindBestWindowPosForPopup :: (ret: ^mut ImVec2, _window: ^mut ImGuiWindow);
__c__FindBestWindowPosForPopupEx :: (ret: ^mut ImVec2, _ref_pos: ^mut ImVec2, _size: ^mut ImVec2, _last_dir: ^mut ImGuiDir, _r_outer: ^mut ImRect, _r_avoid: ^mut ImRect, _policy: ImGuiPopupPositionPolicy);
__c__NavInitWindow :: (_window: ^mut ImGuiWindow, _force_reinit: bool);
__c__NavMoveRequestButNoResultYet :: (ret: ^mut bool);
__c__NavMoveRequestCancel :: ();
__c__NavMoveRequestForward :: (_move_dir: ImGuiDir, _clip_dir: ImGuiDir, _bb_rel: ^mut ImRect, _move_flags: ImGuiNavMoveFlags);
__c__NavMoveRequestTryWrapping :: (_window: ^mut ImGuiWindow, _move_flags: ImGuiNavMoveFlags);
__c__GetNavInputAmount :: (ret: ^mut f32, _n: ImGuiNavInput, _mode: ImGuiInputReadMode);
__c__GetNavInputAmount2d :: (ret: ^mut ImVec2, _dir_sources: ImGuiNavDirSourceFlags, _mode: ImGuiInputReadMode, _slow_factor: f32, _fast_factor: f32);
__c__CalcTypematicRepeatAmount :: (ret: ^mut i32, _t0: f32, _t1: f32, _repeat_delay: f32, _repeat_rate: f32);
__c__ActivateItem :: (_id: ImGuiID);
__c__SetNavID :: (_id: ImGuiID, _nav_layer: i32, _focus_scope_id: ImGuiID);
__c__SetNavIDWithRectRel :: (_id: ImGuiID, _nav_layer: i32, _focus_scope_id: ImGuiID, _rect_rel: ^mut ImRect);
__c__PushFocusScope :: (_id: ImGuiID);
__c__PopFocusScope :: ();
__c__IsMouseDragPastThreshold :: (ret: ^mut bool, _button: ImGuiMouseButton, _lock_threshold: f32);
__c__GetMergedKeyModFlags :: (ret: ^mut ImGuiKeyModFlags);
__c__DockContextInitialize :: (_ctx: ^mut ImGuiContext);
__c__DockContextShutdown :: (_ctx: ^mut ImGuiContext);
__c__DockContextClearNodes :: (_ctx: ^mut ImGuiContext, _root_id: ImGuiID, _clear_settings_refs: bool);
__c__DockContextRebuildNodes :: (_ctx: ^mut ImGuiContext);
__c__DockContextUpdateUndocking :: (_ctx: ^mut ImGuiContext);
__c__DockContextUpdateDocking :: (_ctx: ^mut ImGuiContext);
__c__DockContextGenNodeID :: (ret: ^mut ImGuiID, _ctx: ^mut ImGuiContext);
__c__DockContextQueueDock :: (_ctx: ^mut ImGuiContext, _target: ^mut ImGuiWindow, _target_node: ^mut ImGuiDockNode, _payload: ^mut ImGuiWindow, _split_dir: ImGuiDir, _split_ratio: f32, _split_outer: bool);
__c__DockContextQueueUndockWindow :: (_ctx: ^mut ImGuiContext, _window: ^mut ImGuiWindow);
__c__DockContextQueueUndockNode :: (_ctx: ^mut ImGuiContext, _node: ^mut ImGuiDockNode);
__c__DockContextCalcDropPosForDocking :: (ret: ^mut bool, _target: ^mut ImGuiWindow, _target_node: ^mut ImGuiDockNode, _payload: ^mut ImGuiWindow, _split_dir: ImGuiDir, _split_outer: bool, _out_pos: ^mut ImVec2);
__c__GetWindowAlwaysWantOwnTabBar :: (ret: ^mut bool, _window: ^mut ImGuiWindow);
__c__BeginDocked :: (_window: ^mut ImGuiWindow, _p_open: ^mut bool);
__c__BeginDockableDragDropSource :: (_window: ^mut ImGuiWindow);
__c__BeginDockableDragDropTarget :: (_window: ^mut ImGuiWindow);
__c__SetWindowDock :: (_window: ^mut ImGuiWindow, _dock_id: ImGuiID, _cond: ImGuiCond);
__c__DockBuilderDockWindow :: (_window_name: ^char8, _node_id: ImGuiID);
__c__DockBuilderGetNode :: (ret: ^mut ^mut ImGuiDockNode, _node_id: ImGuiID);
__c__DockBuilderAddNode :: (ret: ^mut ImGuiID, _node_id: ImGuiID, _flags: ImGuiDockNodeFlags);
__c__DockBuilderRemoveNode :: (_node_id: ImGuiID);
__c__DockBuilderRemoveNodeDockedWindows :: (_node_id: ImGuiID, _clear_settings_refs: bool);
__c__DockBuilderRemoveNodeChildNodes :: (_node_id: ImGuiID);
__c__DockBuilderSetNodePos :: (_node_id: ImGuiID, _pos: ^mut ImVec2);
__c__DockBuilderSetNodeSize :: (_node_id: ImGuiID, _size: ^mut ImVec2);
__c__DockBuilderSplitNode :: (ret: ^mut ImGuiID, _node_id: ImGuiID, _split_dir: ImGuiDir, _size_ratio_for_node_at_dir: f32, _out_id_at_dir: ^mut ImGuiID, _out_id_at_opposite_dir: ^mut ImGuiID);
__c__DockBuilderCopyDockSpace :: (_src_dockspace_id: ImGuiID, _dst_dockspace_id: ImGuiID, _in_window_remap_pairs: ^mut __UNKNOWN_0);
__c__DockBuilderCopyNode :: (_src_node_id: ImGuiID, _dst_node_id: ImGuiID, _out_node_remap_pairs: ^mut __UNKNOWN_16);
__c__DockBuilderCopyWindowSettings :: (_src_name: ^char8, _dst_name: ^char8);
__c__DockBuilderFinish :: (_node_id: ImGuiID);
__c__BeginDragDropTargetCustom :: (ret: ^mut bool, _bb: ^mut ImRect, _id: ImGuiID);
__c__ClearDragDrop :: ();
__c__IsDragDropPayloadBeingAccepted :: (ret: ^mut bool);
__c__SetWindowClipRectBeforeSetChannel :: (_window: ^mut ImGuiWindow, _clip_rect: ^mut ImRect);
__c__BeginColumns :: (_str_id: ^char8, _count: i32, _flags: ImGuiColumnsFlags);
__c__EndColumns :: ();
__c__PushColumnClipRect :: (_column_index: i32);
__c__PushColumnsBackground :: ();
__c__PopColumnsBackground :: ();
__c__GetColumnsID :: (ret: ^mut ImGuiID, _str_id: ^char8, _count: i32);
__c__FindOrCreateColumns :: (ret: ^mut ^mut ImGuiColumns, _window: ^mut ImGuiWindow, _id: ImGuiID);
__c__GetColumnOffsetFromNorm :: (ret: ^mut f32, _columns: ^mut ImGuiColumns, _offset_norm: f32);
__c__GetColumnNormFromOffset :: (ret: ^mut f32, _columns: ^mut ImGuiColumns, _offset: f32);
__c__BeginTabBarEx :: (ret: ^mut bool, _tab_bar: ^mut ImGuiTabBar, _bb: ^mut ImRect, _flags: ImGuiTabBarFlags, _dock_node: ^mut ImGuiDockNode);
__c__TabBarFindTabByID :: (ret: ^mut ^mut ImGuiTabItem, _tab_bar: ^mut ImGuiTabBar, _tab_id: ImGuiID);
__c__TabBarFindMostRecentlySelectedTabForActiveWindow :: (ret: ^mut ^mut ImGuiTabItem, _tab_bar: ^mut ImGuiTabBar);
__c__TabBarAddTab :: (_tab_bar: ^mut ImGuiTabBar, _tab_flags: ImGuiTabItemFlags, _window: ^mut ImGuiWindow);
__c__TabBarRemoveTab :: (_tab_bar: ^mut ImGuiTabBar, _tab_id: ImGuiID);
__c__TabBarCloseTab :: (_tab_bar: ^mut ImGuiTabBar, _tab: ^mut ImGuiTabItem);
__c__TabBarQueueReorder :: (_tab_bar: ^mut ImGuiTabBar, _tab: ^mut ImGuiTabItem, _dir: i32);
__c__TabBarProcessReorder :: (ret: ^mut bool, _tab_bar: ^mut ImGuiTabBar);
__c__TabItemEx :: (ret: ^mut bool, _tab_bar: ^mut ImGuiTabBar, _label: ^char8, _p_open: ^mut bool, _flags: ImGuiTabItemFlags, _docked_window: ^mut ImGuiWindow);
__c__TabItemCalcSize :: (ret: ^mut ImVec2, _label: ^char8, _has_close_button: bool);
__c__TabItemBackground :: (_draw_list: ^mut ImDrawList, _bb: ^mut ImRect, _flags: ImGuiTabItemFlags, _col: ImU32);
__c__TabItemLabelAndCloseButton :: (ret: ^mut bool, _draw_list: ^mut ImDrawList, _bb: ^mut ImRect, _flags: ImGuiTabItemFlags, _frame_padding: ^mut ImVec2, _label: ^char8, _tab_id: ImGuiID, _close_button_id: ImGuiID, _is_contents_visible: bool);
__c__RenderText :: (_pos: ^mut ImVec2, _text: ^char8, _text_end: ^char8, _hide_text_after_hash: bool);
__c__RenderTextWrapped :: (_pos: ^mut ImVec2, _text: ^char8, _text_end: ^char8, _wrap_width: f32);
__c__RenderTextClipped :: (_pos_min: ^mut ImVec2, _pos_max: ^mut ImVec2, _text: ^char8, _text_end: ^char8, _text_size_if_known: ^mut ImVec2, _align: ^mut ImVec2, _clip_rect: ^mut ImRect);
__c__RenderTextClippedEx :: (_draw_list: ^mut ImDrawList, _pos_min: ^mut ImVec2, _pos_max: ^mut ImVec2, _text: ^char8, _text_end: ^char8, _text_size_if_known: ^mut ImVec2, _align: ^mut ImVec2, _clip_rect: ^mut ImRect);
__c__RenderTextEllipsis :: (_draw_list: ^mut ImDrawList, _pos_min: ^mut ImVec2, _pos_max: ^mut ImVec2, _clip_max_x: f32, _ellipsis_max_x: f32, _text: ^char8, _text_end: ^char8, _text_size_if_known: ^mut ImVec2);
__c__RenderFrame :: (_p_min: ^mut ImVec2, _p_max: ^mut ImVec2, _fill_col: ImU32, _border: bool, _rounding: f32);
__c__RenderFrameBorder :: (_p_min: ^mut ImVec2, _p_max: ^mut ImVec2, _rounding: f32);
__c__RenderColorRectWithAlphaCheckerboard :: (_draw_list: ^mut ImDrawList, _p_min: ^mut ImVec2, _p_max: ^mut ImVec2, _fill_col: ImU32, _grid_step: f32, _grid_off: ^mut ImVec2, _rounding: f32, _rounding_corners_flags: i32);
__c__RenderNavHighlight :: (_bb: ^mut ImRect, _id: ImGuiID, _flags: ImGuiNavHighlightFlags);
__c__FindRenderedTextEnd :: (ret: ^mut ^char8, _text: ^char8, _text_end: ^char8);
__c__LogRenderedText :: (_ref_pos: ^mut ImVec2, _text: ^char8, _text_end: ^char8);
__c__RenderArrow :: (_draw_list: ^mut ImDrawList, _pos: ^mut ImVec2, _col: ImU32, _dir: ImGuiDir, _scale: f32);
__c__RenderBullet :: (_draw_list: ^mut ImDrawList, _pos: ^mut ImVec2, _col: ImU32);
__c__RenderCheckMark :: (_draw_list: ^mut ImDrawList, _pos: ^mut ImVec2, _col: ImU32, _sz: f32);
__c__RenderMouseCursor :: (_draw_list: ^mut ImDrawList, _pos: ^mut ImVec2, _scale: f32, _mouse_cursor: ImGuiMouseCursor, _col_fill: ImU32, _col_border: ImU32, _col_shadow: ImU32);
__c__RenderArrowPointingAt :: (_draw_list: ^mut ImDrawList, _pos: ^mut ImVec2, _half_sz: ^mut ImVec2, _direction: ImGuiDir, _col: ImU32);
__c__RenderArrowDockMenu :: (_draw_list: ^mut ImDrawList, _p_min: ^mut ImVec2, _sz: f32, _col: ImU32);
__c__RenderRectFilledRangeH :: (_draw_list: ^mut ImDrawList, _rect: ^mut ImRect, _col: ImU32, _x_start_norm: f32, _x_end_norm: f32, _rounding: f32);
__c__RenderRectFilledWithHole :: (_draw_list: ^mut ImDrawList, _outer: ^mut ImRect, _inner: ^mut ImRect, _col: ImU32, _rounding: f32);
__c__TextEx :: (_text: ^char8, _text_end: ^char8, _flags: ImGuiTextFlags);
__c__ButtonEx :: (ret: ^mut bool, _label: ^char8, _size_arg: ^mut ImVec2, _flags: ImGuiButtonFlags);
__c__CloseButton :: (ret: ^mut bool, _id: ImGuiID, _pos: ^mut ImVec2);
__c__CollapseButton :: (ret: ^mut bool, _id: ImGuiID, _pos: ^mut ImVec2, _dock_node: ^mut ImGuiDockNode);
__c__ArrowButtonEx :: (ret: ^mut bool, _str_id: ^char8, _dir: ImGuiDir, _size_arg: ^mut ImVec2, _flags: ImGuiButtonFlags);
__c__Scrollbar :: (_axis: ImGuiAxis);
__c__ScrollbarEx :: (ret: ^mut bool, _bb: ^mut ImRect, _id: ImGuiID, _axis: ImGuiAxis, _p_scroll_v: ^mut f32, _avail_v: f32, _contents_v: f32, _rounding_corners: ImDrawCornerFlags);
__c__ImageButtonEx :: (ret: ^mut bool, _id: ImGuiID, _texture_id: ImTextureID, _size: ^mut ImVec2, _uv0: ^mut ImVec2, _uv1: ^mut ImVec2, _padding: ^mut ImVec2, _bg_col: ^mut ImVec4, _tint_col: ^mut ImVec4);
__c__GetWindowScrollbarRect :: (ret: ^mut ImRect, _window: ^mut ImGuiWindow, _axis: ImGuiAxis);
__c__GetWindowScrollbarID :: (ret: ^mut ImGuiID, _window: ^mut ImGuiWindow, _axis: ImGuiAxis);
__c__GetWindowResizeID :: (ret: ^mut ImGuiID, _window: ^mut ImGuiWindow, _n: i32);
__c__SeparatorEx :: (_flags: ImGuiSeparatorFlags);
__c__ButtonBehavior :: (ret: ^mut bool, _bb: ^mut ImRect, _id: ImGuiID, _out_hovered: ^mut bool, _out_held: ^mut bool, _flags: ImGuiButtonFlags);
__c__DragBehavior :: (ret: ^mut bool, _id: ImGuiID, _data_type: ImGuiDataType, _p_v: ^mut void, _v_speed: f32, _p_min: ^mut void, _p_max: ^mut void, _format: ^char8, _flags: ImGuiSliderFlags);
__c__SliderBehavior :: (ret: ^mut bool, _bb: ^mut ImRect, _id: ImGuiID, _data_type: ImGuiDataType, _p_v: ^mut void, _p_min: ^mut void, _p_max: ^mut void, _format: ^char8, _flags: ImGuiSliderFlags, _out_grab_bb: ^mut ImRect);
__c__SplitterBehavior :: (ret: ^mut bool, _bb: ^mut ImRect, _id: ImGuiID, _axis: ImGuiAxis, _size1: ^mut f32, _size2: ^mut f32, _min_size1: f32, _min_size2: f32, _hover_extend: f32, _hover_visibility_delay: f32);
__c__TreeNodeBehavior :: (ret: ^mut bool, _id: ImGuiID, _flags: ImGuiTreeNodeFlags, _label: ^char8, _label_end: ^char8);
__c__TreeNodeBehaviorIsOpen :: (ret: ^mut bool, _id: ImGuiID, _flags: ImGuiTreeNodeFlags);
__c__TreePushOverrideID :: (_id: ImGuiID);
__c__DataTypeGetInfo :: (ret: ^mut ^mut ImGuiDataTypeInfo, _data_type: ImGuiDataType);
__c__DataTypeFormatString :: (ret: ^mut i32, _buf: ^mut char8, _buf_size: i32, _data_type: ImGuiDataType, _p_data: ^mut void, _format: ^char8);
__c__DataTypeApplyOp :: (_data_type: ImGuiDataType, _op: i32, _output: ^mut void, _arg_1: ^mut void, _arg_2: ^mut void);
__c__DataTypeApplyOpFromText :: (ret: ^mut bool, _buf: ^char8, _initial_value_buf: ^char8, _data_type: ImGuiDataType, _p_data: ^mut void, _format: ^char8);
__c__DataTypeCompare :: (ret: ^mut i32, _data_type: ImGuiDataType, _arg_1: ^mut void, _arg_2: ^mut void);
__c__DataTypeClamp :: (ret: ^mut bool, _data_type: ImGuiDataType, _p_data: ^mut void, _p_min: ^mut void, _p_max: ^mut void);
__c__InputTextEx :: (ret: ^mut bool, _label: ^char8, _hint: ^char8, _buf: ^mut char8, _buf_size: i32, _size_arg: ^mut ImVec2, _flags: ImGuiInputTextFlags, _callback: ImGuiInputTextCallback, _user_data: ^mut void);
__c__TempInputText :: (ret: ^mut bool, _bb: ^mut ImRect, _id: ImGuiID, _label: ^char8, _buf: ^mut char8, _buf_size: i32, _flags: ImGuiInputTextFlags);
__c__TempInputScalar :: (ret: ^mut bool, _bb: ^mut ImRect, _id: ImGuiID, _label: ^char8, _data_type: ImGuiDataType, _p_data: ^mut void, _format: ^char8, _p_clamp_min: ^mut void, _p_clamp_max: ^mut void);
__c__ColorTooltip :: (_text: ^char8, _col: ^f32, _flags: ImGuiColorEditFlags);
__c__ColorEditOptionsPopup :: (_col: ^f32, _flags: ImGuiColorEditFlags);
__c__ColorPickerOptionsPopup :: (_ref_col: ^f32, _flags: ImGuiColorEditFlags);
__c__PlotEx :: (ret: ^mut i32, _plot_type: ImGuiPlotType, _label: ^char8, _values_getter: fn(^mut void, i32) -> f32, _data: ^mut void, _values_count: i32, _values_offset: i32, _overlay_text: ^char8, _scale_min: f32, _scale_max: f32, _frame_size: ^mut ImVec2);
__c__ShadeVertsLinearColorGradientKeepAlpha :: (_draw_list: ^mut ImDrawList, _vert_start_idx: i32, _vert_end_idx: i32, _gradient_p0: ^mut ImVec2, _gradient_p1: ^mut ImVec2, _col0: ImU32, _col1: ImU32);
__c__ShadeVertsLinearUV :: (_draw_list: ^mut ImDrawList, _vert_start_idx: i32, _vert_end_idx: i32, _a: ^mut ImVec2, _b: ^mut ImVec2, _uv_a: ^mut ImVec2, _uv_b: ^mut ImVec2, _clamp: bool);
__c__GcCompactTransientWindowBuffers :: (_window: ^mut ImGuiWindow);
__c__GcAwakeTransientWindowBuffers :: (_window: ^mut ImGuiWindow);
__c__ImFontAtlasBuildWithStbTruetype :: (ret: ^mut bool, _atlas: ^mut ImFontAtlas);
__c__ImFontAtlasBuildInit :: (_atlas: ^mut ImFontAtlas);
__c__ImFontAtlasBuildSetupFont :: (_atlas: ^mut ImFontAtlas, _font: ^mut ImFont, _font_config: ^mut ImFontConfig, _ascent: f32, _descent: f32);
__c__ImFontAtlasBuildPackCustomRects :: (_atlas: ^mut ImFontAtlas, _stbrp_context_opaque: ^mut void);
__c__ImFontAtlasBuildFinish :: (_atlas: ^mut ImFontAtlas);
__c__ImFontAtlasBuildRender1bppRectFromString :: (_atlas: ^mut ImFontAtlas, _atlas_x: i32, _atlas_y: i32, _w: i32, _h: i32, _in_str: ^char8, _in_marker_char: char8, _in_marker_pixel_value: u8);
__c__ImFontAtlasBuildMultiplyCalcLookupTable :: (_out_table: ^mut u8, _in_multiply_factor: f32);
__c__ImFontAtlasBuildMultiplyRectAlpha8 :: (_table: ^u8, _pixels: ^mut u8, _x: i32, _y: i32, _w: i32, _h: i32, _stride: i32);
__c__ImGui_ImplGlfw_InitForOpenGL :: (ret: ^mut bool, _window: ^mut GLFWwindow, _install_callbacks: bool);
__c__ImGui_ImplGlfw_InitForVulkan :: (ret: ^mut bool, _window: ^mut GLFWwindow, _install_callbacks: bool);
__c__ImGui_ImplGlfw_Shutdown :: ();
__c__ImGui_ImplGlfw_NewFrame :: ();
__c__ImGui_ImplGlfw_MouseButtonCallback :: (_window: ^mut GLFWwindow, _button: i32, _action: i32, _mods: i32);
__c__ImGui_ImplGlfw_ScrollCallback :: (_window: ^mut GLFWwindow, _xoffset: f64, _yoffset: f64);
__c__ImGui_ImplGlfw_KeyCallback :: (_window: ^mut GLFWwindow, _key: i32, _scancode: i32, _action: i32, _mods: i32);
__c__ImGui_ImplGlfw_CharCallback :: (_window: ^mut GLFWwindow, _c: u32);
__c__ImGui_ImplGlfw_MonitorCallback :: (_monitor: ^mut GLFWmonitor, _event: i32);
